import { IntervalFT, IntervalSE } from './data.structures';
export declare const convertFTtoSE: <T extends IntervalFT>(r: T) => Pick<T, Exclude<keyof T, "from" | "to">> & IntervalSE;
export declare const convertARtoSE: ([start, end]: [number, number]) => IntervalSE;
export declare const convertSEtoFT: <T extends IntervalSE>(r: T) => Pick<T, Exclude<keyof T, "start" | "end">> & IntervalFT;
export declare const convertSEtoAR: (r: IntervalSE) => [number, number];
/**
 * Complement of `intervals` bounded to `boundaries`. Convert space between two consecutive intervals into interval.
 * Keeps extra object properties on `boundaries`.
 * intervals array has to be sorted.
 * Doesn't mutate input. Output keeps input's structure.
 *
 * boundaries | interval(s) | result
 * --- | --- | ---
 * { start: 0, end: 10} | [{ start: 3, end: 7 }] | [{ start: 0, end: 3 }, { start: 7, end: 10 }]
 * { start: 0, end: 10} | [{ start: 2, end: 4 }, { start: 7, end: 8 }] | [{ start: 0, end: 2 }, { start: 4, end: 7 }, { start: 8, end: 10 }]
 *
 * @param boundaries arg1: interval defining boundaries for the complement computation.
 * @param intervals arg2: array of intervals that complement the result.
 * @returns array of intervals.
 */
export declare const complement: <T extends IntervalSE>(boundaries: T, intervals: ReadonlyArray<IntervalSE>) => T[];
/**
 * Test if `intervalA` overlaps with `intervalB`.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 0, end: 10} | { start: 3, end: 7 } | true
 * { start: 0, end: 5} | { start: 5, end: 7 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if overlaps
 */
export declare const isOverlappingSimple: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` overlaps with `intervalB`.
 *
 * Accept array of intervals.
 * Intervals arrays have to be sorted.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 0, end: 10} | { start: 3, end: 7 } | true
 * { start: 0, end: 5} | { start: 5, end: 7 } | false
 * { start: 5, end: 10} | [{ start: 0, end: 4 }, { start: 7, end: 8 }] | true
 *
 * @param intervalA arg1: interval or array of intervals
 * @param intervalB arg2: interval or array of intervals
 * @returns true if overlaps
 */
export declare const isOverlapping: (intervalsA: ReadonlyArray<IntervalSE>, intervalsB: ReadonlyArray<IntervalSE>) => boolean;
/**
 * Test if `intervalA` is adjacent to (meets) `intervalB`.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 0, end: 10} | { start: 3, end: 7 } | false
 * { start: 0, end: 5} | { start: 5, end: 7 } | true
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if adjacent
 */
export declare const isMeeting: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` is before or adjacent `intervalB`.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 0, end: 2} | { start: 3, end: 7 } | true
 * { start: 0, end: 5} | { start: 3, end: 7 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if before
 */
export declare const isBefore: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` is after or adjacent `intervalB`.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 5, end: 10} | { start: 3, end: 4 } | true
 * { start: 5, end: 10} | { start: 3, end: 6 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if after
 */
export declare const isAfter: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` and `intervalB` share the same starting point.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 5, end: 10} | { start: 5, end: 4 } | true
 * { start: 5, end: 10} | { start: 0, end: 10 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if same starting point
 */
export declare const isStarting: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` and `intervalB` share the same ending point.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 5, end: 10} | { start: 0, end: 10 } | true
 * { start: 5, end: 10} | { start: 5, end: 7 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if same ending point
 */
export declare const isEnding: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` occurs in `intervalB`. `intervalsB` act as boundaries. Can share starting and/or ending point.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 2, end: 6} | { start: 0, end: 10 } | true
 * { start: 5, end: 10} | { start: 0, end: 10 } | true
 * { start: 5, end: 10} | { start: 0, end: 9 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if `intervalA` occurs in `intervalB`
 */
export declare const isDuring: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Test if `intervalA` is equivalent to `intervalB`.
 *
 * intervalA | intervalB | result
 * --- | --- | ---
 * { start: 5, end: 10} | { start: 5, end: 10 } | true
 * { start: 5, end: 10} | { start: 0, end: 10 } | false
 *
 * @param intervalA arg1: interval
 * @param intervalB arg2: interval
 * @returns true if equivalent
 */
export declare const isEqual: (a: IntervalSE, b: IntervalSE) => boolean;
/**
 * Simplification of `intervals`. Unify touching or overlapping intervals.
 *
 * Intervals array has to be sorted.
 *
 * Doesn't mutate input. Output keeps input's structure.
 *
 * | intervals A | result |
 * | ----------- | ------ |
 * | [{ start: 3, end: 9 }, { start: 9, end: 13 }, { start: 11, end: 14 }] | [{ start: 3, end: 14 }] |
 *
 * @param intervalA
 */
export declare const simplify: <T extends IntervalSE>(intervals: ReadonlyArray<T>) => T[];
/**
 * Union of `intervals`.
 *
 * Accept array of intervals. Doesn't mutate input. Output keeps input's structure.
 * Intervals arrays have to be sorted.
 *
 * interval(s) A | interval(s) B | result
 * --- | --- | ---
 * [{ start: 0, end: 4}] | [{ start: 3, end: 7 }, { start: 9, end: 11 }] | [{ start: 0, end: 7 }, { start: 9, end: 11 }]
 *
 * @param intervalA arg1: array of intervals
 * @param intervalB arg2: array of intervals
 * @returns union of `arg1` and `arg2`
 */
export declare const unify: <T extends IntervalSE>(intervalsA: ReadonlyArray<T>, intervalsB: ReadonlyArray<T>) => IntervalSE[];
/**
 * Intersection of `intervals`. Does not simplify result. Keeps extra object properties on `intervalB`.
 *
 * `interalA` and `interalB` can have different structure.
 * Accept array of intervals. Doesn't mutate input. Output keeps `intervalB` structure.
 * Intervals arrays have to be sorted.
 *
 * interval(s) A | interval(s) B | result
 * --- | --- | ---
 * { from: 0, to: 4 } | { start: 3, end: 7, foo: 'bar' } | [{ start: 3, end: 4, foo: 'bar' }]
 * { start: 0, end: 10 } | [{ start: 2, end: 5}, { start: 5, end: 8}] | [{ start: 2, end: 5 }, { start: 5, end: 8 }]
 * [{ start: 0, end: 4 }, { start: 8, end: 11 }] | [{ start: 2, end: 9 }, { start: 10, end: 13 }] | [{ start: 2, end: 4 }, { start: 8, end: 9 }, { start: 10, end: 11 }]
 *
 * @param intervalA arg1: array of intervals
 * @param intervalB arg2: array of intervals
 * @returns intersection of `arg1` and `arg2`
 */
export declare const intersect: <T extends IntervalSE>(intervalsA: ReadonlyArray<IntervalSE>, intervalsB: ReadonlyArray<T>) => T[];
/**
 * Merge extra properties of all intervals inside `intervals`, when overlapping, with provided function `mergeFn`.
 * Can also be used to generate an array of intervals without overlaps
 *
 * Doesn't mutate input. Output keeps input's structure.
 * Interval array has to be sorted.
 *
 * parameter | value
 * --- | ---
 * mergeFn | `(a, b) => {...a, data: a.data + b.data }`
 * intervals | `[{ start: 0, end: 10, data: 5 }, { start: 4, end: 7, data: 100 }]`
 * result | `[{ start: 0, end: 4, data: 5 }, { start: 4, end: 7, data: 105 }, { start: 7, end: 10, data: 5 }]`
 * @param mergeFn arg1: function to merge extra properties of overlapping intervals
 * @param intervals arg2: intervals with extra properties.
 */
export declare const merge: <T extends IntervalSE>(mergeFn: (ints: any[]) => any, intervals: ReadonlyArray<T>) => T[];
/**
 * Subtact `base` with `mask`.
 * Keeps extra object properties on `base`.
 *
 * Accept array of intervals. Doesn't mutate input. Output keeps input's structure.
 * Intervals arrays have to be sorted.
 *
 * interval(s) base | interval(s) mask | result
 * --- | --- | ---
 * [{ start: 0, end: 4 }] | [{ start: 3, end: 7 }] | [{ start: 0, end: 3 }]
 * [{ start: 0, end: 4 }, { start: 8, end: 11 }] | [{ start: 2, end: 9 }, { start: 10, end: 13 }] | [{ start: 0, end: 2 }, { start: 9, end: 10 }]
 *
 * @param intervalA arg1: array of intervals
 * @param intervalB arg2: array of intervals
 * @returns intersection of `arg1` and `arg2`
 */
export declare const substract: <T extends IntervalSE>(base: ReadonlyArray<T>, mask: ReadonlyArray<IntervalSE>) => T[];
/**
 * Split `intervals` with `splitIndexes`.
 * Keeps extra object properties on `intervals`.
 * Doesn't mutate input. Output keeps input's structure.
 *
 * splitIndexes | interval(s) | result
 * --- | --- | ---
 * [2, 4] | { start: 0, end: 6, foo: 'bar' } | [{ start: 0, end: 2, foo: 'bar' }, { start: 2, end: 4, foo: 'bar' } { start: 4, end: 6, foo: 'bar' }]
 * [5] | [{ start: 0, end: 7 }, { start: 3, end: 8 }] | [{ start: 0, end: 5 }, { start: 5, end: 7 }, { start: 3, end: 5 }, { start: 5, end: 8 }]
 *
 * @param splitIndexes arg1: defines indexes where intervals are splitted.
 * @param intervals arg2: intervals to be splitted.
 * @returns array of intervals.
 */
export declare const split: <T extends IntervalSE>(splits: ReadonlyArray<number>, intervals: ReadonlyArray<T>) => T[];
