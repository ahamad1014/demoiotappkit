import { v4 } from 'uuid';
import SubscriptionStore from './subscription-store/subscriptionStore';
import DataSourceStore from './data-source-store/dataSourceStore';
import { DataCache } from './data-cache/dataCacheWrapped';
import { requestRange } from './data-cache/requestRange';
import { getRequestInformations } from './data-cache/caching/caching';
import { viewportEndDate, viewportStartDate } from '../common/viewport';
import { MINUTE_IN_MS, parseDuration, SECOND_IN_MS } from '../common/time';
export const DEFAULT_CACHE_SETTINGS = {
    ttlDurationMapping: {
        [1.2 * MINUTE_IN_MS]: SECOND_IN_MS,
        [3 * MINUTE_IN_MS]: 30 * SECOND_IN_MS,
        [20 * MINUTE_IN_MS]: 5 * MINUTE_IN_MS,
    },
};
export class TimeSeriesDataModule {
    /**
     * Create a new data module, optionally with a pre-hydrated data cache.
     *
     */
    constructor(dataSource, configuration = {}) {
        /**
         * Fulfill query
         *
         * Ensure that all requests are initiated required to fulfill the entire query, from start to end.
         * Takes into account the current state of the cache, to determine which data has already been requested, or has expired
         * segments within the cache.
         */
        this.fulfillQueries = async ({ viewport, request, queries, }) => {
            const requestedStreams = await this.dataSourceStore.getRequestsFromQueries({
                queries,
                request,
            });
            const isRequestedDataStream = ({ id, resolution, aggregationType, }) => this.dataCache.shouldRequestDataStream({
                dataStreamId: id,
                resolution: parseDuration(resolution),
                aggregationType,
            });
            const requiredStreams = requestedStreams.filter(isRequestedDataStream);
            const requests = requiredStreams
                .map(({ resolution, id, cacheSettings, aggregationType, meta }) => getRequestInformations({
                request,
                meta,
                store: this.dataCache.getState(),
                start: viewportStartDate(viewport),
                end: viewportEndDate(viewport),
                aggregationType,
                resolution,
                dataStreamId: id,
                cacheSettings: { ...this.cacheSettings, ...cacheSettings },
            }))
                .flat();
            requests.forEach(this.dataCache.onRequest);
            if (requests.length > 0) {
                this.registerRequest({ queries, request }, requests);
            }
        };
        this.getAdjustedViewport = (request) => {
            var _a;
            // Get the date range to request data for.
            // Pass in 'now' for max since we don't want to request for data in the future yet - it doesn't exist yet.
            const { start, end } = requestRange({
                start: viewportStartDate(request.viewport),
                end: viewportEndDate(request.viewport),
                max: new Date(),
            }, (_a = request.settings) === null || _a === void 0 ? void 0 : _a.requestBuffer);
            return { start, end };
        };
        this.getCachedDataStreams = async ({ viewport, queries, emitDataStreams, settings, }) => {
            const requestedStreams = await this.dataSourceStore.getRequestsFromQueries({
                queries,
                request: { viewport, settings },
            });
            // create request information on every dataStream requested
            // so they can be used to get cached data
            const requestInformations = requestedStreams.map((stream) => ({
                start: viewportStartDate(viewport),
                end: viewportEndDate(viewport),
                ...stream,
            }));
            const unsubscribe = this.dataCache.getCachedDataForRange(requestInformations, emitDataStreams);
            return unsubscribe;
        };
        this.subscribeToDataStreams = ({ queries, request }, callback) => {
            const subscriptionId = v4();
            this.subscriptions.addSubscription(subscriptionId, {
                queries,
                request,
                emit: callback,
                fulfill: () => {
                    const viewport = this.getAdjustedViewport(request);
                    if (viewport.start < viewport.end) {
                        this.fulfillQueries({
                            viewport,
                            queries,
                            request,
                        });
                    }
                },
            });
            /**
             * subscription management
             */
            const unsubscribe = () => {
                this.unsubscribe(subscriptionId);
            };
            const update = (subscriptionUpdate) => this.update(subscriptionId, subscriptionUpdate);
            return { unsubscribe, update };
        };
        this.update = async (subscriptionId, subscriptionUpdate) => {
            const subscription = this.subscriptions.getSubscription(subscriptionId);
            const updatedSubscription = { ...subscription, ...subscriptionUpdate };
            if ('queries' in updatedSubscription) {
                return this.subscriptions.updateSubscription(subscriptionId, {
                    ...updatedSubscription,
                    fulfill: () => {
                        this.fulfillQueries({
                            viewport: this.getAdjustedViewport(updatedSubscription.request),
                            queries: updatedSubscription.queries,
                            request: updatedSubscription.request,
                        });
                    },
                });
            }
        };
        this.registerRequest = (subscription, requestInformations) => {
            const { queries, request } = subscription;
            queries.forEach((query) => this.dataSourceStore.initiateRequest({
                request,
                query,
                onSuccess: this.dataCache.onSuccess,
                onError: this.dataCache.onError,
            }, requestInformations));
        };
        /**
         * Unsubscribe from the data module.
         *
         * Prevents the provided callbacks associated with the given subscription from being called, and prevents
         * the previously queried data streams from being queried any longer.
         */
        this.unsubscribe = (subscriptionId) => {
            this.subscriptions.removeSubscription(subscriptionId);
        };
        const { initialDataCache, cacheSettings } = configuration;
        this.dataSourceStore = new DataSourceStore(dataSource);
        this.dataCache = new DataCache(initialDataCache);
        this.cacheSettings = {
            ...DEFAULT_CACHE_SETTINGS,
            ...cacheSettings,
        };
        this.subscriptions = new SubscriptionStore({
            dataSourceStore: this.dataSourceStore,
            dataCache: this.dataCache,
            cacheSettings: this.cacheSettings,
        });
    }
}
