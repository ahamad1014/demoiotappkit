import RequestScheduler from '../request-scheduler/requestScheduler';
import { viewportEndDate } from '../../common/viewport';
import { maxCacheDuration } from '../data-cache/caching/caching';
import * as RefreshRate from './refreshRate';
/**
 * Subscription store
 *
 * Manages the collection of subscriptions
 */
export default class SubscriptionStore {
    constructor({ dataSourceStore, dataCache, cacheSettings, }) {
        this.unsubscribeMap = {};
        this.scheduler = new RequestScheduler();
        this.subscriptions = {};
        this.removeSubscription = (subscriptionId) => {
            if (this.subscriptions[subscriptionId] == null) {
                throw new Error(`Attempted to remove a subscription with an id of "${subscriptionId}", but the requested subscription does not exist.`);
            }
            if (this.unsubscribeMap[subscriptionId]) {
                this.unsubscribeMap[subscriptionId]();
                delete this.unsubscribeMap[subscriptionId];
            }
            delete this.subscriptions[subscriptionId];
        };
        this.getSubscriptions = () => Object.values(this.subscriptions);
        this.getSubscription = (subscriptionId) => this.subscriptions[subscriptionId];
        this.dataCache = dataCache;
        this.dataSourceStore = dataSourceStore;
        this.cacheSettings = cacheSettings;
    }
    getRefreshRate(subscription) {
        var _a, _b;
        const refreshRate = ((_a = subscription.queries
            .filter(RefreshRate.isQueryWithRequestSettings)
            .find((q) => q.requestSettings.refreshRate != null)) === null || _a === void 0 ? void 0 : _a.requestSettings.refreshRate) || ((_b = subscription.request.settings) === null || _b === void 0 ? void 0 : _b.refreshRate);
        return RefreshRate.getValidRefreshRate(refreshRate);
    }
    async addSubscription(subscriptionId, subscription) {
        if (this.subscriptions[subscriptionId] == null) {
            /**
             * If the subscription is query based
             */
            if ('queries' in subscription) {
                subscription.fulfill();
                const refreshRate = this.getRefreshRate(subscription);
                if ('duration' in subscription.request.viewport) {
                    /** has a duration, so periodically request for data without a deadline */
                    this.scheduler.create({
                        id: subscriptionId,
                        cb: () => subscription.fulfill(),
                        refreshRate,
                    });
                }
                else {
                    /** has a static start and end, request until data is unexpireable */
                    this.scheduler.create({
                        id: subscriptionId,
                        cb: () => subscription.fulfill(),
                        refreshRate,
                        refreshExpiration: viewportEndDate(subscription.request.viewport).getTime() +
                            Math.max(...subscription.queries.map((query) => maxCacheDuration({
                                ...this.cacheSettings,
                                ...query.cacheSettings,
                            }))),
                    });
                }
                const { queries, request } = subscription;
                const requestInfos = await this.dataSourceStore.getRequestsFromQueries({
                    queries,
                    request,
                });
                // Subscribe to changes from the data cache
                const unsubscribe = this.dataCache.subscribe(requestInfos, (dataStreams) => subscription.emit({
                    dataStreams,
                    viewport: subscription.request.viewport,
                    thresholds: [],
                }));
                this.unsubscribeMap[subscriptionId] = () => {
                    // unsubscribe from listening to the data cache changes
                    unsubscribe();
                    // unsubscribe from re-occurring requests
                    if (this.scheduler.isScheduled(subscriptionId)) {
                        this.scheduler.remove(subscriptionId);
                    }
                };
                this.subscriptions[subscriptionId] = subscription;
            }
        }
        else {
            throw new Error(`Attempted to add a subscription with an id of "${subscriptionId}", but the provided subscriptionId is already present.`);
        }
    }
    async updateSubscription(subscriptionId, subscriptionUpdate) {
        if (this.subscriptions[subscriptionId] == null) {
            throw new Error(`Attempted to update a subscription with an id of "${subscriptionId}", but the requested subscription does not exist.`);
        }
        const updatedSubscription = {
            ...this.subscriptions[subscriptionId],
            ...subscriptionUpdate,
        };
        this.removeSubscription(subscriptionId);
        await this.addSubscription(subscriptionId, updatedSubscription);
    }
}
