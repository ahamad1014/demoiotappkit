import { MINUTE_IN_MS, SECOND_IN_MS, parseDuration, } from '../../../common/time';
import { getDataStreamStore } from '../getDataStreamStore';
import { addInterval, intersect, subtractIntervals, } from '../../../common/intervalStructure';
import { getExpiredCacheIntervals } from './expiredCacheIntervals';
import { pointBisector } from '../../../common/dataFilters';
export const unexpiredCacheIntervals = (streamStore, ttlDurationMapping) => {
    const expiredCacheIntervals = streamStore.requestHistory
        .map((historicalRequest) => getExpiredCacheIntervals(ttlDurationMapping, historicalRequest))
        .flat();
    const allCachedIntervals = streamStore.requestCache.intervals;
    return allCachedIntervals
        .map((interval) => subtractIntervals(interval, expiredCacheIntervals))
        .flat();
};
// What is considered 'too close', and will cause intervals to merge together.
// One minute was tested on it's impact for data requesting on SWM.
const TOO_CLOSE_MS = MINUTE_IN_MS;
// Don't request anything with less than a second - SiteWise API will return 400
// as it will think the start and the end date are the same if they are not
// far enough apart.
const MINIMUM_INTERVAL = SECOND_IN_MS * 3;
/**
 * Combine Short Intervals
 *
 * Combines intervals of time, to reduce the fracturing of small data-requests,
 * which can cause to excessive network requests.
 *
 * Usually it is better to simply over-request by a couple minutes of data, than initiating more network requests.
 *
 * Assumes combined intervals are sorted, in a strictly ascending order.
 */
const combineShortIntervals = (combinedIntervals, interval) => {
    if (combinedIntervals.length === 0) {
        return [interval];
    }
    const [start, end] = interval;
    const [lastStart, lastEnd] = combinedIntervals[combinedIntervals.length - 1];
    const intervalsAreClose = start - lastEnd < TOO_CLOSE_MS;
    if (!intervalsAreClose) {
        return [...combinedIntervals, interval];
    }
    // combine the last two intervals into one.
    return [...combinedIntervals.slice(0, -1), [lastStart, end]];
};
/**
 * Returns all the date ranges that need to be requested.
 * Returns empty list if there are no date ranges needed to be requested.
 *
 * This takes into account what date intervals for a given stream id and resolution exist,
 * allowing us to only request what is needed
 */
export const getDateRangesToRequest = ({ store, dataStreamId, start, end, resolution, cacheSettings, aggregationType, }) => {
    const streamStore = getDataStreamStore(dataStreamId, resolution, store, aggregationType);
    if (end.getTime() === start.getTime()) {
        // nothing to request
        return [];
    }
    if (streamStore == null) {
        // There is no data present at all, so we know we need to simply request all of the data.
        return [[start, end]];
    }
    // NOTE: Use the request cache since we don't want to request intervals that already have been requested.
    const cacheIntervals = unexpiredCacheIntervals(streamStore, cacheSettings.ttlDurationMapping);
    const millisecondIntervals = subtractIntervals([start.getTime(), end.getTime()], cacheIntervals);
    return millisecondIntervals
        .reduce(combineShortIntervals, [])
        .filter(([startMs, endMs]) => endMs - startMs > MINIMUM_INTERVAL)
        .map(([startMS, endMS]) => [new Date(startMS), new Date(endMS)]);
};
/**
 * Returns all the request information required
 * Returns empty list if there are no date ranges needed to be requested.
 *
 * This takes into account what date intervals for a given stream id and resolution exist,
 * allowing us to only request what is needed.
 *
 * It also includes all the request behaviour pertaining to each date range.
 */
export const getRequestInformations = ({ request, store, dataStreamId, start, meta, end, resolution, aggregationType, cacheSettings, }) => {
    var _a, _b, _c;
    // get sorted date ranges that need to be requested
    const dateRanges = getDateRangesToRequest({
        store,
        dataStreamId,
        start,
        end,
        aggregationType,
        resolution: parseDuration(resolution),
        cacheSettings,
    });
    let requestInformations = [];
    const fetchFromStartToEnd = (_a = request.settings) === null || _a === void 0 ? void 0 : _a.fetchFromStartToEnd;
    // convert date ranges to request information
    if (fetchFromStartToEnd) {
        requestInformations = dateRanges.map(([rangeStart, rangeEnd]) => ({
            start: rangeStart,
            end: rangeEnd,
            id: dataStreamId,
            meta,
            resolution,
            aggregationType,
            fetchFromStartToEnd,
        }));
    }
    // fetchMostRecentBeforeEnd if a recent point doesn't exist in the cache, even with no request informations
    if (((_b = request.settings) === null || _b === void 0 ? void 0 : _b.fetchMostRecentBeforeEnd) &&
        !checkCacheForRecentPoint({
            store,
            dataStreamId,
            aggregationType,
            resolution: parseDuration(resolution),
            start: end,
            cacheSettings,
        })) {
        requestInformations.push({
            start,
            end,
            meta,
            id: dataStreamId,
            resolution,
            fetchMostRecentBeforeEnd: true,
            aggregationType,
        });
    }
    // fetch a leading point if needed and there is no recent point in cache before the start date
    if (((_c = request.settings) === null || _c === void 0 ? void 0 : _c.fetchMostRecentBeforeStart) &&
        !checkCacheForRecentPoint({
            store,
            dataStreamId,
            aggregationType,
            resolution: parseDuration(resolution),
            start,
            cacheSettings,
        })) {
        requestInformations.unshift({
            start,
            end,
            meta,
            id: dataStreamId,
            resolution,
            fetchMostRecentBeforeStart: true,
            aggregationType,
        });
    }
    return requestInformations;
};
export const dataPointCompare = (a, b) => {
    const aTime = a.x;
    const bTime = b.x;
    if (aTime !== bTime) {
        return aTime - bTime;
    }
    if (typeof a.y === 'number' && typeof b.y === 'number') {
        return a.y - b.y;
    }
    const upperA = a.y.toUpperCase();
    const upperB = b.y.toUpperCase();
    if (upperA < upperB) {
        return -1;
    }
    if (upperA > upperB) {
        return 1;
    }
    return 0;
};
export const EMPTY_CACHE = {
    intervals: [],
    items: [],
};
export const createDataPointCache = ({ start, end, data = [], }) => ({
    intervals: [[start.getTime(), end.getTime()]],
    items: [data],
});
export const addToDataPointCache = ({ start, end, data = [], cache, }) => {
    if (data.length === 0 && start.getTime() === end.getTime()) {
        return cache;
    }
    return addInterval(cache, [start.getTime(), end.getTime()], data, dataPointCompare);
};
export const checkCacheForRecentPoint = ({ store, dataStreamId, resolution, start, cacheSettings, aggregationType, }) => {
    const streamStore = getDataStreamStore(dataStreamId, resolution, store, aggregationType);
    if (streamStore && streamStore.dataCache.intervals.length > 0) {
        const { dataCache } = streamStore;
        const cacheIntervals = unexpiredCacheIntervals(streamStore, cacheSettings.ttlDurationMapping);
        const intersectedIntervals = intersect(cacheIntervals, dataCache.intervals);
        const interval = intersectedIntervals.find((inter) => inter[0] <= start.getTime() && start.getTime() <= inter[1]);
        if (interval) {
            const dataPoints = dataCache.items.flat();
            const elementIndex = pointBisector.right(dataPoints, start);
            return (elementIndex !== 0 && dataPoints[elementIndex - 1].x >= interval[0]);
        }
        return false;
    }
    return false;
};
// Validates request config to see if we need to make a fetch Request
// This will expand in future to accomodate more requestConfig variants
export const validateRequestConfig = (requestConfig) => {
    if (requestConfig) {
        return requestConfig.fetchMostRecentBeforeStart;
    }
    return false;
};
// Returns the maximum duration for possible uncached data for given CacheSettings
export const maxCacheDuration = (cacheSettings) => {
    const ttlDurations = Object.keys(cacheSettings.ttlDurationMapping).map((key) => Number(key));
    if (ttlDurations.length === 0) {
        return 0;
    }
    return Math.max(...ttlDurations);
};
