import { AggregateType } from '@aws-sdk/client-iotsitewise';
import type { DataPoint, Primitive, RequestInformation, RequestInformationAndRange } from '../../types';
import type { Interval, IntervalStructure } from '../../../common/intervalStructure';
import type { CacheSettings, DataStreamsStore, DataStreamStore, TTLDurationMapping } from '../types';
import type { TimeSeriesDataRequestSettings, TimeSeriesDataRequest } from '../requestTypes';
export declare const unexpiredCacheIntervals: (streamStore: DataStreamStore, ttlDurationMapping: TTLDurationMapping) => Interval[];
/**
 * Returns all the date ranges that need to be requested.
 * Returns empty list if there are no date ranges needed to be requested.
 *
 * This takes into account what date intervals for a given stream id and resolution exist,
 * allowing us to only request what is needed
 */
export declare const getDateRangesToRequest: ({ store, dataStreamId, start, end, resolution, cacheSettings, aggregationType, }: {
    store: DataStreamsStore;
    dataStreamId: string;
    start: Date;
    end: Date;
    resolution: number;
    cacheSettings: CacheSettings;
    aggregationType?: AggregateType | undefined;
}) => [Date, Date][];
/**
 * Returns all the request information required
 * Returns empty list if there are no date ranges needed to be requested.
 *
 * This takes into account what date intervals for a given stream id and resolution exist,
 * allowing us to only request what is needed.
 *
 * It also includes all the request behaviour pertaining to each date range.
 */
export declare const getRequestInformations: ({ request, store, dataStreamId, start, meta, end, resolution, aggregationType, cacheSettings, }: {
    request: TimeSeriesDataRequest;
    store: DataStreamsStore;
    dataStreamId: string;
    start: Date;
    end: Date;
    aggregationType?: AggregateType | undefined;
    meta?: RequestInformation['meta'];
    resolution: string;
    cacheSettings: CacheSettings;
}) => RequestInformationAndRange[];
export declare const dataPointCompare: <T extends Primitive = number>(a: DataPoint<T>, b: DataPoint<T>) => number;
export declare const EMPTY_CACHE: IntervalStructure<DataPoint<Primitive>>;
/**
 * DataPoint Cache
 *
 * A wrapper around an interval structure.
 */
export type DataPointCache = IntervalStructure<DataPoint<Primitive>>;
export declare const createDataPointCache: ({ start, end, data, }: {
    start: Date;
    end: Date;
    data?: DataPoint<Primitive>[] | undefined;
}) => DataPointCache;
export declare const addToDataPointCache: ({ start, end, data, cache, }: {
    start: Date;
    end: Date;
    cache: DataPointCache;
    data?: DataPoint<Primitive>[] | undefined;
}) => DataPointCache;
export declare const checkCacheForRecentPoint: ({ store, dataStreamId, resolution, start, cacheSettings, aggregationType, }: {
    store: DataStreamsStore;
    dataStreamId: string;
    resolution: number;
    start: Date;
    cacheSettings: CacheSettings;
    aggregationType?: AggregateType | undefined;
}) => boolean;
export declare const validateRequestConfig: (requestConfig: TimeSeriesDataRequestSettings | undefined) => boolean | undefined;
export declare const maxCacheDuration: (cacheSettings: CacheSettings) => number;
//# sourceMappingURL=caching.d.ts.map