import { simplify, substract, intersect as intersectFn } from 'intervals-fn';
const toObjectNotation = ([start, end]) => ({
    start,
    end,
});
const toIntervalNotation = ({ start, end }) => [start, end];
const isBeforeInterval = ([_, aEnd], [bStart]) => aEnd < bStart;
const isAfterInterval = ([aStart], [_, bEnd]) => aStart > bEnd;
const isIntersecting = (a, b) => !isBeforeInterval(a, b) && !isAfterInterval(a, b);
export const isContained = (structure, interval) => structure.intervals.some(([start, end]) => start <= interval[0] && end >= interval[1]);
export const intersect = (aIntervals, bIntervals) => {
    const intersectedIntervals = simplify(intersectFn(aIntervals.map(toObjectNotation), bIntervals.map(toObjectNotation)));
    return intersectedIntervals.map(toIntervalNotation);
};
export const subtractIntervals = (interval, intervals) => {
    const sortedIntervals = intervals
        .sort((i1, i2) => i1[0] - i2[0])
        .map(toObjectNotation);
    const subtractedIntervals = substract([toObjectNotation(interval)], simplify(sortedIntervals));
    return simplify(subtractedIntervals)
        .filter((inter) => inter.start < inter.end)
        .map(toIntervalNotation);
};
// removes duplicates (by timestamp) in a data (Datapoint[][])
const uniqByKeepLast = (data, key) => {
    return data.map((datum) => {
        if (Array.isArray(datum)) {
            return [
                ...new Map(datum.map((d, index) => {
                    if (typeof d === 'object' && !!d) {
                        return [d[key], d];
                    }
                    return [index, d];
                })).values(),
            ];
        }
        else {
            return datum;
        }
    });
};
/**
 * Merges together to lists of items given a way to compare items.
 *
 * Returns back a single list of items, sorted by `compare`, with no duplicates.
 *
 * `aItems` and `bItems` are assumed to be sorted by `compare`.
 *
 * If `aItems` and `bItems` have overlap, always take the items specified in `aItems`
 */
export const mergeItems = (aItems, bItems, compare) => {
    // Empty items edge cases
    if (aItems.length === 0) {
        return bItems;
    }
    if (bItems.length === 0) {
        return aItems;
    }
    // Non-overlapping interval merge cases
    if (compare(aItems[0], bItems[bItems.length - 1]) > 0) {
        return [...bItems, ...aItems];
    }
    if (compare(aItems[aItems.length - 1], bItems[0]) < 0) {
        return [...aItems, ...bItems];
    }
    // Fully contained edge cases
    if (compare(aItems[0], bItems[0]) <= 0 &&
        compare(aItems[aItems.length - 1], bItems[bItems.length - 1]) >= 0) {
        // `aItems` fully contains `bItems`
        return aItems;
    }
    if (compare(bItems[0], aItems[0]) <= 0 &&
        compare(bItems[bItems.length - 1], aItems[aItems.length - 1]) >= 0) {
        // `bItems` fully contains `aItems`
        const itemsBeforeA = bItems.filter((item) => compare(item, aItems[0]) < 0);
        const itemsAfterA = bItems.filter((item) => compare(item, aItems[aItems.length - 1]) > 0);
        return [...itemsBeforeA, ...aItems, ...itemsAfterA];
    }
    // Merge items
    if (compare(aItems[0], bItems[0]) < 0) {
        // `aItems` interval begins before `bItems`
        return [
            ...aItems,
            ...bItems.filter((x) => compare(x, aItems[aItems.length - 1]) > 0),
        ];
    }
    // `bItems` interval begins before `aItems`
    return [...bItems.filter((x) => compare(x, aItems[0]) < 0), ...aItems];
};
export const addInterval = (intervalStructure, interval, items, compare) => {
    const overlappingIntervals = intervalStructure.intervals
        .map((i, index) => ({
        interval: i,
        index,
    }))
        .filter(({ interval: i }) => isIntersecting(interval, i));
    // Combine all overlapping intervals into a single interval
    const combinedInterval = overlappingIntervals.reduce((mergedInterval, { interval: currInterval }) => [
        Math.min(mergedInterval[0], currInterval[0]),
        Math.max(mergedInterval[1], currInterval[1]),
    ], interval);
    // Combine all elements from all overlapping intervals
    const combinedItems = overlappingIntervals.reduce((mergedItems, { index }) => mergeItems(mergedItems, intervalStructure.items[index], compare), items);
    // Get Insert Points
    const i = intervalStructure.intervals.findIndex((int) => isBeforeInterval(interval, int) || isIntersecting(interval, int));
    const insertIndex = i >= 0 ? i : intervalStructure.intervals.length;
    // Apply update
    const updatedIntervals = [...intervalStructure.intervals];
    updatedIntervals.splice(insertIndex, overlappingIntervals.length, combinedInterval);
    const updatedItems = [...intervalStructure.items];
    updatedItems.splice(insertIndex, overlappingIntervals.length, combinedItems);
    // removing duplicate timestamps in an interval
    const updatedItemsUniqueByTimestamp = uniqByKeepLast(updatedItems, 'x');
    return {
        intervals: updatedIntervals,
        items: updatedItemsUniqueByTimestamp,
    };
};
