"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeSeriesDataModule = exports.DEFAULT_CACHE_SETTINGS = void 0;
const uuid_1 = require("uuid");
const subscriptionStore_1 = __importDefault(require("./subscription-store/subscriptionStore"));
const dataSourceStore_1 = __importDefault(require("./data-source-store/dataSourceStore"));
const dataCacheWrapped_1 = require("./data-cache/dataCacheWrapped");
const requestRange_1 = require("./data-cache/requestRange");
const caching_1 = require("./data-cache/caching/caching");
const viewport_1 = require("../common/viewport");
const time_1 = require("../common/time");
exports.DEFAULT_CACHE_SETTINGS = {
    ttlDurationMapping: {
        [1.2 * time_1.MINUTE_IN_MS]: time_1.SECOND_IN_MS,
        [3 * time_1.MINUTE_IN_MS]: 30 * time_1.SECOND_IN_MS,
        [20 * time_1.MINUTE_IN_MS]: 5 * time_1.MINUTE_IN_MS,
    },
};
class TimeSeriesDataModule {
    /**
     * Create a new data module, optionally with a pre-hydrated data cache.
     *
     */
    constructor(dataSource, configuration = {}) {
        /**
         * Fulfill query
         *
         * Ensure that all requests are initiated required to fulfill the entire query, from start to end.
         * Takes into account the current state of the cache, to determine which data has already been requested, or has expired
         * segments within the cache.
         */
        this.fulfillQueries = async ({ viewport, request, queries, }) => {
            const requestedStreams = await this.dataSourceStore.getRequestsFromQueries({
                queries,
                request,
            });
            const isRequestedDataStream = ({ id, resolution, aggregationType, }) => this.dataCache.shouldRequestDataStream({
                dataStreamId: id,
                resolution: (0, time_1.parseDuration)(resolution),
                aggregationType,
            });
            const requiredStreams = requestedStreams.filter(isRequestedDataStream);
            const requests = requiredStreams
                .map(({ resolution, id, cacheSettings, aggregationType, meta }) => (0, caching_1.getRequestInformations)({
                request,
                meta,
                store: this.dataCache.getState(),
                start: (0, viewport_1.viewportStartDate)(viewport),
                end: (0, viewport_1.viewportEndDate)(viewport),
                aggregationType,
                resolution,
                dataStreamId: id,
                cacheSettings: { ...this.cacheSettings, ...cacheSettings },
            }))
                .flat();
            requests.forEach(this.dataCache.onRequest);
            if (requests.length > 0) {
                this.registerRequest({ queries, request }, requests);
            }
        };
        this.getAdjustedViewport = (request) => {
            var _a;
            // Get the date range to request data for.
            // Pass in 'now' for max since we don't want to request for data in the future yet - it doesn't exist yet.
            const { start, end } = (0, requestRange_1.requestRange)({
                start: (0, viewport_1.viewportStartDate)(request.viewport),
                end: (0, viewport_1.viewportEndDate)(request.viewport),
                max: new Date(),
            }, (_a = request.settings) === null || _a === void 0 ? void 0 : _a.requestBuffer);
            return { start, end };
        };
        this.getCachedDataStreams = async ({ viewport, queries, emitDataStreams, settings, }) => {
            const requestedStreams = await this.dataSourceStore.getRequestsFromQueries({
                queries,
                request: { viewport, settings },
            });
            // create request information on every dataStream requested
            // so they can be used to get cached data
            const requestInformations = requestedStreams.map((stream) => ({
                start: (0, viewport_1.viewportStartDate)(viewport),
                end: (0, viewport_1.viewportEndDate)(viewport),
                ...stream,
            }));
            const unsubscribe = this.dataCache.getCachedDataForRange(requestInformations, emitDataStreams);
            return unsubscribe;
        };
        this.subscribeToDataStreams = ({ queries, request }, callback) => {
            const subscriptionId = (0, uuid_1.v4)();
            this.subscriptions.addSubscription(subscriptionId, {
                queries,
                request,
                emit: callback,
                fulfill: () => {
                    const viewport = this.getAdjustedViewport(request);
                    if (viewport.start < viewport.end) {
                        this.fulfillQueries({
                            viewport,
                            queries,
                            request,
                        });
                    }
                },
            });
            /**
             * subscription management
             */
            const unsubscribe = () => {
                this.unsubscribe(subscriptionId);
            };
            const update = (subscriptionUpdate) => this.update(subscriptionId, subscriptionUpdate);
            return { unsubscribe, update };
        };
        this.update = async (subscriptionId, subscriptionUpdate) => {
            const subscription = this.subscriptions.getSubscription(subscriptionId);
            const updatedSubscription = { ...subscription, ...subscriptionUpdate };
            if ('queries' in updatedSubscription) {
                return this.subscriptions.updateSubscription(subscriptionId, {
                    ...updatedSubscription,
                    fulfill: () => {
                        this.fulfillQueries({
                            viewport: this.getAdjustedViewport(updatedSubscription.request),
                            queries: updatedSubscription.queries,
                            request: updatedSubscription.request,
                        });
                    },
                });
            }
        };
        this.registerRequest = (subscription, requestInformations) => {
            const { queries, request } = subscription;
            queries.forEach((query) => this.dataSourceStore.initiateRequest({
                request,
                query,
                onSuccess: this.dataCache.onSuccess,
                onError: this.dataCache.onError,
            }, requestInformations));
        };
        /**
         * Unsubscribe from the data module.
         *
         * Prevents the provided callbacks associated with the given subscription from being called, and prevents
         * the previously queried data streams from being queried any longer.
         */
        this.unsubscribe = (subscriptionId) => {
            this.subscriptions.removeSubscription(subscriptionId);
        };
        const { initialDataCache, cacheSettings } = configuration;
        this.dataSourceStore = new dataSourceStore_1.default(dataSource);
        this.dataCache = new dataCacheWrapped_1.DataCache(initialDataCache);
        this.cacheSettings = {
            ...exports.DEFAULT_CACHE_SETTINGS,
            ...cacheSettings,
        };
        this.subscriptions = new subscriptionStore_1.default({
            dataSourceStore: this.dataSourceStore,
            dataCache: this.dataCache,
            cacheSettings: this.cacheSettings,
        });
    }
}
exports.TimeSeriesDataModule = TimeSeriesDataModule;
