"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataCache = void 0;
const createStore_1 = require("./createStore");
const dataActions_1 = require("./dataActions");
const getDataStreamStore_1 = require("./getDataStreamStore");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const toDataStreams_1 = require("./toDataStreams");
const dateUtils_1 = require("./dateUtils");
/**
 * Referential comparison of information related to the requested information.
 */
const hasRequestedInformationChanged = ({ prevDataCache, currDataCache }, requestInformation) => {
    const prevDataStreamStore = (0, getDataStreamStore_1.getDataStreamStore)(requestInformation.id, requestInformation.resolution, prevDataCache, requestInformation.aggregationType);
    const currDataStreamStore = (0, getDataStreamStore_1.getDataStreamStore)(requestInformation.id, requestInformation.resolution, currDataCache, requestInformation.aggregationType);
    const hasChanged = prevDataStreamStore != currDataStreamStore;
    return hasChanged;
};
/**
 * Data Cache Wrapper
 *
 * A wrapper around the existing data-cache, as is currently used within SiteWise Monitor.
 *
 * This wrapped component allows us to evolve the API of the data-cache, without altering the currently utilized data-cache.
 */
class DataCache {
    constructor(initialDataCache) {
        this.subscribe = (requestInformations, emit) => {
            const subscription = this.observableStore
                .pipe(
            // Filter out any changes that don't effect the requested informations
            (0, operators_1.filter)(({ currDataCache, prevDataCache }) => requestInformations.some((requestInformation) => hasRequestedInformationChanged({
                currDataCache,
                prevDataCache,
            }, requestInformation))))
                .subscribe((stores) => {
                const dataStreams = (0, toDataStreams_1.toDataStreams)({
                    dataStreamsStores: stores.currDataCache,
                    requestInformations: requestInformations,
                });
                emit(dataStreams);
            });
            return () => {
                subscription.unsubscribe();
            };
        };
        this.shouldRequestDataStream = ({ dataStreamId, resolution, aggregationType, }) => {
            const associatedStore = (0, getDataStreamStore_1.getDataStreamStore)(dataStreamId, resolution, this.getState(), aggregationType);
            const hasError = associatedStore ? associatedStore.error != null : false;
            return !hasError;
        };
        this.getState = () => this.dataCache.getState();
        // emits cached data
        this.getCachedDataForRange = (requestInfos, emit) => {
            const subscription = this.observableStore
                .pipe((0, operators_1.delay)(0))
                .subscribe(({ currDataCache }) => {
                const hasLoadedFullIntervalData = requestInfos.every((request) => {
                    const { id, resolution, aggregationType, start, end } = request;
                    const associatedStore = (0, getDataStreamStore_1.getDataStreamStore)(id, resolution, currDataCache, aggregationType);
                    // if no stores are found, then data is uncached
                    if (!associatedStore)
                        return false;
                    // check if cache has correct interval and is not loading more data
                    const hasLoadedData = !associatedStore.isLoading && !associatedStore.isRefreshing;
                    const hasLoadedFullInterval = (0, dateUtils_1.hasIntervalForRange)(associatedStore.dataCache.intervals, { start, end });
                    return hasLoadedData && hasLoadedFullInterval;
                });
                // only emit data streams if all request informations have loaded dataStreams for the required time range
                if (hasLoadedFullIntervalData) {
                    const dataStreams = (0, toDataStreams_1.toDataStreams)({
                        requestInformations: requestInfos,
                        dataStreamsStores: currDataCache,
                    });
                    subscription.unsubscribe();
                    emit(dataStreams);
                }
            });
        };
        /**
         * data-cache bindings
         *
         * data-cache utilizes a redux store, the below methods are for ease of use, so you don't have to worry about
         * coordinating the dispatching of the action throughout the file.
         */
        this.onSuccess = (dataStreams, requestInformation, start, end) => {
            // TODO: `duration` is not an accurate way to determine what _was_ requested.
            //  Need to change then code to utilize the actual start and end date, as utilized by the data source which initiated the request.
            //  For example, if we have queried data for the last day, but it took 1 minute for the query to resolve, we would have the start and the end date
            //  incorrectly offset by one minute with the correct logic.
            dataStreams.forEach((stream) => {
                this.dataCache.dispatch((0, dataActions_1.onSuccessAction)(stream.id, stream, start, end, requestInformation));
            });
        };
        this.onError = ({ id, resolution, error, aggregationType, }) => {
            this.dataCache.dispatch((0, dataActions_1.onErrorAction)(id, resolution, error, aggregationType));
        };
        this.onRequest = (requestInformation) => {
            this.dataCache.dispatch((0, dataActions_1.onRequestAction)(requestInformation));
        };
        this.dataCache = (0, createStore_1.configureStore)(initialDataCache);
        this.observableStore = (0, rxjs_1.from)(this.dataCache).pipe((0, rxjs_1.startWith)(undefined), (0, rxjs_1.pairwise)(), (0, rxjs_1.map)(([prevDataCache, currDataCache]) => ({
            prevDataCache,
            currDataCache,
        })));
    }
}
exports.DataCache = DataCache;
