"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const requestScheduler_1 = __importDefault(require("../request-scheduler/requestScheduler"));
const viewport_1 = require("../../common/viewport");
const caching_1 = require("../data-cache/caching/caching");
const RefreshRate = __importStar(require("./refreshRate"));
/**
 * Subscription store
 *
 * Manages the collection of subscriptions
 */
class SubscriptionStore {
    constructor({ dataSourceStore, dataCache, cacheSettings, }) {
        this.unsubscribeMap = {};
        this.scheduler = new requestScheduler_1.default();
        this.subscriptions = {};
        this.removeSubscription = (subscriptionId) => {
            if (this.subscriptions[subscriptionId] == null) {
                throw new Error(`Attempted to remove a subscription with an id of "${subscriptionId}", but the requested subscription does not exist.`);
            }
            if (this.unsubscribeMap[subscriptionId]) {
                this.unsubscribeMap[subscriptionId]();
                delete this.unsubscribeMap[subscriptionId];
            }
            delete this.subscriptions[subscriptionId];
        };
        this.getSubscriptions = () => Object.values(this.subscriptions);
        this.getSubscription = (subscriptionId) => this.subscriptions[subscriptionId];
        this.dataCache = dataCache;
        this.dataSourceStore = dataSourceStore;
        this.cacheSettings = cacheSettings;
    }
    getRefreshRate(subscription) {
        var _a, _b;
        const refreshRate = ((_a = subscription.queries
            .filter(RefreshRate.isQueryWithRequestSettings)
            .find((q) => q.requestSettings.refreshRate != null)) === null || _a === void 0 ? void 0 : _a.requestSettings.refreshRate) || ((_b = subscription.request.settings) === null || _b === void 0 ? void 0 : _b.refreshRate);
        return RefreshRate.getValidRefreshRate(refreshRate);
    }
    async addSubscription(subscriptionId, subscription) {
        if (this.subscriptions[subscriptionId] == null) {
            /**
             * If the subscription is query based
             */
            if ('queries' in subscription) {
                subscription.fulfill();
                const refreshRate = this.getRefreshRate(subscription);
                if ('duration' in subscription.request.viewport) {
                    /** has a duration, so periodically request for data without a deadline */
                    this.scheduler.create({
                        id: subscriptionId,
                        cb: () => subscription.fulfill(),
                        refreshRate,
                    });
                }
                else {
                    /** has a static start and end, request until data is unexpireable */
                    this.scheduler.create({
                        id: subscriptionId,
                        cb: () => subscription.fulfill(),
                        refreshRate,
                        refreshExpiration: (0, viewport_1.viewportEndDate)(subscription.request.viewport).getTime() +
                            Math.max(...subscription.queries.map((query) => (0, caching_1.maxCacheDuration)({
                                ...this.cacheSettings,
                                ...query.cacheSettings,
                            }))),
                    });
                }
                const { queries, request } = subscription;
                const requestInfos = await this.dataSourceStore.getRequestsFromQueries({
                    queries,
                    request,
                });
                // Subscribe to changes from the data cache
                const unsubscribe = this.dataCache.subscribe(requestInfos, (dataStreams) => subscription.emit({
                    dataStreams,
                    viewport: subscription.request.viewport,
                    thresholds: [],
                }));
                this.unsubscribeMap[subscriptionId] = () => {
                    // unsubscribe from listening to the data cache changes
                    unsubscribe();
                    // unsubscribe from re-occurring requests
                    if (this.scheduler.isScheduled(subscriptionId)) {
                        this.scheduler.remove(subscriptionId);
                    }
                };
                this.subscriptions[subscriptionId] = subscription;
            }
        }
        else {
            throw new Error(`Attempted to add a subscription with an id of "${subscriptionId}", but the provided subscriptionId is already present.`);
        }
    }
    async updateSubscription(subscriptionId, subscriptionUpdate) {
        if (this.subscriptions[subscriptionId] == null) {
            throw new Error(`Attempted to update a subscription with an id of "${subscriptionId}", but the requested subscription does not exist.`);
        }
        const updatedSubscription = {
            ...this.subscriptions[subscriptionId],
            ...subscriptionUpdate,
        };
        this.removeSubscription(subscriptionId);
        await this.addSubscription(subscriptionId, updatedSubscription);
    }
}
exports.default = SubscriptionStore;
