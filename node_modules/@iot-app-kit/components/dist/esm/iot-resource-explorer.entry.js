import { r as registerInstance, h } from './index-7d5b2a6a.js';
import { a2 as BranchReference } from './resolution-2064ad48.js';
import './_commonjsHelpers-f9dc4873.js';

const recursiveParseSitewiseAssetTree = (flattenTree, subTree, parentId) => {
  subTree.forEach((node) => {
    flattenTree.push(Object.assign(Object.assign({}, node.asset), { hasChildren: node.hierarchies.size > 0, parentId }));
    node.hierarchies.forEach((hierarchy) => {
      recursiveParseSitewiseAssetTree(flattenTree, hierarchy.children, node.asset.id);
    });
  });
};
const parseSitewiseAssetTree = (tree) => {
  const flattenTree = [];
  recursiveParseSitewiseAssetTree(flattenTree, tree);
  return flattenTree;
};

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};

function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

const DEFAULT_COLUMNS = [
  {
    sortingField: 'name',
    id: 'name',
    header: 'Asset Name',
    cell: ({ name }) => name,
  },
  {
    sortingField: 'status',
    id: 'status',
    header: 'Status',
    cell: ({ status }) => status === null || status === void 0 ? void 0 : status.state,
  },
  {
    sortingField: 'creationDate',
    id: 'creationDate',
    header: 'Created',
    cell: ({ creationDate }) => creationDate === null || creationDate === void 0 ? void 0 : creationDate.toUTCString(),
  },
  {
    sortingField: 'lastUpdateDate',
    id: 'lastUpdateDate',
    header: 'Updated',
    cell: ({ lastUpdateDate }) => lastUpdateDate === null || lastUpdateDate === void 0 ? void 0 : lastUpdateDate.toUTCString(),
  },
];
const IotResourceExplorer = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.columnDefinitions = DEFAULT_COLUMNS;
    this.filterEnabled = true;
    this.sortingEnabled = true;
    this.paginationEnabled = true;
    this.wrapLines = false;
    this.widgetId = v4();
    this.expanded = false;
    this.items = [];
    this.expandedItems = {};
    this.errors = [];
    this.defaults = {
      selectionType: 'single',
      loadingText: 'loading...',
      filterText: {
        placeholder: 'Filter by name',
        empty: 'No assets found.',
        noMatch: `We can't find a match.`,
      },
      empty: {
        header: 'No assets',
        description: `You don't have any asset.`,
      },
    };
    this.expandNode = (node) => {
      var _a;
      (_a = node.hierarchies) === null || _a === void 0 ? void 0 : _a.forEach((hierarchy) => {
        this.provider.expand(new BranchReference(node.id, hierarchy.id));
      });
    };
  }
  buildProvider() {
    return this.query.build(this.widgetId);
  }
  componentWillLoad() {
    this.provider = this.buildProvider();
    this.provider.subscribe({
      next: (data) => {
        this.items = parseSitewiseAssetTree(data);
      },
      error: (err) => {
        this.errors = err;
      },
    });
  }
  componentWillUnmount() {
    this.provider.unsubscribe();
  }
  watchItems(newItems) {
    if (this.expanded) {
      const newExpandedItems = {};
      newItems.forEach(({ id, hierarchies, hasChildren }) => {
        if (!this.expandedItems[id] && hasChildren) {
          hierarchies === null || hierarchies === void 0 ? void 0 : hierarchies.forEach((hierarchy) => {
            this.provider.expand(new BranchReference(id, hierarchy.id));
          });
          newExpandedItems[id] = true;
        }
      });
      this.expandedItems = Object.assign(Object.assign({}, this.expandedItems), newExpandedItems);
    }
  }
  render() {
    var _a;
    const filtering = this.filterEnabled
      ? this.filterTexts || this.defaults.filterText
      : undefined;
    const collectionOptions = {
      columnDefinitions: this.columnDefinitions,
      keyPropertyName: 'id',
      parentKeyPropertyName: 'parentId',
      selection: {
        keepSelection: true,
      },
      sorting: {
        defaultState: {
          sortingColumn: {
            sortingField: 'name',
          },
          isDescending: true,
        },
      },
      filtering,
    };
    if (this.paginationEnabled) {
      collectionOptions.pagination = { pageSize: 20 };
    }
    let empty = this.defaults.empty;
    if (this.empty) {
      empty = this.empty;
    }
    if (this.errors.length > 0) {
      // TODO: Make use of all the errors
      empty = {
        header: 'Error',
        description: (_a = this.errors[this.errors.length - 1]) === null || _a === void 0 ? void 0 : _a.msg,
      };
    }
    return (h("iot-tree-table", { items: this.items, collectionOptions: collectionOptions, columnDefinitions: this.columnDefinitions, selectionType: this.selectionType || this.defaults.selectionType, loadingText: this.loadingText || this.defaults.loadingText, filterPlaceholder: filtering === null || filtering === void 0 ? void 0 : filtering.placeholder, onExpandChildren: this.expandNode, onSelectionChange: this.onSelectionChange, empty: empty, sortingDisabled: !this.sortingEnabled, wrapLines: this.wrapLines, expanded: this.expanded }));
  }
  static get watchers() { return {
    "items": ["watchItems"]
  }; }
};

export { IotResourceExplorer as iot_resource_explorer };
