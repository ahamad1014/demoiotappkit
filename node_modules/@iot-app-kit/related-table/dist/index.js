var collectionHooks = require('@awsui/collection-hooks');
var React = require('react');
var uuid = require('uuid');
var Button = require('@awsui/components-react/button');
var styled = require('styled-components');
var awsui = require('@awsui/design-tokens');
var Table = require('@awsui/components-react/table');
var Box = require('@awsui/components-react/box');
var TextFilter = require('@awsui/components-react/text-filter');
var Pagination = require('@awsui/components-react/pagination');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return n;
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var Button__default = /*#__PURE__*/_interopDefaultLegacy(Button);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var awsui__namespace = /*#__PURE__*/_interopNamespace(awsui);
var Table__default = /*#__PURE__*/_interopDefaultLegacy(Table);
var Box__default = /*#__PURE__*/_interopDefaultLegacy(Box);
var TextFilter__default = /*#__PURE__*/_interopDefaultLegacy(TextFilter);
var Pagination__default = /*#__PURE__*/_interopDefaultLegacy(Pagination);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}

exports.ExpandableTableNodeStatus = void 0;
(function (ExpandableTableNodeStatus) {
  ExpandableTableNodeStatus[ExpandableTableNodeStatus["normal"] = 0] = "normal";
  ExpandableTableNodeStatus[ExpandableTableNodeStatus["loading"] = 1] = "loading";
  ExpandableTableNodeStatus[ExpandableTableNodeStatus["emptyChildren"] = 2] = "emptyChildren";
})(exports.ExpandableTableNodeStatus || (exports.ExpandableTableNodeStatus = {}));
exports.LinePrefixTypes = void 0;
(function (LinePrefixTypes) {
  LinePrefixTypes["MiddleChild"] = "MiddleChild";
  LinePrefixTypes["LastChild"] = "LastChild";
  LinePrefixTypes["ChildOfMiddleChild"] = "ChildOfMiddleChild";
  LinePrefixTypes["ChildOfLastChild"] = "ChildOfLastChild";
  LinePrefixTypes["Indentation"] = "Indentation";
})(exports.LinePrefixTypes || (exports.LinePrefixTypes = {}));
var InternalTreeNode = /*#__PURE__*/function () {
  function InternalTreeNode(params, metadata) {
    this.hasChildren = false;
    this.id = uuid.v4();
    this.metadata = {
      prefix: [],
      children: [],
      status: exports.ExpandableTableNodeStatus.normal,
      expanded: false,
      visible: false
    };
    Object.assign(this, params);
    this.metadata = _extends({}, this.metadata, metadata);
  }
  var _proto = InternalTreeNode.prototype;
  _proto.addChild = function addChild(child) {
    this.metadata.children.push(child);
  };
  _proto.removeAllChildren = function removeAllChildren() {
    this.metadata.children = [];
  };
  _proto.getChildren = function getChildren() {
    return this.metadata.children;
  };
  _proto.getParent = function getParent() {
    return this.metadata.parent;
  };
  _proto.toggleExpandCollapse = function toggleExpandCollapse() {
    this.metadata.expanded = !this.metadata.expanded;
  };
  _proto.isExpanded = function isExpanded() {
    return this.metadata.expanded;
  };
  _proto.isVisible = function isVisible() {
    return this.metadata.visible;
  };
  _proto.getMetadata = function getMetadata() {
    return this.metadata;
  };
  _proto.getPrefix = function getPrefix() {
    return this.metadata.prefix;
  };
  _proto.getStatus = function getStatus() {
    return this.metadata.status;
  };
  _proto.setStatus = function setStatus(status) {
    this.metadata.status = status;
  };
  _proto.setVisible = function setVisible(visible) {
    this.metadata.visible = visible;
  };
  _proto.setParentNode = function setParentNode(parentNode) {
    this.metadata.parent = parentNode;
  };
  _proto.buildPrefix = function buildPrefix(lastChild, parentLastChildPath) {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var prefix = [exports.LinePrefixTypes.Indentation, lastChild ? exports.LinePrefixTypes.LastChild : exports.LinePrefixTypes.MiddleChild];
    for (var i = parentLastChildPath.length - 1; i >= 1; i -= 1) {
      var isParentLastChild = parentLastChildPath[i];
      var treeLineMode = isParentLastChild ? exports.LinePrefixTypes.ChildOfLastChild : exports.LinePrefixTypes.ChildOfMiddleChild;
      prefix.splice(1, 0, treeLineMode);
    }
    this.metadata.prefix = prefix;
  };
  return InternalTreeNode;
}();
var TreeNode = InternalTreeNode;

var removeNode = function removeNode(node, keyPropertyName, treeMap) {
  var key = node[keyPropertyName];
  if (node.getParent()) {
    var _node$getParent;
    var parentChildren = (_node$getParent = node.getParent()) == null ? void 0 : _node$getParent.getChildren();
    var childIndex = parentChildren == null ? void 0 : parentChildren.findIndex(function (child) {
      return child === node;
    });
    if (childIndex != null) {
      parentChildren == null || parentChildren.splice(childIndex, 1);
    }
    node.setParentNode(undefined);
  }
  node.getChildren().forEach(function (child) {
    return removeNode(child, keyPropertyName, treeMap);
  });
  node.removeAllChildren();
  treeMap["delete"](key);
};
function cleanupTree(keyPropertyName, treeMap, staleNodeKeys) {
  staleNodeKeys.forEach(function (key) {
    var node = treeMap.get(key);
    if (node) {
      removeNode(node, keyPropertyName, treeMap);
    }
  });
}

var createOrSetParentNode = function createOrSetParentNode(node, treeMap, keyPropertyName, parentKeyPropertyName) {
  var parentKey = node[parentKeyPropertyName];
  if (parentKey) {
    var _TreeNode;
    var parentNode = treeMap.get(parentKey) || new TreeNode((_TreeNode = {}, _TreeNode[keyPropertyName] = parentKey, _TreeNode));
    if (parentNode.getChildren().length === 0 || node.getParent() !== parentNode) {
      node.setParentNode(parentNode);
      parentNode.addChild(node);
    }
    treeMap.set(parentKey, parentNode);
  }
};
var updateNode = function updateNode(node, newData) {
  Object.keys(newData).forEach(function (prop) {
    // eslint-disable-next-line no-param-reassign
    node[prop] = newData[prop];
  });
};
var createNode = function createNode(item, treeMap, keyPropertyName, parentKeyPropertyName) {
  var key = item[keyPropertyName];
  var node = treeMap.get(key);
  if (node) {
    // in case exists just updates
    updateNode(node, item);
  } else {
    node = new TreeNode(item);
  }
  createOrSetParentNode(node, treeMap, keyPropertyName, parentKeyPropertyName);
  treeMap.set(key, node);
  return node;
};
var prepareNode = function prepareNode(node, treeMap, keyPropertyName) {
  var key = node[keyPropertyName];
  var parent = node.getParent();
  var isVisible = parent ? parent.isExpanded() && parent.isVisible() : true;
  node.setVisible(isVisible);
  node.setStatus(node.hasChildren || node.getChildren().length > 0 ? exports.ExpandableTableNodeStatus.normal : exports.ExpandableTableNodeStatus.emptyChildren);
  treeMap.set(key, node);
  return node;
};
var buildTreeNodes = function buildTreeNodes(items, treeMap, keyPropertyName, parentKeyPropertyName) {
  var staleNodeKeys = new Set(Array.from(treeMap.keys()));
  var treeNodes = items.map(function (item) {
    var key = item[keyPropertyName];
    staleNodeKeys["delete"](key);
    return createNode(item, treeMap, keyPropertyName, parentKeyPropertyName);
  }).map(function (node) {
    return prepareNode(node, treeMap, keyPropertyName);
  }).filter(function (node) {
    return typeof node.getParent() === 'undefined';
  });
  cleanupTree(keyPropertyName, treeMap, staleNodeKeys);
  return treeNodes;
};
var recursiveBuildTreePrefix = function recursiveBuildTreePrefix(node, index, parentLastChildPath) {
  var parent = node.getParent();
  var isLastChild = parent ? parent.getChildren().length - 1 === index : true;
  node.buildPrefix(isLastChild, parentLastChildPath);
  node.getChildren().forEach(function (child, childIndex) {
    return recursiveBuildTreePrefix(child, childIndex, parentLastChildPath.concat([isLastChild]));
  });
  return node;
};
var buildTreePrefix = function buildTreePrefix(tree) {
  return tree.map(function (node, index) {
    return recursiveBuildTreePrefix(node, index, []);
  });
};

function expandOrCollapseChildren(node, treeMap, keyPropertyName) {
  node.getChildren().forEach(function (child) {
    var key = child[keyPropertyName];
    child.setVisible(node.isExpanded() && node.isVisible());
    treeMap.set(key, child);
    expandOrCollapseChildren(child, treeMap, keyPropertyName);
  });
}

function filteringFunction(item, filteringText, filteringFields, customFilteringFunction) {
  if (filteringText.length === 0) {
    return item.isVisible();
  }
  var filterMatched;
  if (customFilteringFunction) {
    filterMatched = customFilteringFunction(item, filteringText, filteringFields);
  } else {
    var fields = filteringFields || Object.keys(item);
    var lowFilteringText = filteringText.toLowerCase();
    filterMatched = fields.some(function (key) {
      return String(item[key]).toLowerCase().indexOf(lowFilteringText) > -1;
    });
  }
  if (!filterMatched) {
    var childrenFiltered = item.getChildren().map(function (child) {
      return filteringFunction(child, filteringText, filteringFields);
    }).find(function (found) {
      return found;
    });
    return typeof childrenFiltered !== 'undefined';
  }
  return filterMatched;
}

var recursiveFlatTree = function recursiveFlatTree(tree, flattenTree) {
  tree.forEach(function (node) {
    flattenTree.push(node);
    if (node.getChildren().length) {
      recursiveFlatTree(node.getChildren(), flattenTree);
    }
  });
};
var flatTree = function flatTree(tree) {
  var flattenTree = [];
  recursiveFlatTree(tree, flattenTree);
  return flattenTree;
};

var defaultComparator = function defaultComparator(sortingField) {
  return function (row1, row2) {
    var _row1$sortingField, _row2$sortingField;
    // Use empty string as a default value, because it works well to compare with both strings and numbers:
    // Every number can be casted to a string, but not every string can be casted to a meaningful number,
    // sometimes it is NaN.
    var value1 = (_row1$sortingField = row1[sortingField]) != null ? _row1$sortingField : '';
    var value2 = (_row2$sortingField = row2[sortingField]) != null ? _row2$sortingField : '';
    if (typeof value1 === 'string' && typeof value2 === 'string') {
      return value1.localeCompare(value2);
    }
    if (value1 < value2) {
      return -1;
    }
    // use loose comparison to handle inconsistent data types like undefined, null
    // eslint-disable-next-line eqeqeq
    return value1 == value2 ? 0 : 1;
  };
};
var sortTree = function sortTree(tree, sortState, columnsDefinitions) {
  var sortingColumn = sortState.sortingColumn;
  if (sortingColumn && sortingColumn.sortingField) {
    var columnDefinition = columnsDefinitions.find(function (column) {
      return column.sortingField === sortingColumn.sortingField;
    });
    var direction = sortState.isDescending ? -1 : 1;
    var comparator = (columnDefinition == null ? void 0 : columnDefinition.sortingComparator) || defaultComparator(sortState.sortingColumn.sortingField);
    tree.sort(function (a, b) {
      return comparator(a, b) * direction;
    }).forEach(function (node) {
      return sortTree(node.getChildren(), sortState, columnsDefinitions);
    });
  }
};

var _excluded = ["keyPropertyName", "parentKeyPropertyName", "columnDefinitions"];
var useTreeCollection = function useTreeCollection(items, props, expanded) {
  var _collectionProps$sort;
  if (expanded === void 0) {
    expanded = false;
  }
  var keyPropertyName = props.keyPropertyName,
    parentKeyPropertyName = props.parentKeyPropertyName,
    columnDefinitions = props.columnDefinitions,
    collectionProps = _objectWithoutPropertiesLoose(props, _excluded);
  var _useState = React.useState(new Map()),
    treeMap = _useState[0],
    setTreeMap = _useState[1];
  var _useState2 = React.useState([]),
    nodes = _useState2[0],
    setNodes = _useState2[1];
  var _useState3 = React.useState(_extends({}, ((_collectionProps$sort = collectionProps.sorting) == null ? void 0 : _collectionProps$sort.defaultState) || {})),
    sortState = _useState3[0],
    setSortState = _useState3[1];
  var _useState4 = React.useState(columnDefinitions),
    columnsDefinitions = _useState4[0];
  var _useState5 = React.useState({}),
    nodesExpanded = _useState5[0],
    addNodesExpanded = _useState5[1];
  React.useEffect(function () {
    var treeNodes = buildTreeNodes(items, treeMap, keyPropertyName, parentKeyPropertyName);
    sortTree(treeNodes, sortState, columnsDefinitions);
    // only builds prefix after building and sorting the tree
    var tree = buildTreePrefix(treeNodes);
    setNodes(flatTree(tree));
  }, [items, keyPropertyName, parentKeyPropertyName, sortState, columnsDefinitions, treeMap]);
  var expandNode = function expandNode(node) {
    if (node) {
      var key = node[keyPropertyName];
      var internalNode = nodes.find(function (n) {
        return n[keyPropertyName] === key;
      });
      if (internalNode) {
        internalNode.toggleExpandCollapse();
        expandOrCollapseChildren(internalNode, treeMap, keyPropertyName);
        treeMap.set(key, internalNode);
      }
      var updatedNodes = nodes.concat([]);
      setNodes(updatedNodes);
      setTreeMap(treeMap);
    }
  };
  var reset = function reset() {
    setNodes([]);
    setTreeMap(new Map());
  };
  var internalCollectionProps = _extends({}, collectionProps, {
    sorting: undefined,
    filtering: _extends({}, collectionProps.filtering || {}, {
      filteringFunction: function filteringFunction$1(item, filteringText, filteringFields) {
        var _collectionProps$filt;
        return filteringFunction(item, filteringText, filteringFields, (_collectionProps$filt = collectionProps.filtering) == null ? void 0 : _collectionProps$filt.filteringFunction);
      }
    })
  });
  React.useEffect(function () {
    if (expanded) {
      var newNodesExpanded = {};
      nodes.forEach(function (node) {
        if (!nodesExpanded[node.id]) {
          if (!node.isExpanded()) {
            node.toggleExpandCollapse();
          }
          node.setVisible(true);
          newNodesExpanded[node.id] = true;
        }
      });
      if (Object.keys(newNodesExpanded).length > 0) {
        addNodesExpanded(_extends({}, nodesExpanded, newNodesExpanded));
      }
    }
  }, [nodesExpanded, nodes, expanded]);
  var collectionResult = collectionHooks.useCollection(nodes, internalCollectionProps);
  var useCollectionResult = _extends({}, collectionResult, {
    collectionProps: _extends({}, collectionResult.collectionProps, {
      sortingColumn: sortState.sortingColumn,
      sortingDescending: sortState.isDescending,
      onSortingChange: function onSortingChange(event) {
        setSortState(event.detail);
        var customOnSortingChange = collectionResult.collectionProps.onSortingChange;
        if (customOnSortingChange) {
          customOnSortingChange(event);
        }
      }
    })
  });
  return _extends({
    expandNode: expandNode,
    reset: reset
  }, useCollectionResult);
};

var _templateObject, _templateObject2, _templateObject3, _templateObject4;
var Wrapper = styled__default["default"].div(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n  position: relative;\n  margin-top: -1rem;\n  margin-bottom: -1rem;\n  margin-left: -1rem;\n  height: ", "%;\n"])), function (props) {
  return props.height;
});
var LeftPad = styled__default["default"].div(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  margin-left: ", "rem;\n"])), function (_ref) {
  var length = _ref.length;
  return length || 0;
});
var EmptySpace = styled__default["default"].span(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: ", "rem;\n  height: ", "rem;\n"])), function (props) {
  return props.width;
}, function (props) {
  return props.height;
});
var ButtonWrapper = styled__default["default"].div(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["\n  align-self: flex-start;\n"])));

/* eslint-disable react/no-array-index-key */
var TABLE_ROW_HEIGHT_PERCENT$1 = 100;
var WRAPPER_EXTRA_HEIGHT_PERCENT$1 = 25;
var WRAPPER_VERTICAL_MARGIN_DIFF = 0.5;
var BUTTON_PADDING_DIFF = 0.3;
var ICON_BUTTON_WIDTH_PERCENT = 100;
var ICON_BUTTON_MIDPOINT_X = ICON_BUTTON_WIDTH_PERCENT / 2;
var ICON_BUTTON_MIDPOINT_Y = TABLE_ROW_HEIGHT_PERCENT$1 / 2;
var SVG_WIDTH_IN_REM = 2.0;
var AWSUI_TOP_MARGIN_DIFF = 0.2;
var AWSUI_SVG_WIDTH_IN_REM = 1.7;
var Theme;
(function (Theme) {
  Theme["INTERNAL"] = "INTERNAL";
  Theme["AWSUI"] = "AWSUI";
})(Theme || (Theme = {}));
var Dir;
(function (Dir) {
  Dir[Dir["Top"] = 0] = "Top";
  Dir[Dir["Bottom"] = 1] = "Bottom";
  Dir[Dir["LittleBottom"] = 2] = "LittleBottom";
  Dir[Dir["Right"] = 3] = "Right";
})(Dir || (Dir = {}));
var getLines = function getLines(directions) {
  return directions.map(function (dir, index) {
    var y1 = TABLE_ROW_HEIGHT_PERCENT$1;
    var y2 = ICON_BUTTON_MIDPOINT_Y;
    if (dir === Dir.Top) {
      y1 = 0;
    }
    if (dir === Dir.Right) {
      y1 = ICON_BUTTON_MIDPOINT_Y;
    }
    if (dir === Dir.LittleBottom) {
      y2 = 0;
    }
    var x2 = ICON_BUTTON_MIDPOINT_X;
    if (dir === Dir.Right) {
      x2 = ICON_BUTTON_WIDTH_PERCENT;
    }
    return /*#__PURE__*/React__default["default"].createElement("line", {
      style: {
        stroke: awsui__namespace.colorBorderDividerDefault,
        strokeWidth: 2,
        vectorEffect: 'non-scaling-stroke'
      },
      key: "Line" + index,
      x1: ICON_BUTTON_MIDPOINT_X + "%",
      x2: x2 + "%",
      y1: y1 + "%",
      y2: y2 + "%"
    });
  });
};
var getTopMargin = function getTopMargin(isLittleBottom, theme) {
  var topMarginInternal = isLittleBottom ? 1.5 + WRAPPER_VERTICAL_MARGIN_DIFF : "-" + WRAPPER_VERTICAL_MARGIN_DIFF;
  var topMarginOpenSource = isLittleBottom ? 1.3 + AWSUI_TOP_MARGIN_DIFF : "-" + AWSUI_TOP_MARGIN_DIFF;
  return theme === Theme.INTERNAL ? topMarginInternal : topMarginOpenSource;
};
var getHeight = function getHeight(width, hasRightLine, theme) {
  var heightInternal = hasRightLine ? width * 2 + "rem" : TABLE_ROW_HEIGHT_PERCENT$1 + WRAPPER_EXTRA_HEIGHT_PERCENT$1 + "%";
  var heightOpenSource = hasRightLine ? width + 0.7 + "rem" : TABLE_ROW_HEIGHT_PERCENT$1 + WRAPPER_EXTRA_HEIGHT_PERCENT$1 + "%";
  return theme === Theme.INTERNAL ? heightInternal : heightOpenSource;
};
var createLinesSvg = function createLinesSvg(directions, theme, index) {
  var width = theme === Theme.INTERNAL ? SVG_WIDTH_IN_REM : AWSUI_SVG_WIDTH_IN_REM;
  var leftPos = (index - 1) * 2;
  var rightPos = leftPos + width;
  var rightLine = directions.find(function (dir) {
    return dir === Dir.Right;
  });
  var lines = [directions.filter(function (dir) {
    return dir !== Dir.Right;
  })];
  if (rightLine) {
    lines.push([rightLine]);
  }
  return lines.map(function (lineDirections) {
    var isLittleBottom = lineDirections.length === 1 && lineDirections[0] === Dir.LittleBottom;
    var isRightLineOnly = lineDirections.length === 1 && lineDirections[0] === Dir.Right;
    var isTopWithRightLine = lineDirections.length === 1 && lineDirections[0] === Dir.Top && !!rightLine;
    var paddingLeft = theme === Theme.INTERNAL ? BUTTON_PADDING_DIFF + "rem" : '';
    var topMargin = getTopMargin(isLittleBottom, theme);
    var height = getHeight(width, isRightLineOnly || isTopWithRightLine, theme);
    var viewBox = isRightLineOnly || isTopWithRightLine ? "0 0 " + width + " " + width * 2 : "0 0 " + width + " " + TABLE_ROW_HEIGHT_PERCENT$1;
    return /*#__PURE__*/React__default["default"].createElement("svg", {
      key: "" + leftPos + lineDirections.join('_') + index,
      style: {
        margin: topMargin + "rem 0 0 0",
        paddingLeft: paddingLeft,
        position: 'absolute',
        top: 0,
        left: leftPos + "rem",
        right: rightPos + "rem",
        bottom: 0,
        width: width + "rem",
        height: height
      },
      viewBox: viewBox,
      preserveAspectRatio: "none"
    }, getLines(lineDirections));
  });
};
function createPrefixLines(node, theme, alwaysExpanded) {
  if (alwaysExpanded === void 0) {
    alwaysExpanded = false;
  }
  var prefixSequence = [];
  node.getPrefix().forEach(function (prefix, index) {
    switch (prefix) {
      case exports.LinePrefixTypes.Indentation: // Fallthrough, used for external readability
      case exports.LinePrefixTypes.ChildOfLastChild:
        break;
      case exports.LinePrefixTypes.LastChild:
        prefixSequence.splice.apply(prefixSequence, [index, 0].concat(createLinesSvg([Dir.Top, Dir.Right], theme, index)));
        break;
      case exports.LinePrefixTypes.ChildOfMiddleChild:
        prefixSequence.splice.apply(prefixSequence, [index, 0].concat(createLinesSvg([Dir.Top, Dir.Bottom], theme, index)));
        break;
      case exports.LinePrefixTypes.MiddleChild:
        prefixSequence.splice.apply(prefixSequence, [index, 0].concat(createLinesSvg([Dir.Top, Dir.Bottom, Dir.Right], theme, index)));
        break;
      default:
        prefixSequence.push( /*#__PURE__*/React__default["default"].createElement("span", {
          key: "empty"
        }));
    }
  });
  if ((node.isExpanded() || alwaysExpanded) && node.getChildren().length > 0) {
    prefixSequence.splice.apply(prefixSequence, [prefixSequence.length - 1, 0].concat(createLinesSvg([Dir.LittleBottom], theme, node.getPrefix().length || 1)));
  }
  return prefixSequence;
}

var THEME = 'AWSUI';

var TABLE_ROW_HEIGHT_PERCENT = 100;
var WRAPPER_EXTRA_HEIGHT_PERCENT = 25;
var MARGIN_LEFT_REM_MULTIPLICATOR = 2;
var noAction = function noAction() {};
var theme = THEME;
var emptySpaceHeight = theme === Theme.AWSUI ? 2 : 3;
var emptySpaceWidth = theme === Theme.AWSUI ? 0.4 : 0.5;
function createToggleButton(props) {
  var node = props.node,
    onClick = props.onClick,
    alwaysExpanded = props.alwaysExpanded;
  var icon = node.isExpanded() || alwaysExpanded ? 'treeview-collapse' : 'treeview-expand';
  return node.getChildren().length > 0 || node.hasChildren ? /*#__PURE__*/React__default["default"].createElement(ButtonWrapper, null, /*#__PURE__*/React__default["default"].createElement(Button__default["default"], {
    disabled: node.getStatus() !== exports.ExpandableTableNodeStatus.normal,
    variant: "icon",
    iconName: icon,
    onClick: alwaysExpanded ? noAction : onClick
  })) : /*#__PURE__*/React__default["default"].createElement(EmptySpace, {
    height: emptySpaceHeight,
    width: emptySpaceWidth
  });
}
var ButtonWithTreeLines = React.memo(function ButtonWithTreeLinesComp(props) {
  var node = props.node,
    content = props.content,
    alwaysExpanded = props.alwaysExpanded;
  var leftPadLength = node.getPrefix().length ? MARGIN_LEFT_REM_MULTIPLICATOR * (node.getPrefix().length - 1) : 0;
  return /*#__PURE__*/React__default["default"].createElement(Wrapper, {
    height: TABLE_ROW_HEIGHT_PERCENT + WRAPPER_EXTRA_HEIGHT_PERCENT
  }, /*#__PURE__*/React__default["default"].createElement(LeftPad, {
    length: leftPadLength
  }, /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, createPrefixLines(node, theme, alwaysExpanded), createToggleButton(props), content)));
});

function RelatedTable(props) {
  var columnDefinitions = props.columnDefinitions,
    _props$items = props.items,
    items = _props$items === void 0 ? [] : _props$items,
    expandChildren = props.expandChildren,
    _props$expandColumnPo = props.expandColumnPosition,
    expandColumnPosition = _props$expandColumnPo === void 0 ? 1 : _props$expandColumnPo,
    _props$filteringText = props.filteringText,
    filteringText = _props$filteringText === void 0 ? '' : _props$filteringText;
  var isFiltering = filteringText !== '';
  var zeroBasedColumnPos = expandColumnPosition - 1;
  var columns = [].concat(columnDefinitions);
  var columnToExpand = columns[zeroBasedColumnPos];
  columns[zeroBasedColumnPos] = _extends({}, columnToExpand, {
    cell: function cell(node) {
      var cell = columnToExpand == null ? void 0 : columnToExpand.cell.apply(columnToExpand, [node].concat([].slice.call(arguments, 1)));
      return /*#__PURE__*/React__default["default"].createElement(ButtonWithTreeLines, {
        alwaysExpanded: isFiltering,
        node: node,
        content: cell,
        onClick: function onClick() {
          expandChildren(node);
        }
      });
    }
  });
  return /*#__PURE__*/React__default["default"].createElement(Table__default["default"], _extends({}, props, {
    columnDefinitions: columns,
    items: items
  }));
}

var EmptyState = function EmptyState(props) {
  var header = props.header,
    description = props.description;
  return /*#__PURE__*/React__namespace.createElement(Box__default["default"], {
    textAlign: "center",
    color: "inherit"
  }, header && /*#__PURE__*/React__namespace.createElement(Box__default["default"], {
    variant: "strong",
    textAlign: "center",
    color: "inherit"
  }, header), description && /*#__PURE__*/React__namespace.createElement(Box__default["default"], {
    variant: "p",
    padding: {
      bottom: 's'
    },
    color: "inherit"
  }, description));
};

var withUseTreeCollection = function withUseTreeCollection(RelatedTableComp) {
  return function (wrapperProps) {
    var items = wrapperProps.items,
      empty = wrapperProps.empty,
      columnDefinitions = wrapperProps.columnDefinitions,
      collectionOptions = wrapperProps.collectionOptions,
      _expandChildren = wrapperProps.expandChildren,
      filterPlaceholder = wrapperProps.filterPlaceholder,
      _onSortingChange = wrapperProps.onSortingChange,
      _onSelectionChange = wrapperProps.onSelectionChange,
      expanded = wrapperProps.expanded;
    var _useTreeCollection = useTreeCollection(items, _extends({}, collectionOptions, {
        columnDefinitions: columnDefinitions
      }), expanded),
      expandNode = _useTreeCollection.expandNode,
      tree = _useTreeCollection.items,
      collectionProps = _useTreeCollection.collectionProps,
      filterProps = _useTreeCollection.filterProps,
      paginationProps = _useTreeCollection.paginationProps;
    var emptyComponent = React.createElement(EmptyState, empty);
    var filterComponent = React.createElement(TextFilter__default["default"], _extends({}, filterProps, {
      filteringPlaceholder: filterPlaceholder || ''
    }));
    var paginationComponent = React.createElement(Pagination__default["default"], paginationProps);
    var hocProps = _extends({}, wrapperProps, collectionProps, filterProps, paginationProps, {
      columnDefinitions: columnDefinitions,
      items: tree,
      empty: emptyComponent,
      filter: filterPlaceholder ? filterComponent : null,
      pagination: collectionOptions.pagination ? paginationComponent : null,
      expandChildren: function expandChildren(node) {
        expandNode(node);
        _expandChildren(node);
      },
      onSortingChange: function onSortingChange(event) {
        if (_onSortingChange) {
          _onSortingChange(event);
        }
        if (collectionProps.onSortingChange) {
          collectionProps.onSortingChange(event);
        }
      },
      onSelectionChange: function onSelectionChange(event) {
        if (_onSelectionChange) {
          _onSelectionChange(event);
        }
        if (collectionProps.onSelectionChange) {
          collectionProps.onSelectionChange(event);
        }
      }
    });
    return /*#__PURE__*/React__default["default"].createElement(RelatedTableComp, hocProps);
  };
};

exports.ButtonWithTreeLines = ButtonWithTreeLines;
exports.ButtonWrapper = ButtonWrapper;
exports.EmptySpace = EmptySpace;
exports.EmptyState = EmptyState;
exports.LeftPad = LeftPad;
exports.MARGIN_LEFT_REM_MULTIPLICATOR = MARGIN_LEFT_REM_MULTIPLICATOR;
exports.RelatedTable = RelatedTable;
exports.TreeNode = TreeNode;
exports.Wrapper = Wrapper;
exports.buildTreeNodes = buildTreeNodes;
exports.buildTreePrefix = buildTreePrefix;
exports.cleanupTree = cleanupTree;
exports.expandOrCollapseChildren = expandOrCollapseChildren;
exports.filteringFunction = filteringFunction;
exports.flatTree = flatTree;
exports.recursiveBuildTreePrefix = recursiveBuildTreePrefix;
exports.sortTree = sortTree;
exports.useTreeCollection = useTreeCollection;
exports.withUseTreeCollection = withUseTreeCollection;
//# sourceMappingURL=index.js.map
