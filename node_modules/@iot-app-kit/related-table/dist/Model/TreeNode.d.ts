export declare enum ExpandableTableNodeStatus {
    normal = 0,
    loading = 1,
    emptyChildren = 2
}
export declare enum LinePrefixTypes {
    MiddleChild = "MiddleChild",
    LastChild = "LastChild",
    ChildOfMiddleChild = "ChildOfMiddleChild",
    ChildOfLastChild = "ChildOfLastChild",
    Indentation = "Indentation"
}
export interface Metadata<T> {
    prefix: LinePrefixTypes[];
    children: ITreeNode<T>[];
    status: ExpandableTableNodeStatus;
    expanded: boolean;
    visible: boolean;
    parent?: ITreeNode<T>;
}
export type TreeMap<T> = Map<string, ITreeNode<T>>;
declare class InternalTreeNode<T> {
    hasChildren: boolean;
    id: string;
    private metadata;
    constructor(params: T, metadata?: Metadata<T>);
    addChild(child: ITreeNode<T>): void;
    removeAllChildren(): void;
    getChildren(): ITreeNode<T>[];
    getParent(): ITreeNode<T> | undefined;
    toggleExpandCollapse(): void;
    isExpanded(): boolean;
    isVisible(): boolean;
    getMetadata(): Metadata<T>;
    getPrefix(): LinePrefixTypes[];
    getStatus(): ExpandableTableNodeStatus;
    setStatus(status: ExpandableTableNodeStatus): void;
    setVisible(visible: boolean): void;
    setParentNode(parentNode: any): void;
    buildPrefix(lastChild: boolean, parentLastChildPath: boolean[]): void;
}
export type ITreeNode<T> = InternalTreeNode<T> & T;
export declare const TreeNode: new <T>(props: T, metadata?: Metadata<T> | undefined) => ITreeNode<T>;
export {};
//# sourceMappingURL=TreeNode.d.ts.map