import { Annotation, Annotations, AnnotationValue, Threshold, YAnnotation } from '../types';
import { Primitive, ThresholdDataTypes, ViewPort } from '../../../../utils/dataTypes';
/**
 * Returns only thresholds defined for number
 * @param thresholds
 */
export declare const getNumberThresholds: (thresholds: Threshold[]) => Threshold[];
/**
 * Returns only annotations defined for numbers
 * @param annotations
 */
export declare const getNumberAnnotations: (annotations: Annotations) => Annotations;
/**
 * Returns an array of the higher priority thresholds.
 *
 * If there is only one threshold with the higher priority severity, returns an
 * array with just that one threshold.
 *
 * If there are multiple thresholds with the same higher priority threshold,
 * returns an array with those thresholds.
 *
 * @param {Array.<Threshold>} t1Array
 * @param {Threshold} t2
 * @returns {Array.<Threshold>}
 */
export declare const isHigherPriorityThresholds: (t1Array: Threshold[], t2: Threshold) => Threshold[];
/**
 * Returns an array with the most important thresholds.
 *
 * The most important thresholds are the visuals which are most important to a user
 * This is determined via the `severity`. Lower severity means highest importance.
 *
 * If no thresholds are present with `severity`, an array with all thresholds is returned.
 *
 * @param {Array.<Threshold>} thresholds
 * @returns {Array.<Threshold>}
 */
export declare const highestPriorityThresholds: (thresholds: Threshold[]) => Threshold[];
/**
 * Getters
 */
export declare const getColor: (annotation: Annotation<AnnotationValue>) => string;
export declare const getValueAndText: ({ annotation, resolution, viewport, }: {
    annotation: Annotation<AnnotationValue>;
    resolution: number;
    viewport: ViewPort;
}) => string;
export declare const getText: (annotation: Annotation<AnnotationValue>) => string;
export declare const getLabelTextVisibility: (annotation: Annotation<AnnotationValue>) => string;
export declare const getValueTextVisibility: (annotation: YAnnotation) => string;
export declare const getValueAndTextVisibility: (annotation: Annotation<AnnotationValue>) => string;
export declare const getValueText: ({ annotation, resolution, viewport, formatText, }: {
    annotation: Annotation<AnnotationValue> | Threshold;
    resolution: number;
    viewport: ViewPort;
    formatText: boolean;
}) => string;
export declare const isThresholdBreached: (value: ThresholdDataTypes, threshold: Threshold) => boolean;
/**
 * Given a list of thresholds, we sort the by the value of the threshold from least to greatest and
 * by the comparators order from least to greatest
 *
 * In the event of multiple thresholds with the same value, the threshold with the highest order will be the
 * one that takes precedence, and other rules colliding will be ignored.
 *
 * Below is an example of sorted threshold:
 *   2 2  2 2     5 5  5 5
 *  >= > <= <    >= > <= <
 */
export declare const sortThreshold: (thresholds: Threshold[]) => Threshold[];
/**
 * Gets the most relevant threshold which is considered breached by a given value.
 *
 * The most relevant threshold to a point is determined by the threshold value and its comparator.
 *
 * When there are two or more relevant thresholds to a point,
 *
 * 1) When the value is positive, then we will take the upper threshold, which is the greater one
 *
 * 2) When the value is negative, then we will take the lower threshold, which is the lesser one.
 */
export declare const getBreachedThreshold: (value: Primitive, thresholds: Threshold[]) => Threshold | undefined;
export declare const isThreshold: (t: Partial<Threshold<Primitive>>) => t is Threshold<Primitive>;
export declare const getThresholds: (annotations: Annotations | undefined) => Threshold[];
