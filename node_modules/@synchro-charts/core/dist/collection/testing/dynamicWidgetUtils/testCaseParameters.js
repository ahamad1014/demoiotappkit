var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as queryString from 'query-string';
import { LEGEND } from './constants';
const parseBool = (str) => str === 'true';
const deserializeAnnotations = (str) => {
    const annotations = JSON.parse(str);
    const { x } = annotations;
    const deserializeXAnnotation = (xAnnotation) => (Object.assign(Object.assign({}, xAnnotation), { value: new Date(xAnnotation.value) }));
    return Object.assign(Object.assign({}, annotations), { x: x != null ? x.map(deserializeXAnnotation) : undefined });
};
export const SCREEN_SIZE = {
    width: 700,
    height: 450,
};
export const constructSearchQuery = (_a) => {
    var { viewportStart, viewportEnd, dataStreams, asyncDataStreams, alarms, dataStreamInfos, legend, tableColumns, annotations, messageOverrides, axis, width, height } = _a, 
    // Props that can be directly serialized, i.e. numbers, booleans, and strings
    serializableProps = __rest(_a, ["viewportStart", "viewportEnd", "dataStreams", "asyncDataStreams", "alarms", "dataStreamInfos", "legend", "tableColumns", "annotations", "messageOverrides", "axis", "width", "height"]);
    return queryString.stringify(Object.assign({ 
        // manually serialize fields that require it.
        annotations: annotations && JSON.stringify(annotations), legend: legend && JSON.stringify(legend), dataStreamInfos: dataStreamInfos && JSON.stringify(dataStreamInfos), dataStreams: dataStreams && JSON.stringify(dataStreams), asyncDataStreams: asyncDataStreams && JSON.stringify(asyncDataStreams), alarms: alarms && JSON.stringify(alarms), viewportStart: viewportStart && viewportStart.toISOString(), viewportEnd: viewportEnd && viewportEnd.toISOString(), tableColumns: tableColumns && JSON.stringify(tableColumns), messageOverrides: messageOverrides && JSON.stringify(messageOverrides), axis: axis && JSON.stringify(axis), width: width && JSON.stringify(width), height: height && JSON.stringify(height) }, serializableProps));
};
const deserializeDataStream = (almostDataStream) => (Object.assign(Object.assign({}, almostDataStream), { data: almostDataStream.data.map((point) => ({ x: Number(point.x), y: point.y })) }));
export const testCaseParameters = () => {
    const query = queryString.parse(window.location.search);
    // Instructions for extending: default should be undefined, or if required, some empty state.
    // DO NOT send mock data here! it should be the bare minimum to render. Consider this the default empty state.
    return {
        alarms: query.alarms ? JSON.parse(query.alarms) : undefined,
        width: query.width ? JSON.parse(query.width) : undefined,
        axis: query.axis ? JSON.parse(query.axis) : undefined,
        height: query.height ? JSON.parse(query.height) : undefined,
        duration: query.duration ? JSON.parse(query.duration) : undefined,
        errMsg: query.errMsg,
        gestures: query.gestures != null ? parseBool(query.gestures) : true,
        delayBeforeDataLoads: query.delayBeforeDataLoads != null ? JSON.parse(query.delayBeforeDataLoads) : 0,
        dataStreamInfos: query.dataStreamInfos != null ? JSON.parse(query.dataStreamInfos) : [],
        tableColumns: query.tableColumns != null ? JSON.parse(query.tableColumns) : [],
        legend: query.legend != null ? JSON.parse(query.legend) : LEGEND,
        messageOverrides: query.messageOverrides != null ? JSON.parse(query.messageOverrides) : undefined,
        componentTag: query.componentTag != null ? query.componentTag : 'sc-line-chart',
        // deserialize fields that require it.
        displayInfoNames: query.displayInfoNames ? parseBool(query.displayInfoNames) : false,
        annotations: query.annotations != null ? deserializeAnnotations(query.annotations) : undefined,
        isEditing: query.isEditing != null ? parseBool(query.isEditing) : false,
        hasError: query.hasError != null ? parseBool(query.hasError) : false,
        dataStreams: query.dataStreams != null ? JSON.parse(query.dataStreams).map(deserializeDataStream) : [],
        asyncDataStreams: query.asyncDataStreams != null ? JSON.parse(query.asyncDataStreams).map(deserializeDataStream) : [],
        viewportStart: query.viewportStart != null ? new Date(query.viewportStart) : new Date(2000, 0, 0),
        viewportEnd: query.viewportEnd != null ? new Date(query.viewportEnd) : new Date(2000, 0, 1),
    };
};
