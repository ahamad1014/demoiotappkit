import { BufferAttribute, DoubleSide, InstancedBufferAttribute, InstancedBufferGeometry, InstancedMesh, RawShaderMaterial, } from 'three';
import statusVert from './status.vert';
import statusFrag from './status.frag';
import { numDataPoints, vertices } from '../sc-webgl-base-chart/utils';
import { getCSSColorByString } from '../common/getCSSColorByString';
import { STATUS_MARGIN_TOP_PX, DEFAULT_STATUS_BAR_COLOR_1, DEFAULT_STATUS_BAR_COLOR_2, HEIGHT } from './constants';
import { getBreachedThreshold } from '../common/annotations/utils';
import { getDistanceFromDuration } from '../common/getDistanceFromDuration';
// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated
// up front per `ChartScene`.
export const NUM_POSITION_COMPONENTS = 2; // (x, y)
export const NUM_STATUS_COMPONENTS = 4; // (x, y, width, height)
const NUM_COLOR_COMPONENTS = 3; // (r, g, b)
const numStatuses = (streamVertexSets) => streamVertexSets.reduce((totalStatuses, streamVertexSet) => {
    const streamStatuses = Math.max(streamVertexSet.length, 0);
    return totalStatuses + streamStatuses;
}, 0);
/**
 * Returns clip space width of the bar
 */
const getWidth = ({ nextX, currX, toClipSpace, alarms, }) => {
    const expires = alarms ? alarms.expires : undefined;
    if (expires != null) {
        // If we have a staleness, render the bar until it either:
        //  - collides with the next point's x value
        //  - extends to the duration of the staleness
        const maxWidth = getDistanceFromDuration(toClipSpace, expires);
        if (nextX == null) {
            return maxWidth;
        }
        return Math.min(getDistanceFromDuration(toClipSpace, nextX - currX), maxWidth);
    }
    // If we have a point that comes after this point, extend till that point
    if (nextX != null) {
        return getDistanceFromDuration(toClipSpace, nextX - currX);
    }
    // Extend bar 'til present time
    return getDistanceFromDuration(toClipSpace, Date.now() - currX);
};
const updateMesh = ({ dataStreams, mesh, toClipSpace, thresholds, thresholdOptions, chartSize, alarms, }) => {
    const streamVertexSets = dataStreams.map(stream => vertices(stream, stream.resolution));
    // Set the number of instances of the status are to be rendered.
    // eslint-disable-next-line no-param-reassign
    mesh.count = numStatuses(streamVertexSets);
    const { geometry } = mesh;
    const { color, status } = geometry.attributes;
    let statusIndex = 0;
    let colorIndex = 0;
    /** Layout */
    const rowHeight = HEIGHT / dataStreams.length;
    const margin = STATUS_MARGIN_TOP_PX / chartSize.height;
    const vizHeight = rowHeight - margin;
    streamVertexSets.forEach((streamVertexSet, setIndex) => {
        let prevY;
        let currentDefaultGrayColor = DEFAULT_STATUS_BAR_COLOR_1;
        streamVertexSet.forEach((currVertex, v) => {
            const nextVertex = streamVertexSet[v + 1];
            const [nextX = undefined] = nextVertex || [];
            const [currX, currY] = currVertex;
            if (prevY != null && prevY !== currY) {
                // Swap grays if data value has changed since last point. Don't want to change color of the data point has the same value as the previous data point.
                currentDefaultGrayColor =
                    currentDefaultGrayColor === DEFAULT_STATUS_BAR_COLOR_1
                        ? DEFAULT_STATUS_BAR_COLOR_2
                        : DEFAULT_STATUS_BAR_COLOR_1;
            }
            /**
             * Color Buffer Construction
             */
            const breachedThreshold = getBreachedThreshold(currY, thresholds);
            if (breachedThreshold == null || !thresholdOptions.showColor) {
                const [r, g, b] = currentDefaultGrayColor;
                // The status-timeline alternates between two grays as a default color.
                // This provides visual contrast when the data value changes, without
                // requiring a user to specify every threshold in advance.
                // In certain use cases of the status-timeline, the values visualized cannot be known ahead of time,
                // but users still need to be able to visually differentiate when they change.
                color.array[colorIndex] = r;
                color.array[colorIndex + 1] = g;
                color.array[colorIndex + 2] = b;
            }
            else {
                const [rr, gg, bb] = getCSSColorByString(breachedThreshold.color);
                // Set breached threshold color (r, g, b)
                color.array[colorIndex] = rr;
                color.array[colorIndex + 1] = gg;
                color.array[colorIndex + 2] = bb;
            }
            // Increment Indexes by the associated stride of the buffer
            colorIndex += NUM_COLOR_COMPONENTS;
            /**
             * Position Buffer Construction
             *
             * The 'y range' varies from 0 to 1 (HEIGHT). We need to convert pixels over to clip space
             */
            // status x
            status.array[statusIndex] = toClipSpace(currX);
            // status y
            status.array[statusIndex + 1] = HEIGHT - rowHeight * (setIndex + 1);
            // status width
            status.array[statusIndex + 2] = getWidth({ currX, nextX, toClipSpace, alarms });
            // status height
            status.array[statusIndex + 3] = vizHeight;
            // Increment Indexes by the associated stride of the buffer
            statusIndex += NUM_STATUS_COMPONENTS;
            prevY = currY;
        });
    });
    status.needsUpdate = true;
    color.needsUpdate = true;
};
// https://wwwtyro.net/2019/11/18/instanced-lines.html
// 2d vertices composing of two triangles which make up a square
// (0, 1) - - - (1, 1)
//   |  \         |
//   |     \      |
//   |        \   |
// (0, 0) - - - (1, 0)
const unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];
const initializeGeometry = (geometry, bufferSize) => {
    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));
    geometry.setAttribute('status', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_STATUS_COMPONENTS), NUM_STATUS_COMPONENTS, false));
    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));
};
export const statusMesh = ({ alarms, dataStreams, toClipSpace, bufferFactor, minBufferSize, thresholdOptions, thresholds, chartSize, }) => {
    const instGeo = new InstancedBufferGeometry();
    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);
    // Create and populate geometry
    initializeGeometry(instGeo, bufferSize);
    /**
     * Create Status Mesh
     *
     * The representation of the statuses on a status chart.
     *
     * Utilizes an instance of a single unit square, which then gets
     * stretched and transposed across the canvas.
     */
    const statusChartMaterial = new RawShaderMaterial({
        vertexShader: statusVert,
        fragmentShader: statusFrag,
        side: DoubleSide,
        transparent: false,
    });
    const mesh = new InstancedMesh(instGeo, statusChartMaterial, bufferSize);
    updateMesh({
        dataStreams,
        mesh,
        toClipSpace,
        thresholds,
        thresholdOptions,
        chartSize,
        alarms,
    });
    // Prevent bounding sphere from being called
    mesh.frustumCulled = false;
    return mesh;
};
export const updateStatusMesh = ({ alarms, statuses, dataStreams, toClipSpace, thresholdOptions, thresholds, chartSize, hasDataChanged, hasAnnotationChanged, hasSizeChanged, }) => {
    if (hasDataChanged || hasAnnotationChanged || hasSizeChanged) {
        updateMesh({
            dataStreams,
            mesh: statuses,
            toClipSpace,
            thresholds,
            thresholdOptions,
            chartSize,
            alarms,
        });
    }
};
