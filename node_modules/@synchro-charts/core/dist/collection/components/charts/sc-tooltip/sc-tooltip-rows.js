import { Component, h, Prop } from '@stencil/core';
import uniq from 'lodash.uniq';
import { activePoints } from '../sc-webgl-base-chart/activePoints';
import { getAggregationFrequency } from '../../sc-data-stream-name/helper';
import { displayDate } from '../../../utils/time';
import { tooltipPosition } from './tooltipPosition';
import { trendLinePoints } from './trendLinePoints';
import { isDefined, isSupportedDataType } from '../../../utils/predicates';
import { breachedThreshold } from '../common/annotations/breachedThreshold';
import { sortTooltipPoints } from './sort';
import { StreamType } from '../../../utils/dataConstants';
const AGGREGATED_LEVEL = 'average';
const TOOLTIP_ROW_HEIGHT = 21;
const TOOLTIP_EMPTY_HEIGHT = 71;
const X_OFFSET = 8;
/**
 * The Display Component for the tool tip.
 *
 * Renders the tooltip, tooltip container, the tooltip line and the tool tip rows
 */
export class ScTooltipRows {
    constructor() {
        this.trendResults = [];
        this.showDataStreamColor = true;
        this.sortPoints = true;
        /** Total height of the tool tip display */
        this.tooltipHeight = (numRows) => numRows * TOOLTIP_ROW_HEIGHT + TOOLTIP_EMPTY_HEIGHT;
        /**
         * Returns the color to display the value within a legend row.
         *
         * Takes into account whether the data stream is breached.
         * Does not take into account associated alarms
         */
        this.rowsValueColorAndIcon = (id, { y }, date) => {
            const dataStream = this.dataStreams.find(info => info.id === id);
            if (dataStream == null) {
                return undefined;
            }
            const threshold = breachedThreshold({
                date,
                value: y,
                thresholds: this.thresholds,
                dataStreams: [],
                dataStream,
            });
            return threshold != null ? { color: threshold.color, icon: threshold.icon } : undefined;
        };
        /**
         * The point in time which is 'actively' being viewed within the tooltip.
         */
        this.getDisplayedDate = (points) => {
            const resolutions = this.dataStreams.map(({ resolution }) => resolution);
            const minResolution = resolutions.length > 0 ? Math.min(...resolutions) : 0;
            if (minResolution === 0) {
                return this.selectedDate;
            }
            const firstPoint = points[0] && points[0].point ? new Date(points[0].point.x) : undefined;
            const firstPointTrend = this.trendResults[0] ? this.trendResults[0].startDate : undefined;
            return firstPoint || firstPointTrend || this.selectedDate;
        };
        /**
         * Returns the data which is supported
         *
         * i.e. if `supportsString` is false, do not return any data streams of string type
         */
        this.visualizedDataStreams = () => {
            const streams = this.dataStreams.filter(isSupportedDataType(this.supportString));
            if (this.visualizesAlarms) {
                // Visualize all infos with a valid data type
                return streams;
            }
            // Visualize only property-infos (non-alarms) with a valid data type
            return streams.filter(({ streamType }) => streamType !== StreamType.ALARM);
        };
        /**
         * Return each of the 'points' to be displayed
         *
         * each of these will correspond to one `tooltip-row`
         */
        this.getTooltipPoints = () => {
            const resolutions = this.dataStreams.map(({ resolution }) => resolution);
            const minResolution = resolutions.length > 0 ? Math.min(...resolutions) : 0;
            const dataPoints = activePoints({
                viewport: this.viewport,
                dataStreams: this.visualizedDataStreams(),
                dataAlignment: this.dataAlignment,
                selectedDate: this.selectedDate,
                allowMultipleDates: minResolution === 0,
                maxDurationFromDate: this.maxDurationFromDate,
            }).map(p => (Object.assign(Object.assign({}, p), { type: "data" /* DATA */ })));
            const trendPoints = trendLinePoints({
                dataStreams: this.dataStreams,
                displayedDate: this.getDisplayedDate(dataPoints),
                trendResults: this.trendResults,
            });
            const tooltipPoints = [...dataPoints, ...trendPoints];
            // Either sort, or place them in the order the infos are presented
            const points = this.sortPoints
                ? tooltipPoints.sort(sortTooltipPoints(p => p.y))
                : this.dataStreams.map(({ id }) => tooltipPoints.find(p => p.streamId === id)).filter(isDefined);
            // Optionally filter out anything without a point
            if (this.showBlankTooltipRows) {
                return points;
            }
            return points.filter(p => p.point != null);
        };
    }
    render() {
        const resolutions = this.dataStreams.map(({ resolution }) => resolution);
        const minResolution = resolutions.length > 0 ? Math.min(...resolutions) : 0;
        const isCrossResolution = uniq(resolutions).length > 1;
        const points = this.getTooltipPoints();
        const displayedDate = this.getDisplayedDate(points);
        const position = tooltipPosition({
            points,
            resolution: minResolution,
            viewport: this.viewport,
            size: this.size,
            selectedTimestamp: this.selectedDate.getTime(),
        });
        if (points.length === 0) {
            // If there are no tooltip points to display on the tool tip, don't display anything.
            return null;
        }
        if (position == null) {
            return null;
        }
        const tooltipContainerTop = this.top != null
            ? `${this.top}px`
            : `${position.y - (this.tooltipHeight(points.length) * 3) / 4 - this.size.height}px`;
        const displayToolTipOnLeftSize = position.x >= this.size.width / 2;
        const toolTipPositioning = displayToolTipOnLeftSize
            ? {
                right: `${-position.x + X_OFFSET}px`,
                transform: 'translateX(-100%)',
            }
            : {
                left: `${position.x + X_OFFSET}px`,
            };
        return (h("div", { class: "awsui" },
            h("div", { class: "tooltip-line", style: {
                    left: `${position.x}px`,
                    height: `${this.size.height}px`,
                } }),
            h("div", { class: "tooltip-container", style: Object.assign({ top: tooltipContainerTop }, toolTipPositioning) },
                h("div", { class: "awsui-util-shadow awsui-util-p-s" },
                    h("small", { class: { 'awsui-util-d-b': true, 'left-offset': !this.showDataStreamColor } }, displayDate(displayedDate, minResolution, this.viewport)),
                    !isCrossResolution && (h("small", { class: { 'awsui-util-d-b': true, 'awsui-util-mb-s': true, 'left-offset': !this.showDataStreamColor } }, getAggregationFrequency(minResolution, AGGREGATED_LEVEL))),
                    points.map(tooltipPoint => {
                        const { streamId } = tooltipPoint;
                        /** Find the data stream info associated with the given data point */
                        const dataStream = this.dataStreams.find(({ id }) => id === streamId);
                        if (!dataStream) {
                            /* eslint-disable-next-line  no-console */
                            console.warn(`No data stream info associated with id ${streamId}`);
                            return null;
                        }
                        const { color: valueColor = undefined, icon = undefined } = (tooltipPoint.point && this.rowsValueColorAndIcon(streamId, tooltipPoint.point, displayedDate)) || {};
                        return (h("sc-tooltip-row", { key: `${tooltipPoint.streamId}-${tooltipPoint.type}`, showDataStreamColor: this.showDataStreamColor, label: tooltipPoint.label || dataStream.name, resolution: isCrossResolution ? dataStream.resolution : undefined, color: tooltipPoint.color || dataStream.color || 'black', point: tooltipPoint.point, pointType: tooltipPoint.type, valueColor: valueColor, icon: icon }));
                    })))));
    }
    static get is() { return "sc-tooltip-rows"; }
    static get properties() { return {
        "selectedDate": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Date",
                "resolved": "Date",
                "references": {
                    "Date": {
                        "location": "global"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "size": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "SizeConfig",
                "resolved": "SizeConfig",
                "references": {
                    "SizeConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "dataStreams": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "DataStream[]",
                "resolved": "DataStream<Primitive>[]",
                "references": {
                    "DataStream": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "viewport": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "ViewPort",
                "resolved": "MinimalLiveViewport & { start: Date; end: Date; yMin: number; yMax: number; duration?: number | undefined; } | MinimalStaticViewport & { start: Date; end: Date; yMin: number; yMax: number; duration?: number | undefined; }",
                "references": {
                    "ViewPort": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "thresholds": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Threshold[]",
                "resolved": "Threshold<Primitive>[]",
                "references": {
                    "Threshold": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "trendResults": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "TrendResult[]",
                "resolved": "LinearRegressionResult[]",
                "references": {
                    "TrendResult": {
                        "location": "import",
                        "path": "../common/trends/types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "[]"
        },
        "maxDurationFromDate": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number | undefined",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "max-duration-from-date",
            "reflect": false
        },
        "showDataStreamColor": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "show-data-stream-color",
            "reflect": false,
            "defaultValue": "true"
        },
        "supportString": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "support-string",
            "reflect": false
        },
        "showBlankTooltipRows": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "show-blank-tooltip-rows",
            "reflect": false
        },
        "visualizesAlarms": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "visualizes-alarms",
            "reflect": false
        },
        "dataAlignment": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "DATA_ALIGNMENT",
                "resolved": "DATA_ALIGNMENT.EITHER | DATA_ALIGNMENT.LEFT | DATA_ALIGNMENT.RIGHT",
                "references": {
                    "DATA_ALIGNMENT": {
                        "location": "import",
                        "path": "../common/constants"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "If we are drawing data from the data timestamp to timestamp + resolution\nwe want the tooltip to align on the left side\n\nOtherwise we are drawing the data from timestamp - resolution to timestamp\nthen we want the tooltip to align on the right side"
            },
            "attribute": "data-alignment",
            "reflect": false
        },
        "top": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number | undefined",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": "CSS Top property for the tooltip container"
            },
            "attribute": "top",
            "reflect": false
        },
        "sortPoints": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean | undefined",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "sort-points",
            "reflect": false,
            "defaultValue": "true"
        }
    }; }
}
