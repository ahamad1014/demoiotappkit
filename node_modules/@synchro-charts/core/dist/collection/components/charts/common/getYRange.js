const orderOfMagnitude = (n) => {
    const o = Math.log10(Math.abs(n));
    return Math.ceil(o);
};
const roundedMagnitude = (n) => {
    const m = orderOfMagnitude(n);
    return n > 0 ? 10 ** m : -1 * 10 ** m;
};
const DEFAULT_ROUNDING_DIVISOR = 50;
const roundedToNearest = (rMag, n) => (roundUp) => {
    const a = n / (rMag / DEFAULT_ROUNDING_DIVISOR);
    const b = rMag / DEFAULT_ROUNDING_DIVISOR;
    return roundUp ? Math.ceil(a) * b : Math.floor(a) * b;
};
const roundToOrderOfMagnitude = (n, min) => {
    if (n === 0) {
        return 0;
    }
    const roundedY = roundedToNearest(roundedMagnitude(n), n);
    return n < 0 ? roundedY(min) : roundedY(!min);
};
export const DEFAULT_Y_RANGE = {
    yMax: 1000,
    yMin: 1,
};
const getBufferHeightByRange = (yMin, yMax) => {
    let bufferHeight = 0;
    // Adding padding such that the data's y-values are not flush with the view port
    if (yMax === yMin) {
        // Taking care of the case where yMax === yMin as well as a special case where both are 0
        bufferHeight = yMax !== 0 ? Math.abs(yMax * 0.5 /* SAME_VALUE */) : 0.5 /* SAME_VALUE */;
    }
    else {
        bufferHeight = (yMax - yMin) * 0.15 /* STANDARD */;
    }
    return bufferHeight;
};
const getYRangeWithBuffers = ({ yValues, startFromZero }) => {
    if (yValues.length === 0) {
        return DEFAULT_Y_RANGE;
    }
    const dataRange = yValues.reduce((yRange, currentY) => ({
        yMin: Math.min(currentY, yRange.yMin),
        yMax: Math.max(currentY, yRange.yMax),
    }), {
        yMin: Infinity,
        yMax: -Infinity,
    });
    const noNegativeValues = dataRange.yMin >= 0;
    const noPositiveValues = dataRange.yMax <= 0;
    const bufferHeight = getBufferHeightByRange(dataRange.yMin, dataRange.yMax);
    let yMax = dataRange.yMax + bufferHeight;
    let yMin = dataRange.yMin - bufferHeight;
    // Special case where yMax ans yMin is both zero. We will want to have padding.
    if (dataRange.yMax !== 0 || dataRange.yMin !== 0) {
        // If should start from zero and all in view points are positive, we set the yMin to zero
        if (startFromZero && noNegativeValues) {
            yMin = 0;
        }
        // If should start from zero and all in view points are negative, we set the yMax to zero.
        if (startFromZero && noPositiveValues) {
            yMax = 0;
        }
    }
    return {
        yMin: roundToOrderOfMagnitude(yMin, true),
        yMax: roundToOrderOfMagnitude(yMax, false),
    };
};
export const getYRange = ({ points, yAnnotations, startFromZero, }) => {
    // Extract out Y values for each of the data set for normalization.
    const yDataValues = points.map(point => point.y);
    const yAnnotationValues = yAnnotations.map(yAnnotation => yAnnotation.value);
    return getYRangeWithBuffers({ yValues: [...yDataValues, ...yAnnotationValues], startFromZero });
};
// TODO: Remove the tests dependency on currentYValue, and then delete this code. DO NOT USE THIS FUNCTION
export const currentYRange = () => {
    let lastYRange = DEFAULT_Y_RANGE;
    return ({ points, yAnnotations, startFromZero, }) => {
        if (points.length === 0 && yAnnotations.length === 0) {
            return lastYRange;
        }
        lastYRange = getYRange({ points, yAnnotations, startFromZero });
        return lastYRange;
    };
};
