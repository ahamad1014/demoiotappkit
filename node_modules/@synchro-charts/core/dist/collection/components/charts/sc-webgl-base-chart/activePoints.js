import { pointBisector, getDataBeforeDate } from '../common/dataFilters';
import { sortTooltipPoints } from '../sc-tooltip/sort';
import { getDataPoints } from '../../../utils/getDataPoints';
import { DATA_ALIGNMENT } from '../common/constants';
/**
 * Closest Points
 *
 * Returns the closest point to the left, and right of a
 * given point in time..
 *
 * @param maxDistance - maximum distance, measured in terms of milliseconds. if not present, there is no max distance.
 */
export const closestPoint = (dataPoints, date, dataAlignment, maxDistance) => {
    const idx = pointBisector.left(dataPoints, date);
    const leftPoint = dataPoints[idx - 1];
    const rightPoint = dataPoints[idx];
    /**
     * If a point falls on our point of time, return it immediately regardless of 'data alignment'.
     */
    if (leftPoint && leftPoint.x === date.getTime()) {
        return leftPoint;
    }
    if (rightPoint && rightPoint.x === date.getTime()) {
        return rightPoint;
    }
    /** Right Alignment */
    if (dataAlignment === DATA_ALIGNMENT.RIGHT) {
        if (!rightPoint) {
            return undefined;
        }
        if (maxDistance == null) {
            return rightPoint;
        }
        return rightPoint.x - date.getTime() <= maxDistance ? rightPoint : undefined;
    }
    /** Left Alignment */
    if (dataAlignment === DATA_ALIGNMENT.LEFT) {
        if (!leftPoint) {
            return undefined;
        }
        if (maxDistance == null) {
            return leftPoint;
        }
        return date.getTime() - leftPoint.x <= maxDistance ? leftPoint : undefined;
    }
    /** Either Alignment */
    // If only the left, or only the right point exist, go ahead and just return it.
    if (!leftPoint || !rightPoint) {
        return leftPoint || rightPoint;
    }
    // We are right bias because the interval between two points is the time span for the point on the right.
    return rightPoint;
};
/**
 * Get Active Points
 *
 * Returns at most one point per data stream - for each data stream, it finds the point which is
 * 1. within the given view port
 * 2. closest to the provided `selectedDate`
 *
 * Additionally, if `allowMultipleDates` is false, it will only return the points which are the closest
 * to the `selectedDate`. i.e. if you have 10 points that are all equally distant from the `selectedDate`,
 * all 10 are returned.
 *
 * However if you have 10 points of different dates, only the closest point would be returned.
 */
export const activePoints = ({ viewport, dataStreams, selectedDate, allowMultipleDates, dataAlignment, maxDurationFromDate, }) => {
    const dataStreamUtilizedData = dataStreams.map(stream => ({
        streamId: stream.id,
        dataPoints: getDataBeforeDate(getDataPoints(stream, stream.resolution), viewport.end),
    }));
    const selectedTimestamp = selectedDate.getTime();
    // Find the closest point to the selected date for each stream
    const points = dataStreamUtilizedData.map(({ streamId, dataPoints }) => ({
        streamId,
        point: closestPoint(dataPoints, selectedDate, dataAlignment, maxDurationFromDate),
    }));
    if (allowMultipleDates) {
        return points;
    }
    const distanceFromDate = (p) => Math.abs(p.x - selectedTimestamp);
    // Sort in ascending order by there distance from the selected date
    const sortedPoints = points.sort(sortTooltipPoints(distanceFromDate));
    if (sortedPoints.length === 0) {
        return [];
    }
    const topPoint = sortedPoints[sortedPoints.length - 1].point;
    if (topPoint == null) {
        // everything must be a 'blank' point
        return sortedPoints;
    }
    // Filter such that only the points with a date equal to the date of the point which is closest to the selected date.
    return sortedPoints.filter(p => p.point && p.point.x === topPoint.x);
};
