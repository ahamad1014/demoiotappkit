import { Component, Element, Event, h, Prop, State, Watch } from '@stencil/core';
import isEqual from 'lodash.isequal';
import throttle from 'lodash.throttle';
import clone from 'lodash.clonedeep';
import { DataType, StreamType } from '../../../utils/dataConstants';
import { webGLRenderer } from '../../sc-webgl-context/webglContext';
import { DEFAULT_CHART_CONFIG, DEFAULT_THRESHOLD_OPTIONS, DEFAULT_THRESHOLD_OPTIONS_OFF } from './chartDefaults';
import { LoadingStatus } from './LoadingStatus';
import { ErrorStatus } from './ErrorStatus';
import { ChartLegendContainer } from './ChartLegendContainer';
import { DataContainer } from './DataContainer';
import { renderAnnotations } from '../common/annotations/renderAnnotations';
import { getNumberAnnotations, isThreshold } from '../common/annotations/utils';
import { renderTrendLines } from '../common/trends/renderTrendLines';
import { renderAxis } from './renderAxis';
import { parseDuration } from '../../../utils/time';
import { getAllTrendResults } from '../common/trends/trendAnalysis';
import { getVisibleData } from '../common/dataFilters';
import { getYRange } from '../common/getYRange';
import { isNumeric } from '../../../utils/number';
import { isMinimalStaticViewport, isNumberDataStream } from '../../../utils/predicates';
import { EmptyStatus } from './EmptyStatus';
import { UnsupportedDataTypeStatus } from './UnsupportedDataTypeStatus';
import { getDataPoints } from '../../../utils/getDataPoints';
import { LEGEND_POSITION } from '../common/constants';
import { getDataStreamForEventing } from '../common';
import { attachDraggable } from '../common/annotations/draggableAnnotations';
import { DATE_RANGE_EMIT_EVENT_MS } from '../../common/constants';
const MIN_WIDTH = 50;
const MIN_HEIGHT = 50;
const LEGEND_HEIGHT = 100;
const DEFAULT_SHOW_DATA_STREAM_COLOR = true;
export class ScWebglBaseChart {
    constructor() {
        this.isEditing = false;
        this.renderLegend = props => h("sc-legend", Object.assign({}, props));
        this.annotations = {};
        this.trends = [];
        this.displaysError = true;
        this.supportedDataTypes = Object.values(DataType);
        this.yRangeStartFromZero = false;
        // Utilized to trigger a re-render once the data container is present to allow the
        // tooltip component to be properly rendered.
        this.isMounted = false;
        /**
         * Active View Port Config
         */
        this.yMin = this.viewport.yMin || 0;
        this.yMax = this.viewport.yMax || 100;
        // NOTE: If a start and end date are not provided, that means we are in 'live' mode
        this.start = isMinimalStaticViewport(this.viewport)
            ? new Date(this.viewport.start)
            : new Date(Date.now() - parseDuration(this.viewport.duration));
        this.end = isMinimalStaticViewport(this.viewport) ? new Date(this.viewport.end) : new Date();
        this.trendResults = [];
        this.axisRenderer = renderAxis();
        this.draggable = attachDraggable();
        this.isDragging = false;
        this.startStopDragging = (dragState) => {
            this.isDragging = dragState;
        };
        this.inDragState = () => {
            return this.isDragging;
        };
        this.getAxisContainer = () => {
            if (!this.axisContainer) {
                // Grab the svg within `<sc-webgl-axis />` component
                this.axisContainer = this.el.querySelector('svg.axis');
            }
            return this.axisContainer;
        };
        /**
         * Emit the current widget configuration
         */
        this.emitUpdatedWidgetConfiguration = (dataStreams) => {
            const configUpdate = {
                movement: undefined,
                scale: undefined,
                layout: undefined,
                legend: this.legend,
                annotations: this.internalAnnotations,
                axis: this.axis,
                widgetId: this.configId,
                dataStreams: dataStreams ? getDataStreamForEventing(dataStreams) : this.dataStreams,
            };
            this.widgetUpdated.emit(configUpdate);
        };
        /**
         * On Widget Updated - Persist `DataStreamInfo`
         *
         * Emits an event which persists the current `NameValue[]` state into the
         * data stream.
         */
        this.updateDataStreamName = ({ streamId, name }) => {
            const updatedDataStreams = this.dataStreams.map(dataStream => {
                return Object.assign(Object.assign({}, dataStream), { name: dataStream.id === streamId ? name : dataStream.name });
            });
            this.emitUpdatedWidgetConfiguration(updatedDataStreams);
        };
        this.onDateRangeChange = throttle(([start, end, from]) => {
            this.dateRangeChange.emit([start, end, from]);
        }, DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.chartSizeConfig = () => {
            const size = this.chartSize();
            const { marginTop, marginBottom, marginLeft, marginRight, height, width } = size;
            const chartHeight = height - marginBottom - marginTop;
            const isRightLegend = this.legend && this.legend.position === LEGEND_POSITION.RIGHT;
            const isBottomLegend = this.legend && this.legend.position === LEGEND_POSITION.BOTTOM;
            return Object.assign(Object.assign({}, size), { width: Math.max(width - marginLeft - marginRight - (isRightLegend ? this.legend.width : 0), MIN_WIDTH), height: chartHeight - (isBottomLegend ? LEGEND_HEIGHT : 0) });
        };
        /**
         * Get Active View Port
         *
         * Returns a view port with the current y range applied.
         * This can differ from the view port passed in, as
         * translations to the y range are only applied locally
         * as opposed to being applied via config changes from above.
         */
        this.activeViewPort = () => ({
            start: this.start,
            end: this.end,
            yMin: this.yMin,
            yMax: this.yMax,
            group: this.viewport.group,
            duration: !isMinimalStaticViewport(this.viewport) ? parseDuration(this.viewport.duration) : undefined,
        });
        this.handleCameraEvent = ({ start, end }) => {
            if (this.scene) {
                const oldViewport = { yMin: this.yMin, yMax: this.yMax, start, end };
                if (this.shouldRerenderOnViewportChange &&
                    this.shouldRerenderOnViewportChange({ oldViewport, newViewport: this.activeViewPort() })) {
                    this.onUpdate({ start, end }, false, false, false, true);
                }
                // Update Camera
                webGLRenderer.updateViewPorts({ start, end, manager: this.scene });
            }
        };
        /**
         * Updates the active view port y range.
         */
        this.updateYRange = () => {
            // Filter down the data streams to only contain data within the viewport
            const inViewPoints = this.dataStreams
                .filter(isNumberDataStream)
                .map(stream => getVisibleData(getDataPoints(stream, stream.resolution), { start: this.start, end: this.end }, false))
                .flat();
            const yAnnotations = (this.internalAnnotations && Array.isArray(this.internalAnnotations.y) && this.internalAnnotations.y) || [];
            const { yMin, yMax } = getYRange({
                points: inViewPoints,
                yAnnotations: yAnnotations.filter(annotation => isNumeric(annotation.value)),
                startFromZero: this.yRangeStartFromZero,
            });
            const prevYMin = this.yMin;
            const prevYMax = this.yMax;
            /** Update active viewport. */
            this.yMin = this.viewport.yMin != null ? this.viewport.yMin : yMin;
            this.yMax = this.viewport.yMax != null ? this.viewport.yMax : yMax;
            const oldViewport = { yMin: prevYMin, yMax: prevYMax, start: this.start, end: this.end };
            if (this.shouldRerenderOnViewportChange &&
                this.shouldRerenderOnViewportChange({ oldViewport, newViewport: this.activeViewPort() })) {
                this.onUpdate(this.activeViewPort(), false, false, false, true);
            }
            this.applyYRangeChanges();
        };
        /**
         * Apply Y Range Changes
         *
         * Updates the scene camera to point to the correct location
         */
        this.applyYRangeChanges = () => {
            if (this.scene) {
                /** Update threejs camera to have the updated viewport */
                this.scene.camera.top = this.yMax;
                this.scene.camera.bottom = this.yMin;
                // NOTE: This is required to make the changes to the camera take effect.
                // This updates the matricies which represent the cameras transformation.
                // This is done by setting a uniform for the shaders which are referenced to the
                // vertex shaders to translate and skew the coordinate space.
                this.scene.camera.updateProjectionMatrix();
            }
        };
        /**
         * Container Helpers
         *
         * Help provide an efficient way to have the correct mount point on the DOM.
         * We want to prevent the DOM from being re-queried for performance concerns.
         */
        this.getDataContainer = () => {
            if (this.dataContainer == null) {
                this.dataContainer = this.el.querySelector('.data-container');
            }
            return this.dataContainer;
        };
        this.getThresholdContainer = () => {
            if (this.thresholdContainer == null) {
                this.thresholdContainer = this.el.querySelector('.threshold-container');
            }
            return this.thresholdContainer;
        };
        this.getTrendContainer = () => {
            if (this.trendContainer == null) {
                this.trendContainer = this.el.querySelector('.trend-container');
            }
            return this.trendContainer;
        };
        this.getHasSupportedData = () => {
            return this.dataStreams.every(({ streamType, dataType }) => streamType === StreamType.ALARM || this.supportedDataTypes.includes(dataType));
        };
        this.thresholds = () => this.internalAnnotations && this.internalAnnotations.y ? this.internalAnnotations.y.filter(isThreshold) : [];
        this.getThresholdOptions = () => {
            // If user did not pass in any threshold options, we just use default
            if (this.internalAnnotations == null || this.internalAnnotations.thresholdOptions == null) {
                return DEFAULT_THRESHOLD_OPTIONS;
            }
            const { thresholdOptions } = this.internalAnnotations;
            // if threshold option is a type of bool, it means that we either turn on all defaults or
            // disable all defaults.
            if (typeof thresholdOptions === 'boolean') {
                return thresholdOptions ? DEFAULT_THRESHOLD_OPTIONS : DEFAULT_THRESHOLD_OPTIONS_OFF;
            }
            // If its a threshold object, then we just use the user's setting and override it with the default settings
            // that we have
            return Object.assign(Object.assign({}, DEFAULT_THRESHOLD_OPTIONS), thresholdOptions);
        };
        /**
         * Lifecycle method
         *
         * Called every time the component mounts, or has it's data, viewport, or size changed.
         *
         * Provide no `hasDataChanged` to prevent a re-processing of the chart scenes.
         */
        this.onUpdate = ({ start, end, shouldBlockDateRangeChangedEvent, }, hasDataChanged = false, hasSizeChanged = false, hasAnnotationChanged = false, shouldRerender = false) => {
            /**
             * Failure Handling
             */
            // avoid updating if dataStream has unsupported data
            if (!this.getHasSupportedData())
                return;
            // why do we have this condition?
            // - if one of the watched props e.g. dataStreams changes this will call onUpdate
            // - if the component unmounts before this this.scene is set to null
            // - if we do not have a scene or a component to render it in we should bail
            if (!this.scene && !this.el.isConnected)
                return;
            if (!this.el.isConnected && this.scene) {
                // Disconnected failure case:
                // This can occur in very 'stressed' performance situations where updates get called
                // and then a chart is disconnected. We can recover from this by removing itself
                // from the view port manager and bailing on the update.
                /* eslint-disable-next-line no-console */
                console.error(`[SynchroCharts] chart with associated scene id of ${this.scene.id} is disconnected,
         but still being called via the view port manager. removing from the view port manager.`);
                // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
                webGLRenderer.removeChartScene(this.scene.id);
                this.scene = null;
                return;
            }
            if (!this.scene) {
                // This should never occur - if it does, it's not recoverable so we just bail.
                throw new Error('[SynchroCharts] Scene is not present but update is being called.');
            }
            /**
             * Update Procedure
             */
            const hasViewPortChanged = this.start.getTime() !== start.getTime() || this.end.getTime() !== end.getTime();
            if (hasViewPortChanged && !shouldBlockDateRangeChangedEvent) {
                this.onDateRangeChange([start, end, this.viewport.group]);
            }
            // Update Active Viewport
            this.start = start;
            this.end = end;
            if (!this.supportString && !shouldRerender) {
                this.updateYRange();
            }
            // Render chart scene
            this.updateAndRegisterChartScene({
                hasDataChanged,
                hasSizeChanged,
                hasAnnotationChanged,
                shouldRerender,
            });
            // settings to utilize in all feature updates.
            const viewport = this.activeViewPort();
            const size = this.chartSizeConfig();
            if (this.onUpdateLifeCycle) {
                // Call all passed in updates - custom features
                this.onUpdateLifeCycle(this.activeViewPort());
            }
            /**
             *
             * Features
             *
             * Place custom features which are built into the chart at the base level here.
             * Non-base chart features should instead be delegated via the `onUpdateLifeCycle` hook.
             */
            /**
             * Annotations Feature
             *
             * Currently only supports rendering annotations for number data streams
             */
            if (!this.supportString) {
                const numberAnnotations = getNumberAnnotations(this.internalAnnotations);
                renderAnnotations({
                    container: this.getThresholdContainer(),
                    annotations: numberAnnotations,
                    viewport,
                    size,
                    // TODO: Revisit this.
                    // If no data streams are present we will fallback to a resolution of 0, i.e. 'raw' data
                    resolution: this.dataStreams[0] ? this.dataStreams[0].resolution : 0,
                    onUpdate: this.onUpdate,
                    activeViewPort: this.activeViewPort,
                    emitUpdatedWidgetConfiguration: this.emitUpdatedWidgetConfiguration,
                    draggable: this.draggable,
                    startStopDragging: this.startStopDragging,
                    inDragState: this.inDragState,
                });
            }
            /**
             * Trend Lines Feature
             *
             * Currently only supports rendering trends for number data streams
             */
            if (!this.supportString) {
                const dataStreamsWithTrends = this.visualizedDataStreams().filter(isNumberDataStream);
                this.trendResults = getAllTrendResults(viewport, dataStreamsWithTrends, this.trends);
                renderTrendLines({
                    container: this.getTrendContainer(),
                    viewport,
                    size,
                    dataStreams: this.visualizedDataStreams(),
                    trendResults: this.trendResults,
                });
            }
            /**
             * Axis Feature
             */
            this.axisRenderer({
                container: this.getAxisContainer(),
                viewport,
                size,
                axis: this.axis,
            });
        };
        /**
         * Set Chart Rendering Position
         *
         * Registers the chart rectangle, which tells webGL where to render the data-vizualization to.
         * This must be called each time after a scene is set.
         *
         */
        this.setChartRenderingPosition = () => {
            if (this.scene) {
                const chartSize = this.chartSizeConfig();
                webGLRenderer.setChartRect(this.scene.id, {
                    width: chartSize.width,
                    height: chartSize.height,
                    x: this.size.x + chartSize.marginLeft,
                    y: this.size.y + chartSize.marginTop,
                    left: this.size.left + chartSize.marginLeft,
                    top: this.size.top + chartSize.marginTop,
                    right: this.size.left + chartSize.marginLeft + chartSize.width,
                    bottom: this.size.top + chartSize.marginTop + chartSize.height,
                    density: window.devicePixelRatio,
                });
            }
        };
        this.chartSize = () => {
            const marginLeft = this.size.marginLeft == null ? DEFAULT_CHART_CONFIG.size.marginLeft : this.size.marginLeft;
            const marginRight = this.size.marginRight == null ? DEFAULT_CHART_CONFIG.size.marginRight : this.size.marginRight;
            const marginTop = this.size.marginTop == null ? DEFAULT_CHART_CONFIG.size.marginTop : this.size.marginTop;
            const marginBottom = this.size.marginBottom == null ? DEFAULT_CHART_CONFIG.size.marginBottom : this.size.marginBottom;
            const minWidth = marginLeft + marginRight + MIN_WIDTH;
            const minHeight = marginTop + marginBottom + MIN_HEIGHT;
            return {
                marginLeft,
                marginRight,
                marginTop,
                marginBottom,
                width: Math.max(this.size.width, minWidth),
                height: Math.max(this.size.height, minHeight),
            };
        };
        this.renderTooltipComponent = (marginLeft, marginTop, thresholds) => this.renderTooltip({
            size: this.chartSizeConfig(),
            style: { marginLeft: `${marginLeft}px`, marginTop: `${marginTop}px` },
            dataStreams: this.dataStreams,
            viewport: this.activeViewPort(),
            dataContainer: this.getDataContainer(),
            thresholds,
            trendResults: this.trendResults,
            visualizesAlarms: this.visualizesAlarms,
        });
        this.renderLegendComponent = ({ isLoading, thresholds, showDataStreamColor, }) => this.renderLegend({
            config: this.legend,
            dataStreams: this.dataStreams,
            visualizesAlarms: this.visualizesAlarms,
            updateDataStreamName: this.updateDataStreamName,
            viewport: this.activeViewPort(),
            isEditing: this.isEditing,
            isLoading,
            thresholds,
            supportString: this.supportString,
            trendResults: this.trendResults,
            showDataStreamColor,
        });
    }
    componentDidLoad() {
        // Why do we have this condition?
        //  - If componentDidUnload is called before componentDidLoad this.el.isConnected will be false
        //  - This can happen when scrolling page very quickly
        //  - If the component is unmounted before this.setupChartScene is complete we run into a race condition
        //  where the scene gets created and assigned to this.scene but we override it with null before
        //  this.setupChartScene calls this.onUpdate
        //  - Without the component mounted there is no point in calling onUpdate since we have nowhere to render this.scene
        if (this.el.isConnected) {
            this.setupChartScene();
            this.isMounted = true;
        }
    }
    componentWillLoad() {
        if (!this.isDragging) {
            this.setInternalAnnotations();
        }
    }
    setInternalAnnotations() {
        // Internal annotations are mutated, so we clone it to prevent altering the inputs.
        this.internalAnnotations = clone(this.annotations);
    }
    /**
     * Visualized Data Streams
     *
     * Returns the data streams we want to directly visualize
     * Depending on if visualizeAlarms is false, this will filter out alarm data.
     */
    visualizedDataStreams() {
        if (this.visualizesAlarms) {
            return this.dataStreams;
        }
        return this.dataStreams.filter(({ streamType }) => streamType !== StreamType.ALARM);
    }
    onViewPortChange(newViewPort, oldViewPort) {
        if (this.scene && !isEqual(newViewPort, oldViewPort)) {
            const hasYRangeChanged = newViewPort.yMin !== oldViewPort.yMin || newViewPort.yMax !== oldViewPort.yMax;
            if (hasYRangeChanged) {
                /** Update active viewport. */
                this.yMin = newViewPort.yMin;
                this.yMax = newViewPort.yMax;
                /** Apply Changes */
                this.applyYRangeChanges();
            }
            // All charts are correctly synced.
            /** Update active viewport */
            this.start = isMinimalStaticViewport(newViewPort)
                ? new Date(newViewPort.start)
                : new Date(Date.now() - parseDuration(newViewPort.duration));
            this.end = isMinimalStaticViewport(newViewPort) ? new Date(newViewPort.end) : new Date();
            /**
             * Updates viewport to the active viewport
             */
            this.scene.updateViewPort(this.activeViewPort());
            /** Re-render scene */
            // This is a necessary call to ensure that the view port group is correctly set.
            // If `updateViewPorts` is **not** called, `updateAndRegisterChartScene` in an edge case may
            // re-create the chart resources, and set the new viewport equal to the view port groups stale viewport.
            webGLRenderer.updateViewPorts({
                start: this.start,
                end: this.end,
                manager: this.scene,
                duration: this.activeViewPort().duration,
            });
            this.updateAndRegisterChartScene({
                hasDataChanged: false,
                hasSizeChanged: false,
                hasAnnotationChanged: false,
                shouldRerender: false,
            });
            if (this.shouldRerenderOnViewportChange &&
                this.shouldRerenderOnViewportChange({ oldViewport: oldViewPort, newViewport: newViewPort })) {
                this.onUpdate({ start: this.start, end: this.end }, false, false, false, true);
            }
        }
        const { duration } = this.activeViewPort();
        if (this.scene != null && duration != null) {
            webGLRenderer.stopTick({ manager: this.scene });
            webGLRenderer.startTick({ manager: this.scene, duration, chartSize: this.chartSizeConfig() });
        }
    }
    onSizeChange(newProp, oldProp) {
        // NOTE: Change of legend can effect sizing
        if (!isEqual(newProp, oldProp)) {
            this.onUpdate(this.activeViewPort(), false, true);
        }
        // Since internal clocks are depended on width, when we detect a width change, we want to re-start the timer.
        if (newProp.width != null && newProp.width !== oldProp.width) {
            const { duration } = this.activeViewPort();
            if (this.scene != null && duration != null) {
                webGLRenderer.stopTick({ manager: this.scene });
                webGLRenderer.startTick({ manager: this.scene, duration, chartSize: this.chartSizeConfig() });
            }
        }
    }
    onDataStreamsChange() {
        // Avoiding a deep equality check due to the cost on a potentially large object.
        this.onUpdate(this.activeViewPort(), true);
    }
    onAnnotationsChange(newProp, oldProp) {
        if (!isEqual(newProp, oldProp) && !this.isDragging) {
            this.setInternalAnnotations();
            this.onUpdate(this.activeViewPort(), false, false, true);
        }
    }
    onTrendsChange(newProp, oldProp) {
        if (!isEqual(newProp, oldProp)) {
            this.onUpdate(this.activeViewPort(), false);
        }
    }
    onAxisChange(newProp, oldProp) {
        const viewport = this.activeViewPort();
        const size = this.chartSizeConfig();
        if (!isEqual(newProp, oldProp)) {
            this.axisRenderer({
                container: this.getAxisContainer(),
                viewport,
                size,
                axis: this.axis,
            });
        }
    }
    // NOTE: While `componentDidUnload` is deprecated, `disconnectedCallback` causes critical issues
    //       causing orphaned updates to occur, where no `scene` is present.
    componentDidUnload() {
        if (this.scene) {
            // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
            webGLRenderer.removeChartScene(this.scene.id);
        }
        this.scene = null;
    }
    setupChartScene() {
        this.scene = this.createChartScene({
            viewport: this.activeViewPort(),
            chartSize: this.chartSizeConfig(),
            dataStreams: this.visualizedDataStreams(),
            alarms: this.alarms,
            container: this.getDataContainer(),
            minBufferSize: this.minBufferSize,
            bufferFactor: this.bufferFactor,
            onUpdate: this.onUpdate,
            thresholdOptions: this.getThresholdOptions(),
            thresholds: this.thresholds(),
        });
        const { duration } = this.activeViewPort();
        webGLRenderer.addChartScene({ manager: this.scene, duration, chartSize: this.chartSizeConfig() });
        this.setChartRenderingPosition();
        webGLRenderer.render(this.scene);
        this.onUpdate(this.activeViewPort());
    }
    /**
     * Update and register chart scene
     *
     * handles the updating of the chart scene, and handles registering the new
     * chart scene if a new chart scene is returned.
     *
     * A new chart scene will be returned if the new data passed in has
     * more data points that the previous chart scene had room allocated for.
     */
    updateAndRegisterChartScene({ hasDataChanged, hasSizeChanged, hasAnnotationChanged, shouldRerender, }) {
        if (this.scene) {
            if (hasSizeChanged) {
                this.setChartRenderingPosition();
            }
            const container = this.getDataContainer();
            const updatedScene = this.updateChartScene({
                scene: this.scene,
                chartSize: this.chartSizeConfig(),
                dataStreams: this.visualizedDataStreams(),
                alarms: this.alarms,
                container,
                viewport: this.activeViewPort(),
                minBufferSize: this.minBufferSize,
                bufferFactor: this.bufferFactor,
                onUpdate: this.onUpdate,
                thresholdOptions: this.getThresholdOptions(),
                thresholds: this.thresholds(),
                hasSizeChanged,
                hasDataChanged,
                shouldRerender,
                hasAnnotationChanged,
            });
            // update chart scene will return a new scene if it needed to delete the old one to make
            // the changes necessary and reconstruct a entirely new scene in it's place.
            // in this scenario we need to remove it's old scene from the global chart registry within webGL Renderer.
            const isNewChartScene = updatedScene.id !== this.scene.id;
            if (isNewChartScene) {
                // Must unregister the previous chart scene and register the new one with webgl
                webGLRenderer.removeChartScene(this.scene.id);
                this.scene = updatedScene;
                const { duration } = this.activeViewPort();
                webGLRenderer.addChartScene({
                    manager: updatedScene,
                    duration,
                    shouldSync: false,
                    chartSize: this.chartSizeConfig(),
                });
                this.setChartRenderingPosition();
            }
            /** Render to canvas */
            webGLRenderer.render(this.scene);
            if (hasSizeChanged) {
                // if the size has changed, then we need to wait till the next 'frame'
                // until the DOM has updated to it's new position.
                window.setTimeout(() => {
                    if (this.scene) {
                        webGLRenderer.render(this.scene);
                    }
                }, 0);
            }
        }
    }
    render() {
        const chartSizeConfig = this.chartSizeConfig();
        const { marginLeft, marginTop, marginRight, marginBottom } = chartSizeConfig;
        const hasError = this.dataStreams.some(({ error }) => error != null);
        const shouldDisplayAsLoading = !hasError && this.visualizedDataStreams().some(({ isLoading }) => isLoading);
        const hasNoDataStreamsPresent = this.visualizedDataStreams().length === 0;
        const hasNoDataPresent = this.visualizedDataStreams().every(stream => {
            const points = getDataPoints(stream, stream.resolution);
            if (points.length === 0) {
                return true;
            }
            // Check the latest datapoint to see if its before the start of viewport
            const isDataOutOfRange = points[points.length - 1].x < this.start.getTime();
            return isDataOutOfRange;
        });
        const thresholds = this.thresholds();
        const showDataStreamColor = this.legend != null && this.legend.showDataStreamColor != null
            ? this.legend.showDataStreamColor
            : DEFAULT_SHOW_DATA_STREAM_COLOR;
        if (!this.getHasSupportedData()) {
            return (h("div", { class: "awsui sc-webgl-base-chart" },
                h(UnsupportedDataTypeStatus, { size: chartSizeConfig, messageOverrides: this.messageOverrides || {}, supportedDataTypes: this.supportedDataTypes })));
        }
        return [
            h("div", { class: "awsui sc-webgl-base-chart" },
                this.displaysError && h(ErrorStatus, { hasError: hasError, size: chartSizeConfig }),
                h("sc-webgl-axis", { size: chartSizeConfig }),
                h(DataContainer, { size: chartSizeConfig },
                    h(EmptyStatus, { displaysNoDataPresentMsg: this.displaysNoDataPresentMsg != null ? this.displaysNoDataPresentMsg : true, messageOverrides: this.messageOverrides || {}, isLoading: shouldDisplayAsLoading, hasNoDataPresent: hasNoDataPresent, hasNoDataStreamsPresent: hasNoDataStreamsPresent }),
                    h(LoadingStatus, { isLoading: shouldDisplayAsLoading }),
                    this.gestures && (h("sc-gesture-handler", { onDateRangeChange: this.handleCameraEvent, size: chartSizeConfig, viewport: this.activeViewPort() }))),
                this.legend && (h(ChartLegendContainer, { config: this.legend, legendHeight: LEGEND_HEIGHT, size: chartSizeConfig }, this.renderLegendComponent({ isLoading: shouldDisplayAsLoading, thresholds, showDataStreamColor })))),
            this.isMounted && this.renderTooltipComponent(marginLeft, marginTop, thresholds),
            h("svg", { class: "threshold-container", width: chartSizeConfig.width + marginRight, height: chartSizeConfig.height + marginBottom, style: { marginLeft: `${marginLeft}px`, marginTop: `${marginTop}px` } }),
            h("svg", { class: "trend-container", width: chartSizeConfig.width, height: chartSizeConfig.height, style: { marginLeft: `${marginLeft}px`, marginTop: `${marginTop}px` } }),
        ];
    }
    static get is() { return "sc-webgl-base-chart"; }
    static get originalStyleUrls() { return {
        "$": ["./sc-webgl-base-chart.css"]
    }; }
    static get styleUrls() { return {
        "$": ["sc-webgl-base-chart.css"]
    }; }
    static get properties() { return {
        "dataStreams": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "DataStream[]",
                "resolved": "DataStream<Primitive>[]",
                "references": {
                    "DataStream": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "updateChartScene": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "ChartSceneUpdater",
                "resolved": "(options: { scene: ChartScene; dataStreams: DataStream<Primitive>[]; alarms?: AlarmsConfig | undefined; container: HTMLElement; viewport: ViewPort; chartSize: { width: number; height: number; }; bufferFactor: number; minBufferSize: number; thresholdOptions: ThresholdOptions; thresholds: Threshold<Primitive>[]; hasDataChanged: boolean; hasAnnotationChanged: boolean; hasSizeChanged: boolean; shouldRerender?: boolean | undefined; onUpdate?: (({ start, end }: { start: Date; end: Date; }) => void) | undefined; }) => ChartScene",
                "references": {
                    "ChartSceneUpdater": {
                        "location": "import",
                        "path": "./types"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "createChartScene": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "ChartSceneCreator",
                "resolved": "(options: { dataStreams: DataStream<Primitive>[]; alarms?: AlarmsConfig | undefined; container: HTMLElement; chartSize: { width: number; height: number; }; viewport: ViewPort; minBufferSize: number; bufferFactor: number; thresholdOptions: ThresholdOptions; thresholds: Threshold<Primitive>[]; onUpdate?: (({ start, end }: { start: Date; end: Date; }) => void) | undefined; }) => ChartScene",
                "references": {
                    "ChartSceneCreator": {
                        "location": "import",
                        "path": "./types"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "viewport": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "MinimalViewPortConfig",
                "resolved": "MinimalLiveViewport | MinimalStaticViewport",
                "references": {
                    "MinimalViewPortConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "gestures": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "gestures",
            "reflect": false
        },
        "size": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "SizePositionConfig",
                "resolved": "SizePositionConfig",
                "references": {
                    "SizePositionConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "isEditing": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "is-editing",
            "reflect": false,
            "defaultValue": "false"
        },
        "configId": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "config-id",
            "reflect": false
        },
        "bufferFactor": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "buffer-factor",
            "reflect": false
        },
        "minBufferSize": {
            "type": "number",
            "mutable": false,
            "complexType": {
                "original": "number",
                "resolved": "number",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "min-buffer-size",
            "reflect": false
        },
        "legend": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "LegendConfig",
                "resolved": "LegendConfig",
                "references": {
                    "LegendConfig": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "renderLegend": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(props: Legend.Props) => HTMLElement",
                "resolved": "(props: Props) => HTMLElement",
                "references": {
                    "Legend": {
                        "location": "import",
                        "path": "../common/types"
                    },
                    "HTMLElement": {
                        "location": "global"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "props => <sc-legend {...props} />"
        },
        "annotations": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Annotations",
                "resolved": "Annotations",
                "references": {
                    "Annotations": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "{}"
        },
        "trends": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Trend[]",
                "resolved": "LinearRegression[]",
                "references": {
                    "Trend": {
                        "location": "import",
                        "path": "../common/trends/types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "[]"
        },
        "supportString": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "support-string",
            "reflect": false
        },
        "axis": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Axis.Options",
                "resolved": "Options | undefined",
                "references": {
                    "Axis": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "renderTooltip": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(props: Tooltip.Props) => HTMLElement",
                "resolved": "(props: Props) => HTMLElement",
                "references": {
                    "Tooltip": {
                        "location": "import",
                        "path": "../common/types"
                    },
                    "HTMLElement": {
                        "location": "global"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "visualizesAlarms": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "visualizes-alarms",
            "reflect": false
        },
        "displaysError": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "displays-error",
            "reflect": false,
            "defaultValue": "true"
        },
        "alarms": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "AlarmsConfig",
                "resolved": "undefined | { expires?: number | undefined; }",
                "references": {
                    "AlarmsConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "supportedDataTypes": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "DataType[]",
                "resolved": "DataType[]",
                "references": {
                    "DataType": {
                        "location": "import",
                        "path": "../../../utils/dataConstants"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "Object.values(DataType)"
        },
        "shouldRerenderOnViewportChange": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "({\n    oldViewport,\n    newViewport,\n  }: {\n    oldViewport: MinimalViewPortConfig;\n    newViewport: MinimalViewPortConfig;\n  }) => boolean",
                "resolved": "(({ oldViewport, newViewport, }: { oldViewport: MinimalViewPortConfig; newViewport: MinimalViewPortConfig; }) => boolean) | undefined",
                "references": {
                    "MinimalViewPortConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "displaysNoDataPresentMsg": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean | undefined",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": "if false, base chart will not display an empty state message when there is no data present."
            },
            "attribute": "displays-no-data-present-msg",
            "reflect": false
        },
        "onUpdateLifeCycle": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(viewport: ViewPortConfig) => void",
                "resolved": "((viewport: ViewPortConfig) => void) | undefined",
                "references": {
                    "ViewPortConfig": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": "Optionally hooks to integrate custom logic into the base chart"
            }
        },
        "messageOverrides": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "MessageOverrides",
                "resolved": "undefined | { liveTimeFrameValueLabel?: string | undefined; historicalTimeFrameValueLabel?: string | undefined; noDataStreamsPresentHeader?: string | undefined; noDataStreamsPresentSubHeader?: string | undefined; noDataPresentHeader?: string | undefined; noDataPresentSubHeader?: string | undefined; liveModeOnly?: string | undefined; unsupportedDataTypeHeader?: string | undefined; unsupportedDataTypeSubHeader?: string | undefined; supportedTypes?: string | undefined; }",
                "references": {
                    "MessageOverrides": {
                        "location": "import",
                        "path": "../../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "yRangeStartFromZero": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "y-range-start-from-zero",
            "reflect": false,
            "defaultValue": "false"
        }
    }; }
    static get states() { return {
        "isMounted": {},
        "yMin": {},
        "yMax": {},
        "start": {},
        "end": {},
        "trendResults": {}
    }; }
    static get events() { return [{
            "method": "widgetUpdated",
            "name": "widgetUpdated",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "WidgetConfigurationUpdate",
                "resolved": "Pick<ChartConfig, \"movement\" | \"scale\" | \"layout\" | \"legend\" | \"annotations\" | \"axis\" | \"widgetId\" | \"size\"> & { dataStreams: Pick<DataStream<Primitive>, \"id\" | \"name\" | \"detailedName\" | \"color\" | \"unit\" | \"meta\" | \"dataType\" | \"streamType\" | \"associatedStreams\" | \"isLoading\" | \"isRefreshing\" | \"error\" | \"resolution\">[]; widgetId: string; }",
                "references": {
                    "WidgetConfigurationUpdate": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            }
        }, {
            "method": "dateRangeChange",
            "name": "dateRangeChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "On view port date range change, this component emits a `dateRangeChange` event.\nThis allows other data visualization components to sync to the same date range."
            },
            "complexType": {
                "original": "[Date, Date, string | undefined]",
                "resolved": "[Date, Date, string | undefined]",
                "references": {
                    "Date": {
                        "location": "global"
                    }
                }
            }
        }]; }
    static get elementRef() { return "el"; }
    static get watchers() { return [{
            "propName": "viewport",
            "methodName": "onViewPortChange"
        }, {
            "propName": "size",
            "methodName": "onSizeChange"
        }, {
            "propName": "legend",
            "methodName": "onSizeChange"
        }, {
            "propName": "dataStreams",
            "methodName": "onDataStreamsChange"
        }, {
            "propName": "annotations",
            "methodName": "onAnnotationsChange"
        }, {
            "propName": "trends",
            "methodName": "onTrendsChange"
        }, {
            "propName": "axis",
            "methodName": "onAxisChange"
        }]; }
}
