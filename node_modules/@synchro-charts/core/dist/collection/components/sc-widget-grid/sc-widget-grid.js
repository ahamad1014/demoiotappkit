import { Component, Event, h, Prop, State, Watch } from '@stencil/core';
import throttle from 'lodash.throttle';
import { DEFAULT_MESSAGE_OVERRIDES, } from '../../utils/dataTypes';
import { updateName } from '../sc-data-stream-name/helper';
import { activePoints } from '../charts/sc-webgl-base-chart/activePoints';
import { getThresholds } from '../charts/common/annotations/utils';
import { breachedThreshold } from '../charts/common/annotations/breachedThreshold';
import { streamPairs } from '../../utils/streamPairs';
import { viewportEndDate, viewportStartDate, isInLiveMode } from '../../utils/viewPort';
import { DATA_ALIGNMENT } from '../charts/common/constants';
import { isMinimalStaticViewport } from '../../utils/predicates';
import { parseDuration } from '../../utils/time';
import { getDataStreamForEventing } from '../charts/common';
import { validate } from '../common/validator/validate';
import { webGLRenderer } from '../sc-webgl-context/webglContext';
import { DATE_RANGE_EMIT_EVENT_MS } from '../common/constants';
const title = ({ alarm, property }) => {
    if (property) {
        return property.detailedName || property.name;
    }
    if (alarm) {
        return alarm.detailedName || alarm.name;
    }
    return '';
};
/**
 * A generic parent container which can be utilized to construct a variety of 'grid-like' components.
 *
 * This component allows construction of widgets, by simply constructing the display cell via the `renderCell` method.gt
 */
export class ScWidgetGrid {
    constructor() {
        this.collapseVertically = true;
        this.isEditing = false;
        this.messageOverrides = {};
        /** Widget data stream names */
        this.names = [];
        /** Active Viewport */
        this.start = viewportStartDate(this.viewport);
        this.end = viewportEndDate(this.viewport);
        this.duration = !isMinimalStaticViewport(this.viewport)
            ? parseDuration(this.viewport.duration)
            : undefined;
        this.onDateRangeChange = throttle(([start, end, from]) => {
            this.dateRangeChange.emit([start, end, from]);
        }, DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.onUpdate = ({ start, end, duration }) => {
            const hasViewPortChanged = viewportStartDate(this.viewport).getTime() !== start.getTime() ||
                viewportEndDate(this.viewport).getTime() !== end.getTime();
            const inLiveMode = isInLiveMode(this.viewport);
            if (hasViewPortChanged && !inLiveMode) {
                this.onDateRangeChange([start, end, this.viewport.group]);
            }
            // Update active viewport
            this.start = start;
            this.end = end;
            this.duration = duration;
        };
        /**
         * Emit the current widget configuration
         */
        this.emitUpdatedWidgetConfiguration = (dataStreams) => {
            const configUpdate = {
                movement: undefined,
                scale: undefined,
                layout: undefined,
                legend: undefined,
                annotations: this.annotations,
                axis: undefined,
                widgetId: this.widgetId,
                dataStreams: dataStreams ? getDataStreamForEventing(dataStreams) : this.dataStreams,
            };
            this.widgetUpdated.emit(configUpdate);
        };
        this.onChangeLabel = ({ streamId, name }) => {
            this.names = updateName(this.names, name, streamId);
            this.onWidgetUpdated();
        };
        this.getPoints = () => activePoints({
            viewport: {
                start: this.start,
                end: this.end,
            },
            dataStreams: this.dataStreams,
            selectedDate: this.end,
            allowMultipleDates: true,
            dataAlignment: DATA_ALIGNMENT.EITHER,
        });
        this.getBreachedThreshold = (point, dataStream) => breachedThreshold({
            value: point && point.y,
            date: isMinimalStaticViewport(this.viewport) ? new Date(this.viewport.end) : new Date(),
            dataStreams: this.dataStreams,
            dataStream,
            thresholds: getThresholds(this.annotations),
        });
    }
    componentWillRender() {
        validate(this);
    }
    componentDidLoad() {
        webGLRenderer.addChartScene({
            manager: {
                id: this.widgetId,
                viewportGroup: this.viewport.group,
                updateViewPort: this.onUpdate,
            },
            duration: this.duration,
        });
    }
    onViewPortChange(newViewPort) {
        this.onUpdate(Object.assign(Object.assign({}, newViewPort), { duration: !isMinimalStaticViewport(newViewPort) ? parseDuration(newViewPort.duration) : undefined, start: viewportStartDate(this.viewport), end: viewportEndDate(this.viewport) }));
    }
    disconnectedCallback() {
        // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
        webGLRenderer.removeChartScene(this.widgetId);
    }
    /**
     * On Widget Updated - Persist `DataStreamInfo`
     *
     * Emits an event which persists the current `NameValue[]` state into the
     * data stream info.
     */
    onWidgetUpdated() {
        // Construct the config update with the new names specified.
        const updatedDataStreams = this.dataStreams.map(dataStream => {
            const nameValue = this.names.find(({ id: nameId }) => dataStream.id === nameId);
            const name = nameValue != null ? nameValue.name : dataStream.name;
            return Object.assign(Object.assign({}, dataStream), { name });
        });
        this.emitUpdatedWidgetConfiguration(updatedDataStreams);
    }
    render() {
        var _a, _b;
        const isEnabled = this.duration != null;
        const points = this.getPoints();
        const pairs = streamPairs(this.dataStreams);
        const isMiniVersion = pairs.length > 1;
        return (h("div", { class: { tall: !this.collapseVertically } },
            !isEnabled && (h("div", { class: "help-icon-container" },
                h("sc-help-tooltip", { message: (_b = (_a = this.messageOverrides) === null || _a === void 0 ? void 0 : _a.liveModeOnly) !== null && _b !== void 0 ? _b : DEFAULT_MESSAGE_OVERRIDES.liveModeOnly }))),
            h("sc-grid", null, pairs.map(({ alarm, property }) => {
                const stream = alarm || property;
                if (stream == null) {
                    return undefined;
                }
                const alarmPointWrapper = alarm && points.find(p => p.streamId === alarm.id);
                const propertyPointWrapper = property && points.find(p => p.streamId === property.id);
                const alarmPoint = alarmPointWrapper ? alarmPointWrapper.point : undefined;
                const propertyPoint = propertyPointWrapper ? propertyPointWrapper.point : undefined;
                const pointToEvaluateOn = alarmPoint || propertyPoint;
                const infoToEvaluateOn = alarm || property;
                const threshold = pointToEvaluateOn && infoToEvaluateOn && this.getBreachedThreshold(pointToEvaluateOn, infoToEvaluateOn);
                const alarmStream = alarm && this.dataStreams.find(s => s.id === alarm.id);
                const primaryStream = alarm ? alarmStream : property;
                return (h("sc-grid-tooltip", { title: title({ alarm, property }), propertyPoint: propertyPoint, alarmPoint: alarmPoint, breachedThreshold: threshold, isEnabled: isEnabled }, this.renderCell({
                    isEnabled,
                    trendStream: property,
                    propertyStream: property,
                    propertyPoint,
                    alarmStream,
                    alarmPoint,
                    breachedThreshold: threshold,
                    isEditing: this.isEditing,
                    viewport: { start: this.start, end: this.end },
                    miniVersion: isMiniVersion,
                    onChangeLabel: this.onChangeLabel,
                    messageOverrides: this.messageOverrides,
                    labelsConfig: this.labelsConfig,
                    icon: threshold ? threshold.icon : undefined,
                    valueColor: threshold ? threshold.color : undefined,
                    error: primaryStream ? primaryStream.error : undefined,
                    isLoading: primaryStream ? primaryStream.isLoading || false : false,
                    isRefreshing: primaryStream ? primaryStream.isRefreshing || false : false,
                })));
            }))));
    }
    static get is() { return "sc-widget-grid"; }
    static get originalStyleUrls() { return {
        "$": ["sc-widget-grid.css"]
    }; }
    static get styleUrls() { return {
        "$": ["sc-widget-grid.css"]
    }; }
    static get properties() { return {
        "renderCell": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "RenderCell",
                "resolved": "(cellOptions: CellOptions) => void",
                "references": {
                    "RenderCell": {
                        "location": "import",
                        "path": "./types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "collapseVertically": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "collapse-vertically",
            "reflect": false,
            "defaultValue": "true"
        },
        "labelsConfig": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "LabelsConfig",
                "resolved": "undefined | { showUnit?: boolean | undefined; showName?: boolean | undefined; showValue?: boolean | undefined; }",
                "references": {
                    "LabelsConfig": {
                        "location": "import",
                        "path": "../common/types"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": "Chart API"
            }
        },
        "viewport": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "MinimalViewPortConfig",
                "resolved": "MinimalLiveViewport | MinimalStaticViewport",
                "references": {
                    "MinimalViewPortConfig": {
                        "location": "import",
                        "path": "../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "widgetId": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "widget-id",
            "reflect": false
        },
        "dataStreams": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "DataStream[]",
                "resolved": "DataStream<Primitive>[]",
                "references": {
                    "DataStream": {
                        "location": "import",
                        "path": "../../utils/dataTypes"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "annotations": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "Annotations",
                "resolved": "Annotations",
                "references": {
                    "Annotations": {
                        "location": "import",
                        "path": "../charts/common/types"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "isEditing": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "attribute": "is-editing",
            "reflect": false,
            "defaultValue": "false"
        },
        "messageOverrides": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "MessageOverrides",
                "resolved": "{ liveTimeFrameValueLabel?: string | undefined; historicalTimeFrameValueLabel?: string | undefined; noDataStreamsPresentHeader?: string | undefined; noDataStreamsPresentSubHeader?: string | undefined; noDataPresentHeader?: string | undefined; noDataPresentSubHeader?: string | undefined; liveModeOnly?: string | undefined; unsupportedDataTypeHeader?: string | undefined; unsupportedDataTypeSubHeader?: string | undefined; supportedTypes?: string | undefined; }",
                "references": {
                    "MessageOverrides": {
                        "location": "import",
                        "path": "../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            },
            "defaultValue": "{}"
        }
    }; }
    static get states() { return {
        "names": {},
        "start": {},
        "end": {},
        "duration": {}
    }; }
    static get events() { return [{
            "method": "dateRangeChange",
            "name": "dateRangeChange",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": "On view port date range change, this component emits a `dateRangeChange` event.\nThis allows other data visualization components to sync to the same date range."
            },
            "complexType": {
                "original": "[Date, Date, string | undefined]",
                "resolved": "[Date, Date, string | undefined]",
                "references": {
                    "Date": {
                        "location": "global"
                    }
                }
            }
        }, {
            "method": "widgetUpdated",
            "name": "widgetUpdated",
            "bubbles": true,
            "cancelable": true,
            "composed": true,
            "docs": {
                "tags": [],
                "text": ""
            },
            "complexType": {
                "original": "WidgetConfigurationUpdate",
                "resolved": "Pick<ChartConfig, \"movement\" | \"scale\" | \"layout\" | \"legend\" | \"annotations\" | \"axis\" | \"widgetId\" | \"size\"> & { dataStreams: Pick<DataStream<Primitive>, \"id\" | \"name\" | \"detailedName\" | \"color\" | \"unit\" | \"meta\" | \"dataType\" | \"streamType\" | \"associatedStreams\" | \"isLoading\" | \"isRefreshing\" | \"error\" | \"resolution\">[]; widgetId: string; }",
                "references": {
                    "WidgetConfigurationUpdate": {
                        "location": "import",
                        "path": "../charts/common/types"
                    }
                }
            }
        }]; }
    static get watchers() { return [{
            "propName": "viewport",
            "methodName": "onViewPortChange"
        }]; }
}
