import { Component, Element, h, Prop, State } from '@stencil/core';
import ResizeObserver from 'resize-observer-polyfill';
import isEqual from 'lodash.isequal';
import { rectScrollFixed } from '../common/webGLPositioning';
import { renderChild } from './renderChild';
import { webGLRenderer } from '../sc-webgl-context/webglContext';
/**
 * The rate at which the layout will update for graphics projected onto some element.
 *
 * A smaller duration will make performance suffer but prevent ghosting.
 */
const MS_PER_RECT_POLL = 650;
/**
 * Widget Sizer
 */
export class ScSizeProvider {
    constructor() {
        /** The DOM Elements size as computed by the observer. corrected on resolution changes. */
        this.computedSize = null;
        this.rect = null;
        this.rectPollingHandler = null;
        this.setRect = () => {
            if (this.el && this.el.isConnected) {
                const newRect = rectScrollFixed(this.el);
                const rectHasUpdated = !isEqual(newRect, this.rect);
                if (rectHasUpdated) {
                    if (this.rect && this.rect.density !== newRect.density) {
                        // When the density has changed, we need to trigger a resolution change. This will occur in scenarios
                        // such as attaching or detaching a monitor.
                        webGLRenderer.onResolutionChange();
                    }
                    // Note: It's important to only set this value if the contents actually change,
                    //       since it triggers a cascading re-render.
                    this.rect = newRect;
                }
            }
        };
    }
    componentWillLoad() {
        /**
         * Creates a listener for elements dimensions changing.
         * This allows us to dynamically set the widget dimensions.
         */
        this.resizer = new ResizeObserver(entries => {
            entries.forEach(entry => {
                /** Update Size */
                const { width, height } = entry.contentRect;
                this.computedSize = { width, height };
            });
        });
    }
    componentDidLoad() {
        this.setRect();
        this.rectPollingHandler = window.setInterval(this.setRect, MS_PER_RECT_POLL);
        this.resizer.observe(this.el.firstElementChild);
    }
    disconnectedCallback() {
        this.resizer.disconnect();
        if (this.rectPollingHandler) {
            window.clearInterval(this.rectPollingHandler);
        }
    }
    render() {
        const rect = (this.size || this.computedSize) && this.rect
            ? Object.assign(Object.assign(Object.assign({}, this.rect), this.computedSize), this.size) : undefined;
        return h("div", { class: "sc-size-provider-container" }, renderChild(this.renderFunc, rect));
    }
    static get is() { return "sc-size-provider"; }
    static get originalStyleUrls() { return {
        "$": ["sc-size-provider.css"]
    }; }
    static get styleUrls() { return {
        "$": ["sc-size-provider.css"]
    }; }
    static get properties() { return {
        "renderFunc": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "(rect: RectScrollFixed) => void",
                "resolved": "(rect: RectScrollFixed) => void",
                "references": {
                    "RectScrollFixed": {
                        "location": "import",
                        "path": "../../utils/types"
                    }
                }
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": ""
            }
        },
        "size": {
            "type": "unknown",
            "mutable": false,
            "complexType": {
                "original": "MinimalSizeConfig",
                "resolved": "MinimalSizeConfig | undefined",
                "references": {
                    "MinimalSizeConfig": {
                        "location": "import",
                        "path": "../../utils/dataTypes"
                    }
                }
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [],
                "text": "Size overrides. these will take precident over any auto-calculated sizing"
            }
        }
    }; }
    static get states() { return {
        "computedSize": {},
        "rect": {}
    }; }
    static get elementRef() { return "el"; }
}
