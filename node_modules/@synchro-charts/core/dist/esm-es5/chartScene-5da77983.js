import { c as getNumberThresholds } from './utils-96fe4147.js';
import { c as isNumberDataStream } from './predicates-67461267.js';
import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-06da257a.js';
import { n as numDataPoints, v as vertices, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-8273b9c5.js';
import { M as MAX_THRESHOLD_BANDS, t as thresholdBands, P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS$1, u as updatePointMesh } from './pointMesh-a5aff2b1.js';
import { S as STROKE_WIDTH } from './common-a5fcad18.js';
var lineVert = function (showColor) { return "\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n" + (showColor ? 'varying float yPositionPx;' : '') + "\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  " + (showColor ? 'yPositionPx = positionPx.y;' : '') + "\n}\n"; };
var lineFrag = "\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n";
var lineColorationFrag = "\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND " + MAX_THRESHOLD_BANDS + "\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n";
/**
 * Get Pixel Density in terms of the clip space
 *
 * Returns the ratio of model space to pixel space in each dimension.
 * i.e. how many pixels does 10 minutes represent on a given `container`?
 */
var pixelDensity = function (_a) {
    var _b = _a.viewport, end = _b.end, start = _b.start, yMax = _b.yMax, yMin = _b.yMin, toClipSpace = _a.toClipSpace, size = _a.size;
    var width = size.width, height = size.height;
    // We must translate our viewport to be in terms of the coordinate system which matches
    // that of the data being passed in - since we want to know how many pixels
    // are represented within the webGL context. i.e. clip space pixel density.
    var x = Math.abs((toClipSpace(end.getTime()) - toClipSpace(start.getTime())) / width);
    var y = Math.abs((yMax - yMin) / height);
    return { x: x, y: y };
};
/* eslint-disable no-param-reassign */
/**
 * Create Line Mesh`
 *
 * The representation of the lines between points on a chart.
 */
// Ensure that the line width is equal to the existing <sc-line-chart />'s line thickness
var LINE_WIDTH = STROKE_WIDTH;
var LINE_MESH_INDEX = 1;
// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated
// up front per `ChartScene`.
var NUM_POSITION_COMPONENTS = 2; // (x, y)
var NUM_COLOR_COMPONENTS = 3; // (r, g, b)
var numLineSegments = function (streamVertexSets) {
    var segments = streamVertexSets.reduce(function (totalSegments, streamVertexSet) {
        // For every point added within a stream, a new segment is drawn,
        // While there is no visible line segment for the first point added in a stream,
        // it draws a 'degenerate' segment which is rendered as nothing.
        // This is purely an implementation detail of the shader, but we must take it into account
        // when determining the number of 'instances' to be drawn by the instance mesh.
        // ex1. o--o--o--o  [4 points, 3 visible segments, 1 degenerate segment]
        // ex2. o           [1 point, 0 visible segments]
        var streamSegments = Math.max(streamVertexSet.length, 0);
        return totalSegments + streamSegments;
    }, 0);
    return segments;
};
var updateMesh = function (dataStreams, mesh, toClipSpace) {
    var streamVertexSets = dataStreams.filter(isNumberDataStream).map(function (stream) { return vertices(stream, stream.resolution); });
    // Set the number of instances of the line segment that are to be rendered.
    mesh.count = numLineSegments(streamVertexSets);
    var geometry = mesh.geometry;
    /**
     * Fill Buffers with data
     */
    var _a = geometry.attributes, currPoint = _a.currPoint, nextPoint = _a.nextPoint, segmentColor = _a.segmentColor;
    var positionIndex = 0;
    var colorIndex = 0;
    streamVertexSets.forEach(function (streamVertexSet) {
        streamVertexSet.forEach(function (currVertex, vertexNum) {
            var isLastVertex = vertexNum === streamVertexSet.length - 1;
            var nextVertex = !isLastVertex ? streamVertexSet[vertexNum + 1] : currVertex;
            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];
            var nextX = nextVertex[0], nextY = nextVertex[1];
            // NOTE: WebGL takes a buffer of values and then converts those to vectors or the correct dimensionality
            // Set Current Position (currX, currY)
            currPoint.array[positionIndex] = toClipSpace(currX);
            currPoint.array[positionIndex + 1] = currY;
            // Set Next Position (nextX, nextY)
            nextPoint.array[positionIndex] = toClipSpace(nextX);
            nextPoint.array[positionIndex + 1] = nextY;
            // Set Line Segment Color (r, g, b)
            segmentColor.array[colorIndex] = r;
            segmentColor.array[colorIndex + 1] = g;
            segmentColor.array[colorIndex + 2] = b;
            // Increment Indexes by the associated stride of the buffer
            colorIndex += NUM_COLOR_COMPONENTS;
            positionIndex += NUM_POSITION_COMPONENTS;
        });
    });
    currPoint.needsUpdate = true;
    nextPoint.needsUpdate = true;
    segmentColor.needsUpdate = true;
};
/**
 * Segment Instance Geometry is a square made up of two triangles,
 * as shown in the 'perfect' diagram shown below:
 * (0, 0.5)----(1, 0.5)
 *    |  \         |
 *    |     \      |
 *    |         \  |
 * (0, -0.5)---(1, -0.5)
 */
var segmentInstanceGeometry = [
    [0, -0.5],
    [1, -0.5],
    [1, 0.5],
    [0, -0.5],
    [1, 0.5],
    [0, 0.5],
];
var initializeGeometry = function (geometry, bufferSize) {
    /**
     * Create Attributes
     */
    geometry.setAttribute('position', new BufferAttribute(new Float32Array(segmentInstanceGeometry.flat()), NUM_POSITION_COMPONENTS));
    geometry.setAttribute('currPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));
    geometry.setAttribute('nextPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));
    geometry.setAttribute('segmentColor', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));
};
var lineMesh = function (_a) {
    var viewport = _a.viewport, dataStreams = _a.dataStreams, chartSize = _a.chartSize, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, toClipSpace = _a.toClipSpace, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var geometry = new InstancedBufferGeometry();
    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);
    // Create and populate geometry
    initializeGeometry(geometry, bufferSize);
    // Construct shader
    var _b = pixelDensity({ viewport: viewport, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;
    var _c = thresholdOptions.showColor, showColor = _c === void 0 ? true : _c;
    var lineMaterial = new RawShaderMaterial({
        vertexShader: lineVert(showColor && thresholds.length > 0),
        fragmentShader: !showColor || thresholds.length === 0 ? lineFrag : lineColorationFrag,
        side: DoubleSide,
        transparent: true,
        uniforms: {
            width: {
                value: LINE_WIDTH,
            },
            xPixelDensity: {
                value: xPixelDensity,
            },
            yPixelDensity: {
                value: yPixelDensity,
            },
            thresholdBands: {
                value: thresholdBands(thresholds),
            },
        },
    });
    var mesh = new InstancedMesh(geometry, lineMaterial, bufferSize);
    // Prevent bounding sphere from being called
    mesh.frustumCulled = false;
    updateMesh(dataStreams, mesh, toClipSpace);
    return mesh;
};
var updateLineMesh = function (_a) {
    var chartSize = _a.chartSize, toClipSpace = _a.toClipSpace, lines = _a.lines, dataStreams = _a.dataStreams, viewport = _a.viewport, hasDataChanged = _a.hasDataChanged;
    /**
     * Update Uniforms
     */
    var _b = pixelDensity({ viewport: viewport, toClipSpace: toClipSpace, size: chartSize }), xPixelDensity = _b.x, yPixelDensity = _b.y;
    lines.material.uniforms.xPixelDensity.value = xPixelDensity;
    lines.material.uniforms.yPixelDensity.value = yPixelDensity;
    /**
     * Update Data
     */
    if (hasDataChanged) {
        updateMesh(dataStreams, lines, toClipSpace);
    }
};
var chartScene = function (_a) {
    var dataStreams = _a.dataStreams, chartSize = _a.chartSize, container = _a.container, viewport = _a.viewport, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var scene = new Scene();
    var toClipSpace = clipSpaceConversion(viewport);
    var numberThresholds = getNumberThresholds(thresholds);
    // Create and add meshes to the chart scene
    var meshList = [];
    meshList[LINE_MESH_INDEX] = lineMesh({
        toClipSpace: toClipSpace,
        chartSize: chartSize,
        dataStreams: dataStreams,
        viewport: viewport,
        minBufferSize: minBufferSize,
        bufferFactor: bufferFactor,
        thresholdOptions: thresholdOptions,
        thresholds: numberThresholds,
    });
    meshList[POINT_MESH_INDEX] = pointMesh({
        dataStreams: dataStreams,
        minBufferSize: minBufferSize,
        bufferFactor: bufferFactor,
        toClipSpace: toClipSpace,
        thresholdOptions: thresholdOptions,
        thresholds: numberThresholds,
    });
    meshList.forEach(function (mesh) { return scene.add(mesh); });
    return constructChartScene({ scene: scene, viewport: viewport, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });
};
var maxDataPointsRendered = function (points) { return points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS$1; };
var updateChartScene = function (_a) {
    var scene = _a.scene, dataStreams = _a.dataStreams, chartSize = _a.chartSize, container = _a.container, viewport = _a.viewport, hasDataChanged = _a.hasDataChanged, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, hasAnnotationChanged = _a.hasAnnotationChanged, thresholds = _a.thresholds;
    var lines = scene.scene.children[LINE_MESH_INDEX];
    var points = scene.scene.children[POINT_MESH_INDEX];
    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the
    // chart scene, we must fully recreate the chart scene. This is a costly operation.
    var isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);
    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {
        return chartScene({
            dataStreams: dataStreams,
            chartSize: chartSize,
            container: container,
            viewport: viewport,
            minBufferSize: minBufferSize,
            bufferFactor: bufferFactor,
            onUpdate: onUpdate,
            thresholdOptions: thresholdOptions,
            thresholds: thresholds,
        });
    }
    updateLineMesh({
        lines: lines,
        dataStreams: dataStreams,
        chartSize: chartSize,
        viewport: viewport,
        hasDataChanged: hasDataChanged,
        toClipSpace: scene.toClipSpace,
    });
    updatePointMesh(dataStreams, points, scene.toClipSpace, hasDataChanged);
    // Return existing scene.
    return scene;
};
export { chartScene as c, updateChartScene as u };
