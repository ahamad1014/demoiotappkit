var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var _a;
import { r as registerInstance, h } from './index-0c943849.js';
import { L as LEGEND_POSITION } from './constants-35570903.js';
import { S as StreamType, D as DataType } from './dataConstants-856cb1e9.js';
import './index-b3f1c3a1.js';
import { M as MINUTE_IN_MS } from './time-b732648c.js';
import { c as createCommonjsModule } from './_commonjsHelpers-1d681858.js';
/**
 * Data Construction
 *
 * We want to construct a widget which displays a numerical data stream, with two alarm string data streams with
 * corresponding thresholds.
 *
 * We do this by monitoring the "oil change status" and "could get speeding ticket" alarm.
 */
// viewport boundaries
var X_MIN = new Date(2000, 0, 0);
var X_MAX = new Date(2000, 0, 1);
var DIFF = X_MAX.getTime() - X_MIN.getTime();
var SOME_NUM = 60;
var OK = 'OK';
var ALARM = 'ALARM';
/**
 * MPH Data
 */
var getMPHData = function () { return [
    {
        x: X_MIN.getTime() + DIFF / 5,
        y: SOME_NUM / 5,
    },
    {
        x: X_MIN.getTime() + (DIFF * 2) / 5,
        y: SOME_NUM / 4,
    },
    {
        x: X_MIN.getTime() + (DIFF * 3) / 5,
        y: SOME_NUM,
    },
    {
        x: X_MIN.getTime() + (DIFF * 4) / 5,
        y: SOME_NUM * 2,
    },
]; };
var speedingAlarmData = function () { return [
    {
        x: X_MIN.getTime() + DIFF / 5,
        y: OK,
    },
    {
        x: X_MIN.getTime() + (DIFF * 2) / 5,
        y: OK,
    },
    {
        x: X_MIN.getTime() + (DIFF * 3) / 5,
        y: OK,
    },
    {
        x: X_MIN.getTime() + (DIFF * 4) / 5,
        y: ALARM,
    },
]; };
var oilAlarmData = function () { return [
    {
        x: X_MIN.getTime() + DIFF / 5,
        y: OK,
    },
    {
        x: X_MIN.getTime() + (DIFF * 2) / 5,
        y: OK,
    },
    {
        x: X_MIN.getTime() + (DIFF * 3) / 5,
        y: ALARM,
    },
    {
        x: X_MIN.getTime() + (DIFF * 4) / 5,
        y: ALARM,
    },
]; };
var speedingAlarmInfo = {
    dataType: DataType.STRING,
    resolution: 0,
    id: 'speeding-alarm',
    color: 'red',
    name: 'speeding alarm',
    streamType: StreamType.ALARM,
};
var oilChangeAlarmInfo = {
    dataType: DataType.STRING,
    resolution: 0,
    id: 'oil-change-alarm',
    color: 'orange',
    name: 'oil change alarm',
    streamType: StreamType.ALARM,
};
var dataStreamInfoWithAlarms = {
    dataType: DataType.NUMBER,
    resolution: 0,
    id: 'stream-with-alarms',
    color: 'black',
    name: 'mph',
    associatedStreams: [
        { id: speedingAlarmInfo.id, type: StreamType.ALARM },
        { id: oilChangeAlarmInfo.id, type: StreamType.ALARM },
    ],
};
var mphStream = {
    id: dataStreamInfoWithAlarms.id,
    dataType: dataStreamInfoWithAlarms.dataType,
    color: 'black',
    name: 'mph',
    aggregates: (_a = {},
        _a[MINUTE_IN_MS] = getMPHData(),
        _a),
    data: [],
    resolution: MINUTE_IN_MS,
    associatedStreams: [
        {
            id: speedingAlarmInfo.id,
            type: StreamType.ALARM,
        },
        {
            id: speedingAlarmInfo.id,
            type: StreamType.ALARM,
        },
    ],
};
var speedingAlarmStream = {
    id: speedingAlarmInfo.id,
    color: 'red',
    name: 'speeding alarm',
    streamType: StreamType.ALARM,
    dataType: speedingAlarmInfo.dataType,
    data: speedingAlarmData(),
    resolution: 0,
};
var oilAlarmStream = {
    id: oilChangeAlarmInfo.id,
    dataType: oilChangeAlarmInfo.dataType,
    data: oilAlarmData(),
    color: 'orange',
    name: 'oil change alarm',
    streamType: StreamType.ALARM,
    resolution: 0,
};
var VIEWPORT = {
    start: X_MIN,
    end: X_MAX,
};
var SIZE = {
    height: 500,
    width: 500,
};
var LEGEND = {
    position: LEGEND_POSITION.RIGHT,
    width: 200,
    legendLabels: {
        title: 'Number of data points',
    },
};
var strictUriEncode = function (str) { return encodeURIComponent(str).replace(/[!'()*]/g, function (x) { return "%" + x.charCodeAt(0).toString(16).toUpperCase(); }); };
var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return [decodeURIComponent(components.join(''))];
    }
    catch (err) {
        // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    }
    catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i = 1; i < tokens.length; i++) {
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while (match) {
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        }
        catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
var decodeUriComponent = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    }
    catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};
var splitOnFirst = function (string, separator) {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
        throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
        return [string];
    }
    var separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
        return [string];
    }
    return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
    ];
};
var filterObj = function (obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
        }
    }
    return ret;
};
var queryString = createCommonjsModule(function (module, exports) {
    var isNullOrUndefined = function (value) { return value === null || value === undefined; };
    function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
            case 'index':
                return function (key) { return function (result, value) {
                    var index = result.length;
                    if (value === undefined ||
                        (options.skipNull && value === null) ||
                        (options.skipEmptyString && value === '')) {
                        return result;
                    }
                    if (value === null) {
                        return __spreadArrays(result, [[encode(key, options), '[', index, ']'].join('')]);
                    }
                    return __spreadArrays(result, [
                        [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
                    ]);
                }; };
            case 'bracket':
                return function (key) { return function (result, value) {
                    if (value === undefined ||
                        (options.skipNull && value === null) ||
                        (options.skipEmptyString && value === '')) {
                        return result;
                    }
                    if (value === null) {
                        return __spreadArrays(result, [[encode(key, options), '[]'].join('')]);
                    }
                    return __spreadArrays(result, [[encode(key, options), '[]=', encode(value, options)].join('')]);
                }; };
            case 'comma':
            case 'separator':
                return function (key) { return function (result, value) {
                    if (value === null || value === undefined || value.length === 0) {
                        return result;
                    }
                    if (result.length === 0) {
                        return [[encode(key, options), '=', encode(value, options)].join('')];
                    }
                    return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
                }; };
            default:
                return function (key) { return function (result, value) {
                    if (value === undefined ||
                        (options.skipNull && value === null) ||
                        (options.skipEmptyString && value === '')) {
                        return result;
                    }
                    if (value === null) {
                        return __spreadArrays(result, [encode(key, options)]);
                    }
                    return __spreadArrays(result, [[encode(key, options), '=', encode(value, options)].join('')]);
                }; };
        }
    }
    function parserForArrayFormat(options) {
        var result;
        switch (options.arrayFormat) {
            case 'index':
                return function (key, value, accumulator) {
                    result = /\[(\d*)\]$/.exec(key);
                    key = key.replace(/\[\d*\]$/, '');
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === undefined) {
                        accumulator[key] = {};
                    }
                    accumulator[key][result[1]] = value;
                };
            case 'bracket':
                return function (key, value, accumulator) {
                    result = /(\[\])$/.exec(key);
                    key = key.replace(/\[\]$/, '');
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === undefined) {
                        accumulator[key] = [value];
                        return;
                    }
                    accumulator[key] = [].concat(accumulator[key], value);
                };
            case 'comma':
            case 'separator':
                return function (key, value, accumulator) {
                    var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
                    var isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
                    value = isEncodedArray ? decode(value, options) : value;
                    var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) { return decode(item, options); }) : value === null ? value : decode(value, options);
                    accumulator[key] = newValue;
                };
            default:
                return function (key, value, accumulator) {
                    if (accumulator[key] === undefined) {
                        accumulator[key] = value;
                        return;
                    }
                    accumulator[key] = [].concat(accumulator[key], value);
                };
        }
    }
    function validateArrayFormatSeparator(value) {
        if (typeof value !== 'string' || value.length !== 1) {
            throw new TypeError('arrayFormatSeparator must be single character string');
        }
    }
    function encode(value, options) {
        if (options.encode) {
            return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
    }
    function decode(value, options) {
        if (options.decode) {
            return decodeUriComponent(value);
        }
        return value;
    }
    function keysSorter(input) {
        if (Array.isArray(input)) {
            return input.sort();
        }
        if (typeof input === 'object') {
            return keysSorter(Object.keys(input))
                .sort(function (a, b) { return Number(a) - Number(b); })
                .map(function (key) { return input[key]; });
        }
        return input;
    }
    function removeHash(input) {
        var hashStart = input.indexOf('#');
        if (hashStart !== -1) {
            input = input.slice(0, hashStart);
        }
        return input;
    }
    function getHash(url) {
        var hash = '';
        var hashStart = url.indexOf('#');
        if (hashStart !== -1) {
            hash = url.slice(hashStart);
        }
        return hash;
    }
    function extract(input) {
        input = removeHash(input);
        var queryStart = input.indexOf('?');
        if (queryStart === -1) {
            return '';
        }
        return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
            value = Number(value);
        }
        else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
            value = value.toLowerCase() === 'true';
        }
        return value;
    }
    function parse(query, options) {
        options = Object.assign({
            decode: true,
            sort: true,
            arrayFormat: 'none',
            arrayFormatSeparator: ',',
            parseNumbers: false,
            parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        var formatter = parserForArrayFormat(options);
        // Create an object with no prototype
        var ret = Object.create(null);
        if (typeof query !== 'string') {
            return ret;
        }
        query = query.trim().replace(/^[?#&]/, '');
        if (!query) {
            return ret;
        }
        for (var _i = 0, _a = query.split('&'); _i < _a.length; _i++) {
            var param = _a[_i];
            if (param === '') {
                continue;
            }
            var _b = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='), key = _b[0], value = _b[1];
            // Missing `=` should be `null`:
            // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
            value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
            formatter(decode(key, options), value, ret);
        }
        for (var _c = 0, _d = Object.keys(ret); _c < _d.length; _c++) {
            var key = _d[_c];
            var value = ret[key];
            if (typeof value === 'object' && value !== null) {
                for (var _e = 0, _f = Object.keys(value); _e < _f.length; _e++) {
                    var k = _f[_e];
                    value[k] = parseValue(value[k], options);
                }
            }
            else {
                ret[key] = parseValue(value, options);
            }
        }
        if (options.sort === false) {
            return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
            var value = ret[key];
            if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
                // Sort object keys, not values
                result[key] = keysSorter(value);
            }
            else {
                result[key] = value;
            }
            return result;
        }, Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse;
    exports.stringify = function (object, options) {
        if (!object) {
            return '';
        }
        options = Object.assign({
            encode: true,
            strict: true,
            arrayFormat: 'none',
            arrayFormatSeparator: ','
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        var shouldFilter = function (key) { return ((options.skipNull && isNullOrUndefined(object[key])) ||
            (options.skipEmptyString && object[key] === '')); };
        var formatter = encoderForArrayFormat(options);
        var objectCopy = {};
        for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
            var key = _a[_i];
            if (!shouldFilter(key)) {
                objectCopy[key] = object[key];
            }
        }
        var keys = Object.keys(objectCopy);
        if (options.sort !== false) {
            keys.sort(options.sort);
        }
        return keys.map(function (key) {
            var value = object[key];
            if (value === undefined) {
                return '';
            }
            if (value === null) {
                return encode(key, options);
            }
            if (Array.isArray(value)) {
                return value
                    .reduce(formatter(key), [])
                    .join('&');
            }
            return encode(key, options) + '=' + encode(value, options);
        }).filter(function (x) { return x.length > 0; }).join('&');
    };
    exports.parseUrl = function (url, options) {
        options = Object.assign({
            decode: true
        }, options);
        var _a = splitOnFirst(url, '#'), url_ = _a[0], hash = _a[1];
        return Object.assign({
            url: url_.split('?')[0] || '',
            query: parse(extract(url), options)
        }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {});
    };
    exports.stringifyUrl = function (object, options) {
        options = Object.assign({
            encode: true,
            strict: true
        }, options);
        var url = removeHash(object.url).split('?')[0] || '';
        var queryFromUrl = exports.extract(object.url);
        var parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        var query = Object.assign(parsedQueryFromUrl, object.query);
        var queryString = exports.stringify(query, options);
        if (queryString) {
            queryString = "?" + queryString;
        }
        var hash = getHash(object.url);
        if (object.fragmentIdentifier) {
            hash = "#" + encode(object.fragmentIdentifier, options);
        }
        return "" + url + queryString + hash;
    };
    exports.pick = function (input, filter, options) {
        options = Object.assign({
            parseFragmentIdentifier: true
        }, options);
        var _a = exports.parseUrl(input, options), url = _a.url, query = _a.query, fragmentIdentifier = _a.fragmentIdentifier;
        return exports.stringifyUrl({
            url: url,
            query: filterObj(query, filter),
            fragmentIdentifier: fragmentIdentifier
        }, options);
    };
    exports.exclude = function (input, filter, options) {
        var exclusionFilter = Array.isArray(filter) ? function (key) { return !filter.includes(key); } : function (key, value) { return !filter(key, value); };
        return exports.pick(input, exclusionFilter, options);
    };
});
var queryString_2 = queryString.parse;
var parseBool = function (str) { return str === 'true'; };
var deserializeAnnotations = function (str) {
    var annotations = JSON.parse(str);
    var x = annotations.x;
    var deserializeXAnnotation = function (xAnnotation) { return (Object.assign(Object.assign({}, xAnnotation), { value: new Date(xAnnotation.value) })); };
    return Object.assign(Object.assign({}, annotations), { x: x != null ? x.map(deserializeXAnnotation) : undefined });
};
var deserializeDataStream = function (almostDataStream) { return (Object.assign(Object.assign({}, almostDataStream), { data: almostDataStream.data.map(function (point) { return ({ x: Number(point.x), y: point.y }); }) })); };
var testCaseParameters = function () {
    var query = queryString_2(window.location.search);
    // Instructions for extending: default should be undefined, or if required, some empty state.
    // DO NOT send mock data here! it should be the bare minimum to render. Consider this the default empty state.
    return {
        alarms: query.alarms ? JSON.parse(query.alarms) : undefined,
        width: query.width ? JSON.parse(query.width) : undefined,
        axis: query.axis ? JSON.parse(query.axis) : undefined,
        height: query.height ? JSON.parse(query.height) : undefined,
        duration: query.duration ? JSON.parse(query.duration) : undefined,
        errMsg: query.errMsg,
        gestures: query.gestures != null ? parseBool(query.gestures) : true,
        delayBeforeDataLoads: query.delayBeforeDataLoads != null ? JSON.parse(query.delayBeforeDataLoads) : 0,
        dataStreamInfos: query.dataStreamInfos != null ? JSON.parse(query.dataStreamInfos) : [],
        tableColumns: query.tableColumns != null ? JSON.parse(query.tableColumns) : [],
        legend: query.legend != null ? JSON.parse(query.legend) : LEGEND,
        messageOverrides: query.messageOverrides != null ? JSON.parse(query.messageOverrides) : undefined,
        componentTag: query.componentTag != null ? query.componentTag : 'sc-line-chart',
        // deserialize fields that require it.
        displayInfoNames: query.displayInfoNames ? parseBool(query.displayInfoNames) : false,
        annotations: query.annotations != null ? deserializeAnnotations(query.annotations) : undefined,
        isEditing: query.isEditing != null ? parseBool(query.isEditing) : false,
        hasError: query.hasError != null ? parseBool(query.hasError) : false,
        dataStreams: query.dataStreams != null ? JSON.parse(query.dataStreams).map(deserializeDataStream) : [],
        asyncDataStreams: query.asyncDataStreams != null ? JSON.parse(query.asyncDataStreams).map(deserializeDataStream) : [],
        viewportStart: query.viewportStart != null ? new Date(query.viewportStart) : new Date(2000, 0, 0),
        viewportEnd: query.viewportEnd != null ? new Date(query.viewportEnd) : new Date(2000, 0, 1),
    };
};
var DEFAULT_WIDTH = 700;
var DEFAULT_HEIGHT = 400;
var _b = testCaseParameters(), 
/** Chart configurations */
alarms = _b.alarms, messageOverrides = _b.messageOverrides, _c = _b.width, width = _c === void 0 ? DEFAULT_WIDTH : _c, _d = _b.height, height = _d === void 0 ? DEFAULT_HEIGHT : _d, axis = _b.axis, componentTag = _b.componentTag, annotations = _b.annotations, viewportStart = _b.viewportStart, viewportEnd = _b.viewportEnd, duration = _b.duration, isEditing = _b.isEditing, dataStreams = _b.dataStreams, gestures = _b.gestures, legend = _b.legend, tableColumns = _b.tableColumns;
var getSize = function (value) {
    if (typeof value === 'string') {
        return undefined;
    }
    return Object.assign(Object.assign({}, SIZE), { width: width,
        height: height });
};
var styleSize = function (value) {
    if (typeof value === 'string') {
        return value;
    }
    return value + "px";
};
var WidgetTestRoute = /** @class */ (function () {
    function WidgetTestRoute(hostRef) {
        registerInstance(this, hostRef);
        this.dataStreamInfos = [];
        this.component = componentTag;
    }
    WidgetTestRoute.prototype.onWidgetUpdated = function (_a) {
        var configUpdate = _a.detail;
        if (configUpdate.dataStreamInfo) {
            this.dataStreamInfos = configUpdate.dataStreamInfo;
        }
    };
    WidgetTestRoute.prototype.render = function () {
        var viewport = Object.assign(Object.assign({}, VIEWPORT), { start: viewportStart, end: viewportEnd, duration: duration, group: 'some-viewport-group' });
        // live mode
        if (duration != null) {
            delete viewport.start;
            delete viewport.end;
        }
        return (h("div", { style: { width: styleSize(width), height: styleSize(height) } }, h(this.component, { widgetId: "some-widget-id", dataStreams: dataStreams, isEditing: isEditing, alarms: alarms, viewport: viewport, legend: legend, size: getSize(width), axis: axis, tableColumns: tableColumns, annotations: annotations, gestures: gestures, messageOverrides: messageOverrides,
            /** TODO: Port these over to the message overrides */
            invalidTagErrorHeader: "invalidComponentTag.header", invalidTagErrorSubheader: "invalidComponentTag.subheader", liveModeOnly: "invalidWidgetForHistoricalData.content" }), h("sc-webgl-context", null)));
    };
    return WidgetTestRoute;
}());
export { WidgetTestRoute as widget_test_route };
