import './index-b3f1c3a1.js';
import { a as getBreachedThreshold } from './utils-96fe4147.js';
import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-06da257a.js';
import { n as numDataPoints, v as vertices, g as getCSSColorByString, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-8273b9c5.js';
import { g as getDistanceFromDuration } from './getDistanceFromDuration-5c7da5d2.js';
/* eslint-disable max-len */
var statusVert = "\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec4 status;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  float width = status.z;\n  float height = status.w;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * width + status.x, position.y * height + status.y, 0.0, 1.0);\n  vColor = color;\n}\n";
var statusFrag = "\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n";
/**
 * Display Constants
 *
 * Adjust these to scale the margins provided within the status chart.
 * This represent which fraction of the 'width' of a given status group a margin.
 */
var HEIGHT = 1;
// a small fudge factor due to the anti aliasing applied on the edges of the visualization.
// the ideal solution would be to fix the shader to give a crisp line.
var MARGIN_FUDGE_FACTOR = 0.5;
// must match css variable --timeline-row-margin-top, with a small fudge factor removed
var STATUS_MARGIN_TOP_PX = 34 - MARGIN_FUDGE_FACTOR;
var DEFAULT_STATUS_BAR_COLOR_1 = [213, 219, 219]; // (r, g, b) from 0 to 255
var DEFAULT_STATUS_BAR_COLOR_2 = [135, 149, 150]; // (r, g, b) from 0 to 255
// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated
// up front per `ChartScene`.
var NUM_POSITION_COMPONENTS = 2; // (x, y)
var NUM_STATUS_COMPONENTS = 4; // (x, y, width, height)
var NUM_COLOR_COMPONENTS = 3; // (r, g, b)
var numStatuses = function (streamVertexSets) { return streamVertexSets.reduce(function (totalStatuses, streamVertexSet) {
    var streamStatuses = Math.max(streamVertexSet.length, 0);
    return totalStatuses + streamStatuses;
}, 0); };
/**
 * Returns clip space width of the bar
 */
var getWidth = function (_a) {
    var nextX = _a.nextX, currX = _a.currX, toClipSpace = _a.toClipSpace, alarms = _a.alarms;
    var expires = alarms ? alarms.expires : undefined;
    if (expires != null) {
        // If we have a staleness, render the bar until it either:
        //  - collides with the next point's x value
        //  - extends to the duration of the staleness
        var maxWidth = getDistanceFromDuration(toClipSpace, expires);
        if (nextX == null) {
            return maxWidth;
        }
        return Math.min(getDistanceFromDuration(toClipSpace, nextX - currX), maxWidth);
    }
    // If we have a point that comes after this point, extend till that point
    if (nextX != null) {
        return getDistanceFromDuration(toClipSpace, nextX - currX);
    }
    // Extend bar 'til present time
    return getDistanceFromDuration(toClipSpace, Date.now() - currX);
};
var updateMesh = function (_a) {
    var dataStreams = _a.dataStreams, mesh = _a.mesh, toClipSpace = _a.toClipSpace, thresholds = _a.thresholds, thresholdOptions = _a.thresholdOptions, chartSize = _a.chartSize, alarms = _a.alarms;
    var streamVertexSets = dataStreams.map(function (stream) { return vertices(stream, stream.resolution); });
    // Set the number of instances of the status are to be rendered.
    // eslint-disable-next-line no-param-reassign
    mesh.count = numStatuses(streamVertexSets);
    var geometry = mesh.geometry;
    var _b = geometry.attributes, color = _b.color, status = _b.status;
    var statusIndex = 0;
    var colorIndex = 0;
    /** Layout */
    var rowHeight = HEIGHT / dataStreams.length;
    var margin = STATUS_MARGIN_TOP_PX / chartSize.height;
    var vizHeight = rowHeight - margin;
    streamVertexSets.forEach(function (streamVertexSet, setIndex) {
        var prevY;
        var currentDefaultGrayColor = DEFAULT_STATUS_BAR_COLOR_1;
        streamVertexSet.forEach(function (currVertex, v) {
            var nextVertex = streamVertexSet[v + 1];
            var _a = (nextVertex || [])[0], nextX = _a === void 0 ? undefined : _a;
            var currX = currVertex[0], currY = currVertex[1];
            if (prevY != null && prevY !== currY) {
                // Swap grays if data value has changed since last point. Don't want to change color of the data point has the same value as the previous data point.
                currentDefaultGrayColor =
                    currentDefaultGrayColor === DEFAULT_STATUS_BAR_COLOR_1
                        ? DEFAULT_STATUS_BAR_COLOR_2
                        : DEFAULT_STATUS_BAR_COLOR_1;
            }
            /**
             * Color Buffer Construction
             */
            var breachedThreshold = getBreachedThreshold(currY, thresholds);
            if (breachedThreshold == null || !thresholdOptions.showColor) {
                var r = currentDefaultGrayColor[0], g = currentDefaultGrayColor[1], b = currentDefaultGrayColor[2];
                // The status-timeline alternates between two grays as a default color.
                // This provides visual contrast when the data value changes, without
                // requiring a user to specify every threshold in advance.
                // In certain use cases of the status-timeline, the values visualized cannot be known ahead of time,
                // but users still need to be able to visually differentiate when they change.
                color.array[colorIndex] = r;
                color.array[colorIndex + 1] = g;
                color.array[colorIndex + 2] = b;
            }
            else {
                var _b = getCSSColorByString(breachedThreshold.color), rr = _b[0], gg = _b[1], bb = _b[2];
                // Set breached threshold color (r, g, b)
                color.array[colorIndex] = rr;
                color.array[colorIndex + 1] = gg;
                color.array[colorIndex + 2] = bb;
            }
            // Increment Indexes by the associated stride of the buffer
            colorIndex += NUM_COLOR_COMPONENTS;
            /**
             * Position Buffer Construction
             *
             * The 'y range' varies from 0 to 1 (HEIGHT). We need to convert pixels over to clip space
             */
            // status x
            status.array[statusIndex] = toClipSpace(currX);
            // status y
            status.array[statusIndex + 1] = HEIGHT - rowHeight * (setIndex + 1);
            // status width
            status.array[statusIndex + 2] = getWidth({ currX: currX, nextX: nextX, toClipSpace: toClipSpace, alarms: alarms });
            // status height
            status.array[statusIndex + 3] = vizHeight;
            // Increment Indexes by the associated stride of the buffer
            statusIndex += NUM_STATUS_COMPONENTS;
            prevY = currY;
        });
    });
    status.needsUpdate = true;
    color.needsUpdate = true;
};
// https://wwwtyro.net/2019/11/18/instanced-lines.html
// 2d vertices composing of two triangles which make up a square
// (0, 1) - - - (1, 1)
//   |  \         |
//   |     \      |
//   |        \   |
// (0, 0) - - - (1, 0)
var unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];
var initializeGeometry = function (geometry, bufferSize) {
    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));
    geometry.setAttribute('status', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_STATUS_COMPONENTS), NUM_STATUS_COMPONENTS, false));
    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));
};
var statusMesh = function (_a) {
    var alarms = _a.alarms, dataStreams = _a.dataStreams, toClipSpace = _a.toClipSpace, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, chartSize = _a.chartSize;
    var instGeo = new InstancedBufferGeometry();
    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);
    // Create and populate geometry
    initializeGeometry(instGeo, bufferSize);
    /**
     * Create Status Mesh
     *
     * The representation of the statuses on a status chart.
     *
     * Utilizes an instance of a single unit square, which then gets
     * stretched and transposed across the canvas.
     */
    var statusChartMaterial = new RawShaderMaterial({
        vertexShader: statusVert,
        fragmentShader: statusFrag,
        side: DoubleSide,
        transparent: false,
    });
    var mesh = new InstancedMesh(instGeo, statusChartMaterial, bufferSize);
    updateMesh({
        dataStreams: dataStreams,
        mesh: mesh,
        toClipSpace: toClipSpace,
        thresholds: thresholds,
        thresholdOptions: thresholdOptions,
        chartSize: chartSize,
        alarms: alarms,
    });
    // Prevent bounding sphere from being called
    mesh.frustumCulled = false;
    return mesh;
};
var updateStatusMesh = function (_a) {
    var alarms = _a.alarms, statuses = _a.statuses, dataStreams = _a.dataStreams, toClipSpace = _a.toClipSpace, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, chartSize = _a.chartSize, hasDataChanged = _a.hasDataChanged, hasAnnotationChanged = _a.hasAnnotationChanged, hasSizeChanged = _a.hasSizeChanged;
    if (hasDataChanged || hasAnnotationChanged || hasSizeChanged) {
        updateMesh({
            dataStreams: dataStreams,
            mesh: statuses,
            toClipSpace: toClipSpace,
            thresholds: thresholds,
            thresholdOptions: thresholdOptions,
            chartSize: chartSize,
            alarms: alarms,
        });
    }
};
var maxDataPointsRendered = function (statuses) { return statuses.geometry.attributes.status.array.length / NUM_STATUS_COMPONENTS; };
var chartScene = function (_a) {
    var alarms = _a.alarms, dataStreams = _a.dataStreams, container = _a.container, viewport = _a.viewport, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, chartSize = _a.chartSize;
    var scene = new Scene();
    var toClipSpace = clipSpaceConversion(viewport);
    scene.add(statusMesh({
        alarms: alarms,
        dataStreams: dataStreams,
        toClipSpace: toClipSpace,
        bufferFactor: bufferFactor,
        minBufferSize: minBufferSize,
        thresholdOptions: thresholdOptions,
        thresholds: thresholds,
        chartSize: chartSize,
    }));
    return constructChartScene({ scene: scene, viewport: viewport, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });
};
var updateChartScene = function (_a) {
    var scene = _a.scene, alarms = _a.alarms, dataStreams = _a.dataStreams, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, viewport = _a.viewport, container = _a.container, onUpdate = _a.onUpdate, chartSize = _a.chartSize, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, hasDataChanged = _a.hasDataChanged, hasAnnotationChanged = _a.hasAnnotationChanged, hasSizeChanged = _a.hasSizeChanged;
    var statuses = scene.scene.children[0];
    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the
    // chart scene, we must fully recreate the chart scene. This is a costly operation.
    var isDataOverflowingBuffer = maxDataPointsRendered(statuses) < numDataPoints(dataStreams);
    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace)) {
        return chartScene({
            onUpdate: onUpdate,
            dataStreams: dataStreams,
            alarms: alarms,
            container: container,
            viewport: viewport,
            minBufferSize: minBufferSize,
            bufferFactor: bufferFactor,
            chartSize: chartSize,
            thresholdOptions: thresholdOptions,
            thresholds: thresholds,
        });
    }
    updateStatusMesh({
        alarms: alarms,
        statuses: statuses,
        dataStreams: dataStreams,
        toClipSpace: scene.toClipSpace,
        thresholdOptions: thresholdOptions,
        thresholds: thresholds,
        chartSize: chartSize,
        hasDataChanged: hasDataChanged,
        hasAnnotationChanged: hasAnnotationChanged,
        hasSizeChanged: hasSizeChanged,
    });
    return scene;
};
export { HEIGHT as H, STATUS_MARGIN_TOP_PX as S, chartScene as c, updateChartScene as u };
