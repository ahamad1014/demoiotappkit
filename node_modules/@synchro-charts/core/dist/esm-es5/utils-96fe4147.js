var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var _b;
import { C as COMPARISON_OPERATOR, a as COMPARATOR_MAP } from './constants-35570903.js';
import { d as displayDate } from './time-b732648c.js';
import { i as isValid } from './predicates-67461267.js';
import { i as isNumeric } from './number-a7331d73.js';
function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(f) {
    var delta = f;
    var compare = f;
    if (f.length === 1) {
        delta = function (d, x) { return f(d) - x; };
        compare = ascendingComparator(f);
    }
    function left(a, x, lo, hi) {
        if (lo == null)
            lo = 0;
        if (hi == null)
            hi = a.length;
        while (lo < hi) {
            var mid = (lo + hi) >>> 1;
            if (compare(a[mid], x) < 0)
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo;
    }
    function right(a, x, lo, hi) {
        if (lo == null)
            lo = 0;
        if (hi == null)
            hi = a.length;
        while (lo < hi) {
            var mid = (lo + hi) >>> 1;
            if (compare(a[mid], x) > 0)
                hi = mid;
            else
                lo = mid + 1;
        }
        return lo;
    }
    function center(a, x, lo, hi) {
        if (lo == null)
            lo = 0;
        if (hi == null)
            hi = a.length;
        var i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left: left, center: center, right: right };
}
function ascendingComparator(f) {
    return function (d, x) { return ascending(f(d), x); };
}
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Returns only thresholds defined for number
 * @param thresholds
 */
var getNumberThresholds = function (thresholds) { return thresholds.filter(function (threshold) { return isNumeric(threshold.value); }); };
/**
 * Returns only annotations defined for numbers
 * @param annotations
 */
var getNumberAnnotations = function (annotations) {
    var yAnnotations = annotations && Array.isArray(annotations.y) && annotations.y;
    if (!yAnnotations) {
        return annotations;
    }
    var numberAnnotations = yAnnotations.filter(function (annotation) { return isNumeric(annotation.value); });
    if (numberAnnotations.length < 1) {
        var annotationProps = __rest(annotations, ["y"]);
        return annotationProps;
    }
    return Object.assign(Object.assign({}, annotations), { y: numberAnnotations });
};
/**
 * Returns an array of the higher priority thresholds.
 *
 * If there is only one threshold with the higher priority severity, returns an
 * array with just that one threshold.
 *
 * If there are multiple thresholds with the same higher priority threshold,
 * returns an array with those thresholds.
 *
 * @param {Array.<Threshold>} t1Array
 * @param {Threshold} t2
 * @returns {Array.<Threshold>}
 */
var isHigherPriorityThresholds = function (t1Array, t2) {
    var _a;
    var t1Severity = (_a = t1Array[0]) === null || _a === void 0 ? void 0 : _a.severity;
    var t2Severity = t2.severity;
    var t2Array = [t2];
    // If no highest priority thresholds yet, return t2 in array.
    if (t1Array.length === 0) {
        return t2Array;
    }
    // If no severity declared OR same severity level, return t1 array with t2 added.
    if ((t1Severity == null && t2Severity == null) || t1Severity === t2Severity) {
        t1Array.push(t2);
        return t1Array;
    }
    // If only t2 severity is declared, return t2 in an array.
    if (t1Severity == null) {
        return t2Array;
    }
    // If only t1 severity is declared, return t1 array.
    if (t2Severity == null) {
        return t1Array;
    }
    // If t1 severity is higher priority, return t1 array.
    // If t2 severity is higher priority, return new array with t2.
    return t1Severity < t2Severity ? t1Array : t2Array;
};
/**
 * Returns an array with the most important thresholds.
 *
 * The most important thresholds are the visuals which are most important to a user
 * This is determined via the `severity`. Lower severity means highest importance.
 *
 * If no thresholds are present with `severity`, an array with all thresholds is returned.
 *
 * @param {Array.<Threshold>} thresholds
 * @returns {Array.<Threshold>}
 */
var highestPriorityThresholds = function (thresholds) {
    return thresholds.reduce(isHigherPriorityThresholds, []);
};
var formatValueString = function (thresholdValue) {
    var upperLimit = 99999;
    var lowerLimit = -9999;
    var lowerBound = 0.001;
    var digits = 5;
    var limit = 4;
    // Handle large numbers greater than 5 digits --> exponential
    if (thresholdValue > upperLimit || thresholdValue < lowerLimit) {
        return thresholdValue.toExponential(digits - limit).toString();
    }
    // Handle small numbers with a large number of decimal places --> exponential
    if ((thresholdValue < lowerBound && thresholdValue > 0) || (thresholdValue > -lowerBound && thresholdValue < 0)) {
        return thresholdValue.toExponential(digits - limit).toString();
    }
    // All other numbers
    return thresholdValue.toString().length > digits
        ? thresholdValue.toString().substr(0, digits)
        : thresholdValue.toString();
};
var valueDisplayText = function (_b) {
    var value = _b.value, resolution = _b.resolution, viewport = _b.viewport, formatText = _b.formatText;
    if (typeof value === 'number') {
        if (formatText) {
            return formatValueString(value);
        }
        return value.toString();
    }
    if (typeof value === 'string') {
        return value;
    }
    if (typeof value === 'boolean') {
        return String(value);
    }
    return displayDate(value, resolution, viewport);
};
/**
 * Getters
 */
var getColor = function (annotation) { return annotation.color; };
var getValueAndText = function (_b) {
    var annotation = _b.annotation, resolution = _b.resolution, viewport = _b.viewport;
    var valueText = annotation.showValue
        ? valueDisplayText({ value: annotation.value, resolution: resolution, viewport: viewport, formatText: false })
        : null;
    var labelText = annotation.label && annotation.label.show ? annotation.label.text : null;
    if (labelText && valueText) {
        return labelText + " (" + valueText + ")";
    }
    if (!valueText && labelText) {
        return labelText;
    }
    if (!labelText && valueText) {
        return "(" + valueText + ")";
    }
    return '';
};
var getText = function (annotation) {
    var labelText = annotation.label && annotation.label.show ? annotation.label.text : null;
    if (labelText) {
        return "" + labelText;
    }
    return '';
};
var getLabelTextVisibility = function (annotation) {
    if (annotation.label && annotation.label.show) {
        return 'inline';
    }
    return 'none';
};
var getValueTextVisibility = function (annotation) {
    if (annotation.showValue) {
        return 'inline';
    }
    return 'none';
};
var getValueAndTextVisibility = function (annotation) {
    var showValueText = annotation.showValue;
    var showLabelText = annotation.label && annotation.label.show;
    if (showValueText || showLabelText) {
        return 'inline';
    }
    return 'none';
};
var getValueText = function (_b) {
    var annotation = _b.annotation, resolution = _b.resolution, viewport = _b.viewport, formatText = _b.formatText;
    var _a;
    var valueText = annotation.showValue
        ? valueDisplayText({ value: annotation.value, resolution: resolution, viewport: viewport, formatText: formatText })
        : null;
    // Add comparison operator with trailing space if it's a threshold
    var comparisonOperator = 'comparisonOperator' in annotation ? ((_a = COMPARATOR_MAP[annotation.comparisonOperator]) !== null && _a !== void 0 ? _a : '') + " " : '';
    if (valueText) {
        return "" + comparisonOperator + valueText;
    }
    return '';
};
var isThresholdBreached = function (value, threshold) {
    var dataStreamValue = isNumeric(value) ? Number(value) : value;
    var thresholdValue = isNumeric(threshold.value) ? Number(threshold.value) : threshold.value;
    var thresholdComparison = threshold.comparisonOperator;
    if (typeof dataStreamValue === 'number' && typeof thresholdValue === 'number') {
        switch (thresholdComparison) {
            case COMPARISON_OPERATOR.GREATER_THAN:
                return dataStreamValue > thresholdValue;
            case COMPARISON_OPERATOR.GREATER_THAN_EQUAL:
                return dataStreamValue >= thresholdValue;
            case COMPARISON_OPERATOR.LESS_THAN:
                return dataStreamValue < thresholdValue;
            case COMPARISON_OPERATOR.LESS_THAN_EQUAL:
                return dataStreamValue <= thresholdValue;
            case COMPARISON_OPERATOR.EQUAL:
                return dataStreamValue === thresholdValue;
            default:
                throw new Error("Unsupported number threshold comparison operator: " + thresholdComparison);
        }
    }
    if (typeof dataStreamValue === 'string' && typeof thresholdValue === 'string') {
        if (thresholdComparison === COMPARISON_OPERATOR.EQUAL) {
            return dataStreamValue === thresholdValue;
        }
        if (thresholdComparison === COMPARISON_OPERATOR.CONTAINS) {
            return dataStreamValue.includes(thresholdValue);
        }
        throw new Error("Unsupported string threshold comparison operator: " + thresholdComparison);
    }
    if (typeof dataStreamValue === 'string' && Array.isArray(thresholdValue)) {
        if (thresholdComparison === COMPARISON_OPERATOR.EQUAL || thresholdComparison === COMPARISON_OPERATOR.CONTAINS) {
            return thresholdValue.some(function (thresholdString) {
                return dataStreamValue.includes(thresholdString);
            });
        }
        throw new Error("Unsupported string array threshold comparison operator: " + thresholdComparison);
    }
    if (typeof dataStreamValue === 'boolean' && typeof thresholdValue === 'boolean') {
        if (thresholdComparison === COMPARISON_OPERATOR.EQUAL) {
            return dataStreamValue === thresholdValue;
        }
        throw new Error("Unsupported boolean threshold comparison operator: " + thresholdComparison);
    }
    return false;
};
var thresholdBisector = bisector(function (threshold) { return threshold.value; }).left;
/**
 * This a map of comparison operator to order. The higher the order means higher the precedence.
 */
var operatorOrder = (_b = {},
    _b[COMPARISON_OPERATOR.LESS_THAN_EQUAL] = 1,
    _b[COMPARISON_OPERATOR.LESS_THAN] = 2,
    _b[COMPARISON_OPERATOR.GREATER_THAN_EQUAL] = 3,
    _b[COMPARISON_OPERATOR.GREATER_THAN] = 4,
    _b[COMPARISON_OPERATOR.EQUAL] = 5,
    _b);
/**
 * Given a list of thresholds, we sort the by the value of the threshold from least to greatest and
 * by the comparators order from least to greatest
 *
 * In the event of multiple thresholds with the same value, the threshold with the highest order will be the
 * one that takes precedence, and other rules colliding will be ignored.
 *
 * Below is an example of sorted threshold:
 *   2 2  2 2     5 5  5 5
 *  >= > <= <    >= > <= <
 */
var sortThreshold = function (thresholds) { return __spreadArrays(thresholds).sort(function (a, b) {
    if (a.value === b.value) {
        return operatorOrder[a.comparisonOperator] - operatorOrder[b.comparisonOperator];
    }
    // TODO: Fix this to work for all cases. value is not always a number or comparing to the same type
    return a.value - b.value;
}); };
/**
 * Gets the most relevant threshold which is considered breached by a given value.
 *
 * The most relevant threshold to a point is determined by the threshold value and its comparator.
 *
 * When there are two or more relevant thresholds to a point,
 *
 * 1) When the value is positive, then we will take the upper threshold, which is the greater one
 *
 * 2) When the value is negative, then we will take the lower threshold, which is the lesser one.
 */
var getBreachedThreshold = function (value, thresholds) {
    if (thresholds.length === 0) {
        return undefined;
    }
    if (typeof value === 'string' || typeof value === 'boolean') {
        return thresholds.find(function (threshold) { return isThresholdBreached(value, threshold); }) || undefined;
    }
    /**
     * Filter by breached thresholds to remove the 'band' feature as the default.
     *
     * https://github.com/awslabs/synchro-charts/issues/153
     *
     * TO-DO: Add the 'in between operator' feature as one of the operator selections to consider
     * breached data points in between 2 thresholds.
     */
    var breachedThresholds = thresholds.filter(function (threshold) { return isThresholdBreached(value, threshold); });
    // Only consider the highest severity breached thresholds.
    var highestSeverityThresholds = highestPriorityThresholds(breachedThresholds);
    var numberThresholds = getNumberThresholds(highestSeverityThresholds);
    var sortedThresholds = sortThreshold(numberThresholds);
    var idx = thresholdBisector(sortedThresholds, value);
    var annotationLeft = sortedThresholds[idx - 1];
    var annotationRight = sortedThresholds[idx];
    // Special case when the idx is exactly the array length and that the last two thresholds are of the same value
    if (idx === numberThresholds.length &&
        numberThresholds.length > 1 &&
        sortedThresholds[idx - 1].value === sortedThresholds[idx - 2].value) {
        annotationLeft = sortedThresholds[idx - 2];
        annotationRight = sortedThresholds[idx - 1];
    }
    // Special case when the idx is at 0 and that the first two values are of the same value.
    if (idx === 0 && numberThresholds.length > 1 && sortedThresholds[idx].value === sortedThresholds[idx + 1].value) {
        annotationLeft = sortedThresholds[idx];
        annotationRight = sortedThresholds[idx + 1];
    }
    if (annotationLeft == null && annotationRight == null) {
        return undefined;
    }
    if (annotationLeft != null && annotationRight == null) {
        return isThresholdBreached(value, annotationLeft) ? annotationLeft : undefined;
    }
    if (annotationLeft == null && annotationRight != null) {
        return isThresholdBreached(value, annotationRight) ? annotationRight : undefined;
    }
    if (isThresholdBreached(value, annotationLeft) && isThresholdBreached(value, annotationRight)) {
        return value >= 0 ? annotationRight : annotationLeft;
    }
    if (isThresholdBreached(value, annotationLeft) && !isThresholdBreached(value, annotationRight)) {
        return annotationLeft;
    }
    if (!isThresholdBreached(value, annotationLeft) && isThresholdBreached(value, annotationRight)) {
        return annotationRight;
    }
    return undefined;
};
var isThreshold = isValid(function (maybeThreshold) { return maybeThreshold.comparisonOperator != null; });
var getThresholds = function (annotations) { return annotations && annotations.y ? annotations.y.filter(isThreshold) : []; };
export { getBreachedThreshold as a, bisector as b, getNumberThresholds as c, ascending as d, getColor as e, getValueAndText as f, getThresholds as g, getValueAndTextVisibility as h, isThreshold as i, getValueTextVisibility as j, getValueText as k, getLabelTextVisibility as l, getText as m, getNumberAnnotations as n, sortThreshold as s };
