import { r as registerInstance, h } from './index-0c943849.js';
import { D as DATA_ALIGNMENT } from './constants-35570903.js';
import { D as DataType } from './dataConstants-856cb1e9.js';
import './index-b3f1c3a1.js';
import './time-b732648c.js';
import { c as getNumberThresholds } from './utils-96fe4147.js';
import './predicates-67461267.js';
import './number-a7331d73.js';
import './getDataPoints-6f8b4e89.js';
import { S as Scene } from './three.module-06da257a.js';
import './_commonjsHelpers-1d681858.js';
import './v4-9366210a.js';
import './index-2e17ff6c.js';
import { a as clipSpaceConversion, c as constructChartScene, n as numDataPoints, b as needsNewClipSpace } from './clipSpaceConversion-8273b9c5.js';
import { P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS, u as updatePointMesh } from './pointMesh-a5aff2b1.js';
import { v as validate } from './validate-b6246900.js';
import { D as DEFAULT_CHART_CONFIG } from './chartDefaults-f5689a69.js';
var chartScene = function (_a) {
    var dataStreams = _a.dataStreams, container = _a.container, viewport = _a.viewport, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var scene = new Scene();
    var toClipSpace = clipSpaceConversion(viewport);
    var numberThresholds = getNumberThresholds(thresholds);
    // Create and add meshes to the chart scene
    var meshList = [];
    meshList[POINT_MESH_INDEX] = pointMesh({
        dataStreams: dataStreams,
        minBufferSize: minBufferSize,
        bufferFactor: bufferFactor,
        toClipSpace: toClipSpace,
        thresholdOptions: thresholdOptions,
        thresholds: numberThresholds,
    });
    meshList.forEach(function (mesh) { return scene.add(mesh); });
    return constructChartScene({ scene: scene, viewport: viewport, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });
};
var maxDataPointsRendered = function (points) { return points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS; };
var updateChartScene = function (_a) {
    var scene = _a.scene, dataStreams = _a.dataStreams, chartSize = _a.chartSize, container = _a.container, viewport = _a.viewport, hasDataChanged = _a.hasDataChanged, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, hasAnnotationChanged = _a.hasAnnotationChanged;
    var points = scene.scene.children[POINT_MESH_INDEX];
    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the
    // chart scene, we must fully recreate the chart scene. This is a costly operation.
    var isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);
    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {
        return chartScene({
            dataStreams: dataStreams,
            chartSize: chartSize,
            container: container,
            viewport: viewport,
            minBufferSize: minBufferSize,
            bufferFactor: bufferFactor,
            onUpdate: onUpdate,
            thresholdOptions: thresholdOptions,
            thresholds: thresholds,
        });
    }
    if (hasDataChanged) {
        updatePointMesh(dataStreams, points, scene.toClipSpace);
    }
    // Return existing scene.
    return scene;
};
// The initial size of buffers. The larger this is, the more memory allocated up front per chart.
// The lower this number is, more likely that charts will have to re-initialize there buffers which is
// a slow operation (CPU bound).
var DEFAULT_MIN_BUFFER_SIZE = 1000;
var DEFAULT_BUFFER_FACTOR = 2;
var tooltip = function (props) { return (h("sc-tooltip", Object.assign({}, props, { visualizesAlarms: false, supportString: false, dataAlignment: DATA_ALIGNMENT.EITHER }))); };
var ScScatterChart = /** @class */ (function () {
    function ScScatterChart(hostRef) {
        registerInstance(this, hostRef);
        this.gestures = true;
        /** Status */
        this.isEditing = false;
        /** Memory Management */
        this.bufferFactor = DEFAULT_BUFFER_FACTOR;
        this.minBufferSize = DEFAULT_MIN_BUFFER_SIZE;
    }
    ScScatterChart.prototype.componentWillRender = function () {
        validate(this);
    };
    ScScatterChart.prototype.render = function () {
        var _this = this;
        return (h("sc-size-provider", { size: this.size, renderFunc: function (rect) { return (h("sc-webgl-base-chart", { supportedDataTypes: [DataType.NUMBER], axis: _this.axis, gestures: _this.gestures, configId: _this.widgetId, legend: _this.legend, annotations: _this.annotations, trends: _this.trends, updateChartScene: updateChartScene, createChartScene: chartScene, size: Object.assign(Object.assign(Object.assign({}, DEFAULT_CHART_CONFIG.size), _this.size), rect), dataStreams: _this.dataStreams, alarms: _this.alarms, viewport: _this.viewport, minBufferSize: _this.minBufferSize, bufferFactor: _this.bufferFactor, isEditing: _this.isEditing, renderTooltip: tooltip, supportString: false, visualizesAlarms: false, messageOverrides: _this.messageOverrides })); } }));
    };
    return ScScatterChart;
}());
export { ScScatterChart as sc_scatter_chart };
