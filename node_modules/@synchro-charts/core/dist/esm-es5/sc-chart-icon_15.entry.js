var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { h, r as registerInstance, g as getElement, H as Host, e as createEvent } from './index-0c943849.js';
import { b as StatusIcon, L as LEGEND_POSITION, D as DATA_ALIGNMENT, S as ScaleType } from './constants-35570903.js';
import { T as TREND_TYPE, S as StreamType, D as DataType } from './dataConstants-856cb1e9.js';
import './terms-d11f73d5.js';
import './index-b3f1c3a1.js';
import { d as displayDate, p as parseDuration } from './time-b732648c.js';
import { b as bisector, d as ascending$1, e as getColor, f as getValueAndText, h as getValueAndTextVisibility, j as getValueTextVisibility, k as getValueText, l as getLabelTextVisibility, m as getText, i as isThreshold, n as getNumberAnnotations } from './utils-96fe4147.js';
import { d as isSupportedDataType, e as isNumber, a as isDefined, b as isMinimalStaticViewport, c as isNumberDataStream } from './predicates-67461267.js';
import { i as isNumeric } from './number-a7331d73.js';
import { a as getVisibleData } from './dataFilters-2772c214.js';
import { b as breachedThreshold, a as activePoints, s as sortTooltipPoints } from './breachedThreshold-500f9d58.js';
import { g as getDataPoints } from './getDataPoints-6f8b4e89.js';
import './three.module-06da257a.js';
import { r as rectScrollFixed, w as webGLRenderer, i as index } from './webglContext-da311040.js';
import { c as createCommonjsModule, a as commonjsGlobal } from './_commonjsHelpers-1d681858.js';
import { g as getDataStreamForEventing } from './common-a5fcad18.js';
import { l as lodash_throttle, D as DATE_RANGE_EMIT_EVENT_MS } from './constants-24b6dac6.js';
import { E as EmptyStatus } from './EmptyStatus-ce5f05f3.js';
import { T as TREND_ICON_DASH_ARRAY, S as STREAM_ICON_STROKE_LINECAP, a as STREAM_ICON_STROKE_WIDTH, b as STREAM_ICON_PATH_COMMAND } from './dataTypes-91d8b311.js';
import { V as Value } from './Value-9ca575b7.js';
import { t as tippy, T as TIPPY_SETTINGS } from './toolTipSettings-fa1c4ac6.js';
import { g as getAggregationFrequency } from './helper-8e4c02dd.js';
import { a as DEFAULT_THRESHOLD_OPTIONS, b as DEFAULT_THRESHOLD_OPTIONS_OFF, D as DEFAULT_CHART_CONFIG } from './chartDefaults-f5689a69.js';
function number(x) {
    return x === null ? NaN : +x;
}
var ascendingBisect = bisector(ascending$1);
var bisectRight = ascendingBisect.right;
var bisectCenter = bisector(number).center;
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start, stop, count) {
    var reverse, i = -1, n, ticks, step;
    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0)
        return [start];
    if (reverse = stop < start)
        n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))
        return [];
    if (step > 0) {
        var r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start)
            ++r0;
        if (r1 * step > stop)
            --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n)
            ticks[i] = (r0 + i) * step;
    }
    else {
        step = -step;
        var r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start)
            ++r0;
        if (r1 / step > stop)
            --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n)
            ticks[i] = (r0 + i) / step;
    }
    if (reverse)
        ticks.reverse();
    return ticks;
}
function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10)
        step1 *= 10;
    else if (error >= e5)
        step1 *= 5;
    else if (error >= e2)
        step1 *= 2;
    return stop < start ? -step1 : step1;
}
/* eslint-disable max-len */
var DEFAULT_SIZE_PX = 16;
var icons = {
    normal: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", fill: color ? "" + color : '#1d8102' }, h("path", { d: "M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm0 14c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z" }), h("path", { d: "M7 8.6l-2-2L3.6 8 7 11.4l4.9-4.9-1.4-1.4z" })));
    },
    active: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", fill: color ? "" + color : '#d13212', viewBox: "0 0 16 16" }, h("g", { fill: "none", "fill-rule": "evenodd" }, h("circle", { cx: "8", cy: "8", r: "7", stroke: color ? "" + color : '#d13212', "stroke-width": "2" }), h("g", { transform: "translate(7 4)" }, h("mask", { id: "b", fill: "#fff" }, h("path", { id: "a", d: "M2.00129021 6v2h-2V6h2zm0-6v5h-2V0h2z" })), h("g", { mask: "url(#b)" }, h("path", { fill: color ? "" + color : '#d13212', d: "M-7-5H9v16H-7z" }))))));
    },
    acknowledged: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", stroke: color ? "" + color : '#3184c2' }, h("path", { fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M2 12.286h5.143L8.857 14l1.714-1.714H14V2H2v10.286z" }), h("path", { fill: "none", "stroke-linecap": "round", "stroke-width": "2", "stroke-miterlimit": "10", d: "M4.99 7H5v.01h-.01zM7.99 7H8v.01h-.01zM10.99 7H11v.01h-.01z" })));
    },
    disabled: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", stroke: color ? "" + color : '#687078' }, h("g", { fill: "none", "stroke-width": "2" }, h("circle", { cx: "8", cy: "8", r: "7", "stroke-linejoin": "round" }), h("path", { "stroke-linecap": "square", "stroke-miterlimit": "10", d: "M11 8H5" }))));
    },
    latched: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", fill: color ? "" + color : '#f89256' }, h("path", { d: "M15.9 14.6l-7-14c-.3-.7-1.5-.7-1.8 0l-7 14c-.2.3-.1.7 0 1 .2.2.6.4.9.4h14c.3 0 .7-.2.9-.5.1-.3.1-.6 0-.9zM2.6 14L8 3.2 13.4 14H2.6z" }), h("path", { d: "M7 11v2h2v-2zM7 6h2v4H7z" })));
    },
    snoozed: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", stroke: color ? "" + color : '#879596' }, h("g", { fill: "none", "stroke-width": "2" }, h("circle", { cx: "8", cy: "8", r: "7", "stroke-linejoin": "round" }), h("path", { "stroke-linecap": "square", "stroke-miterlimit": "10", d: "M8 5v4H5" }))));
    },
    error: function (color, size) {
        if (size === void 0) { size = DEFAULT_SIZE_PX; }
        return (h("svg", { width: size + "px", height: size + "px", viewBox: "0 0 16 16", fill: color ? "" + color : '#FF0000', "data-test-tag": "error" }, h("path", { class: "st4", d: "M13.7 2.3C12.1.8 10.1 0 8 0S3.9.8 2.3 2.3C.8 3.9 0 5.9 0 8s.8 4.1 2.3 5.7C3.9 15.2 5.9 16 8 16s4.1-.8 5.7-2.3C15.2 12.1 16 10.1 16 8s-.8-4.1-2.3-5.7zm-1.5 9.9C11.1 13.4 9.6 14 8 14s-3.1-.6-4.2-1.8S2 9.6 2 8s.6-3.1 1.8-4.2S6.4 2 8 2s3.1.6 4.2 1.8S14 6.4 14 8s-.6 3.1-1.8 4.2z" }), h("path", { class: "st4", d: "M10.1 4.5L8 6.6 5.9 4.5 4.5 5.9 6.6 8l-2.1 2.1 1.4 1.4L8 9.4l2.1 2.1 1.4-1.4L9.4 8l2.1-2.1z" })));
    },
};
var getIcons = function (name, color, size) {
    if (icons[name]) {
        return icons[name](color, size);
    }
    /* eslint-disable-next-line no-console */
    console.warn("Invalid status icon requested: " + name);
    return undefined;
};
var scChartIconCss = ".sc-chart-icon{position:relative;margin-right:3px;top:2px;padding:0.5rem 0;display:inline}";
var ScChartIcon = /** @class */ (function () {
    function ScChartIcon(hostRef) {
        registerInstance(this, hostRef);
        this.name = StatusIcon.NORMAL;
    }
    ScChartIcon.prototype.render = function () {
        return h("div", { class: "sc-chart-icon" }, getIcons(this.name, this.color, this.size));
    };
    return ScChartIcon;
}());
ScChartIcon.style = scChartIconCss;
var scDataStreamNameCss = "sc-data-stream-name{color:var(--polaris-gray-900)}sc-data-stream-name .awsui{color:inherit}";
var ScDataStreamName = /** @class */ (function () {
    function ScDataStreamName(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.displayTooltip = true;
        this.renderTooltip = function () {
            if (_this.displayTooltip) {
                var container = _this.el.querySelector('sc-expandable-input');
                var tooltip = _this.el.querySelector('.data-stream-name-tooltip');
                if (tooltip != null && container != null) {
                    tooltip.style.display = 'block';
                    _this.tooltip = tippy(container, Object.assign(Object.assign({}, TIPPY_SETTINGS), { content: tooltip }));
                }
            }
        };
    }
    ScDataStreamName.prototype.disconnectedCallback = function () {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    };
    ScDataStreamName.prototype.render = function () {
        var _this = this;
        return (h("div", { class: "awsui" }, h("sc-expandable-input", { isDisabled: !this.isEditing, onValueChange: function (value) {
                _this.onNameChange(value);
            }, onMouseOver: this.renderTooltip, onFocus: this.renderTooltip, value: this.label }), h("div", { class: "data-stream-name-tooltip awsui-util-container awsui", style: { display: 'none' } }, h("div", { class: "awsui-util-spacing-v-s" }, h("div", null, h("div", { class: "awsui-util-label" }, this.detailedLabel || this.label), this.pointType && this.pointType === "trend" /* TREND */ && (h("small", null, "This trend line is computed from only visible data."))), this.date && (h("div", null, h("div", { class: "awsui-util-label" }, "Latest value at"), h("div", null, this.date.toLocaleString('en-US', {
            hour12: true,
            minute: 'numeric',
            hour: 'numeric',
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
        }))))))));
    };
    Object.defineProperty(ScDataStreamName.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    return ScDataStreamName;
}());
ScDataStreamName.style = scDataStreamNameCss;
var scErrorBadgeCss = "sc-error-badge div{display:-ms-flexbox;display:flex;padding-left:1.4286em;line-height:1.4286em;color:var(--error-badge-font-color, #6a7070)}sc-error-badge .warning-symbol{font-size:2rem;padding-right:var(--margin-small);font-weight:bold;color:var(--error-badge-warning-color, #fa3232)}";
var ScErrorBadge = /** @class */ (function () {
    function ScErrorBadge(hostRef) {
        registerInstance(this, hostRef);
    }
    ScErrorBadge.prototype.render = function () {
        return (h("div", { "data-test-tag": "error" }, h("span", { class: "warning-symbol" }, "\u26A0"), h("slot", null)));
    };
    return ScErrorBadge;
}());
ScErrorBadge.style = scErrorBadgeCss;
var scExpandableInputCss = "sc-expandable-input .sc-expandable-input{display:inline-block;background:none;color:inherit;word-break:break-word;margin-top:3px;min-width:20px;text-overflow:ellipsis;border:none;border-bottom:var(--border-width) solid var(--polaris-gray-400)}sc-expandable-input .sc-expandable-input.disabled{outline:none;border-bottom-color:rgba(0, 0, 0, 0)}";
var ScExpandableInput = /** @class */ (function () {
    function ScExpandableInput(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.onChange = function (e) {
            var span = e.target;
            _this.onValueChange(span.innerText);
        };
    }
    ScExpandableInput.prototype.render = function () {
        var _a = this, value = _a.value, _b = _a.isDisabled, isDisabled = _b === void 0 ? false : _b;
        return (h("span", { "data-test-tag": "expandable-input", contentEditable: !isDisabled, class: "sc-expandable-input aws-util-font-size-1 " + (isDisabled ? 'disabled' : ''), 
            // spellCheck={('false' as unknown) as boolean}
            onBlur: this.onChange }, value));
    };
    return ScExpandableInput;
}());
ScExpandableInput.style = scExpandableInputCss;
function initRange(domain, range) {
    switch (arguments.length) {
        case 0: break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break;
    }
    return this;
}
function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
}
function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
        prototype[key] = definition[key];
    return prototype;
}
function Color() { }
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
};
define(Color, color, {
    copy: function (channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable: function () {
        return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
});
function color_formatHex() {
    return this.rgb().formatHex();
}
function color_formatHsl() {
    return hslConvert(this).formatHsl();
}
function color_formatRgb() {
    return this.rgb().formatRgb();
}
function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
            : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                    : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
            : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                    : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                            : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
                                    : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
                                        : null;
}
function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
    if (a <= 0)
        r = g = b = NaN;
    return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
    if (!(o instanceof Color))
        o = color(o);
    if (!o)
        return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
    brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function () {
        return this;
    },
    displayable: function () {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
}));
function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
    if (a <= 0)
        h = s = l = NaN;
    else if (l <= 0 || l >= 1)
        h = s = NaN;
    else if (s <= 0)
        h = NaN;
    return new Hsl(h, s, l, a);
}
function hslConvert(o) {
    if (o instanceof Hsl)
        return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
        o = color(o);
    if (!o)
        return new Hsl;
    if (o instanceof Hsl)
        return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max)
            h = (g - b) / s + (g < b) * 6;
        else if (g === max)
            h = (b - r) / s + 2;
        else
            h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    }
    else {
        s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
    brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function () {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
    }
}));
/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
            : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                : m1) * 255;
}
var constant = function (x) { return function () { return x; }; };
function linear(a, d) {
    return function (t) {
        return a + t * d;
    };
}
function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
    };
}
function gamma(y) {
    return (y = +y) === 1 ? nogamma : function (a, b) {
        return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
    };
}
function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}
var rgb$1 = (function rgbGamma(y) {
    var color = gamma(y);
    function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb$1.gamma = rgbGamma;
    return rgb$1;
})(1);
function numberArray(a, b) {
    if (!b)
        b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function (t) {
        for (i = 0; i < n; ++i)
            c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
    };
}
function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
        x[i] = interpolate(a[i], b[i]);
    for (; i < nb; ++i)
        c[i] = b[i];
    return function (t) {
        for (i = 0; i < na; ++i)
            c[i] = x[i](t);
        return c;
    };
}
function date(a, b) {
    var d = new Date;
    return a = +a, b = +b, function (t) {
        return d.setTime(a * (1 - t) + b * t), d;
    };
}
function interpolateNumber(a, b) {
    return a = +a, b = +b, function (t) {
        return a * (1 - t) + b * t;
    };
}
function object(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
        a = {};
    if (b === null || typeof b !== "object")
        b = {};
    for (k in b) {
        if (k in a) {
            i[k] = interpolate(a[k], b[k]);
        }
        else {
            c[k] = b[k];
        }
    }
    return function (t) {
        for (k in i)
            c[k] = i[k](t);
        return c;
    };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
    return function () {
        return b;
    };
}
function one(b) {
    return function (t) {
        return b(t) + "";
    };
}
function string(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
    am, // current match in a
    bm, // current match in b
    bs, // string preceding current number in b, if any
    i = -1, // index in s
    s = [], // string constants and placeholders
    q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
            bs = b.slice(bi, bs);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
            if (s[i])
                s[i] += bm; // coalesce with previous string
            else
                s[++i] = bm;
        }
        else { // interpolate non-matching numbers
            s[++i] = null;
            q.push({ i: i, x: interpolateNumber(am, bm) });
        }
        bi = reB.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i])
            s[i] += bs; // coalesce with previous string
        else
            s[++i] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
}
function interpolate(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant(b)
        : (t === "number" ? interpolateNumber
            : t === "string" ? ((c = color(b)) ? (b = c, rgb$1) : string)
                : b instanceof color ? rgb$1
                    : b instanceof Date ? date
                        : isNumberArray(b) ? numberArray
                            : Array.isArray(b) ? genericArray
                                : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
                                    : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
    return a = +a, b = +b, function (t) {
        return Math.round(a * (1 - t) + b * t);
    };
}
function constants(x) {
    return function () {
        return x;
    };
}
function number$1(x) {
    return +x;
}
var unit = [0, 1];
function identity(x) {
    return x;
}
function normalize(a, b) {
    return (b -= (a = +a))
        ? function (x) { return (x - a) / b; }
        : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
    var t;
    if (a > b)
        t = a, a = b, b = t;
    return function (x) { return Math.max(a, Math.min(b, x)); };
}
// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0)
        d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else
        d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function (x) { return r0(d0(x)); };
}
function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    // Reverse descending domains.
    if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
    }
    while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
    }
    return function (x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
    };
}
function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
}
function transformer() {
    var domain = unit, range = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp = identity, piecewise, output, input;
    function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity)
            clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
    }
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
    }
    scale.invert = function (y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };
    scale.domain = function (_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
    };
    scale.range = function (_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale.rangeRound = function (_) {
        return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
    };
    scale.clamp = function (_) {
        return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
    };
    scale.interpolate = function (_) {
        return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
    };
    scale.unknown = function (_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function (t, u) {
        transform = t, untransform = u;
        return rescale();
    };
}
function continuous() {
    return transformer()(identity, identity);
}
function formatDecimal(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
}
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
        return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}
function exponent(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
    return function (value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while (i > 0 && g > 0) {
            if (length + g + 1 > width)
                g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width)
                break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}
function formatNumerals(numerals) {
    return function (value) {
        return value.replace(/[0-9]/g, function (i) {
            return numerals[+i];
        });
    };
}
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier)))
        throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function () {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
};
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
            case ".":
                i0 = i1 = i;
                break;
            case "0":
                if (i0 === 0)
                    i0 = i;
                i1 = i;
                break;
            default:
                if (!+s[i])
                    break out;
                if (i0 > 0)
                    i0 = 0;
                break;
        }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
        return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
            : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
                : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}
function formatRounded(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
        return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
            : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var formatTypes = {
    "%": function (x, p) { return (x * 100).toFixed(p); },
    "b": function (x) { return Math.round(x).toString(2); },
    "c": function (x) { return x + ""; },
    "d": formatDecimal,
    "e": function (x, p) { return x.toExponential(p); },
    "f": function (x, p) { return x.toFixed(p); },
    "g": function (x, p) { return x.toPrecision(p); },
    "o": function (x) { return Math.round(x).toString(8); },
    "p": function (x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function (x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function (x) { return Math.round(x).toString(16); }
};
function identity$1(x) {
    return x;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "−" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n")
            comma = true, type = "g";
        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type])
            precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "="))
            zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
                : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            }
            else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim)
                    value = formatTrim(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+")
                    valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer “value” part that can be
                // grouped, and fractional or exponential “suffix” part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while (++i < n) {
                        if (c = value.charCodeAt(i), 48 > c || c > 57) {
                            valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                            value = value.slice(0, i);
                            break;
                        }
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero)
                value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero)
                value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch (align) {
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function () {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
        return function (value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
});
function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
}
function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
        case "s": {
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
                specifier.precision = precision;
            return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
            if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
                specifier.precision = precision - (specifier.type === "e");
            break;
        }
        case "f":
        case "%": {
            if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
                specifier.precision = precision - (specifier.type === "%") * 2;
            break;
        }
    }
    return format(specifier);
}
function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function (count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function (count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function (count) {
        if (count == null)
            count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
            step = start, start = stop, stop = step;
            step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
            step = tickIncrement(start, stop, count);
            if (step === prestep) {
                d[i0] = start;
                d[i1] = stop;
                return domain(d);
            }
            else if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
            }
            else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
            }
            else {
                break;
            }
            prestep = step;
        }
        return scale;
    };
    return scale;
}
function linear$1() {
    var scale = continuous();
    scale.copy = function () {
        return copy(scale, linear$1());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
}
function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
}
var t0 = new Date, t1 = new Date;
function newInterval(floori, offseti, count, field) {
    function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
    }
    interval.floor = function (date) {
        return floori(date = new Date(+date)), date;
    };
    interval.ceil = function (date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };
    interval.round = function (date) {
        var d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
    };
    interval.offset = function (date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };
    interval.range = function (start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0))
            return range; // also handles Invalid Date
        do
            range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
    };
    interval.filter = function (test) {
        return newInterval(function (date) {
            if (date >= date)
                while (floori(date), !test(date))
                    date.setTime(date - 1);
        }, function (date, step) {
            if (date >= date) {
                if (step < 0)
                    while (++step <= 0) {
                        while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                    }
                else
                    while (--step >= 0) {
                        while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                    }
            }
        });
    };
    if (count) {
        interval.count = function (start, end) {
            t0.setTime(+start), t1.setTime(+end);
            floori(t0), floori(t1);
            return Math.floor(count(t0, t1));
        };
        interval.every = function (step) {
            step = Math.floor(step);
            return !isFinite(step) || !(step > 0) ? null
                : !(step > 1) ? interval
                    : interval.filter(field
                        ? function (d) { return field(d) % step === 0; }
                        : function (d) { return interval.count(0, d) % step === 0; });
        };
    }
    return interval;
}
var millisecond = newInterval(function () {
    // noop
}, function (date, step) {
    date.setTime(+date + step);
}, function (start, end) {
    return end - start;
});
// An optimized implementation for this simple case.
millisecond.every = function (k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0))
        return null;
    if (!(k > 1))
        return millisecond;
    return newInterval(function (date) {
        date.setTime(Math.floor(date / k) * k);
    }, function (date, step) {
        date.setTime(+date + step * k);
    }, function (start, end) {
        return (end - start) / k;
    });
};
var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
var second = newInterval(function (date) {
    date.setTime(date - date.getMilliseconds());
}, function (date, step) {
    date.setTime(+date + step * durationSecond);
}, function (start, end) {
    return (end - start) / durationSecond;
}, function (date) {
    return date.getUTCSeconds();
});
var minute = newInterval(function (date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function (date, step) {
    date.setTime(+date + step * durationMinute);
}, function (start, end) {
    return (end - start) / durationMinute;
}, function (date) {
    return date.getMinutes();
});
var hour = newInterval(function (date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function (date, step) {
    date.setTime(+date + step * durationHour);
}, function (start, end) {
    return (end - start) / durationHour;
}, function (date) {
    return date.getHours();
});
var day = newInterval(function (date) { return date.setHours(0, 0, 0, 0); }, function (date, step) { return date.setDate(date.getDate() + step); }, function (start, end) { return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay; }, function (date) { return date.getDate() - 1; });
function weekday(i) {
    return newInterval(function (date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step * 7);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var month = newInterval(function (date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
}, function (date, step) {
    date.setMonth(date.getMonth() + step);
}, function (start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
    return date.getMonth();
});
var year = newInterval(function (date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
}, function (date, step) {
    date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
    return end.getFullYear() - start.getFullYear();
}, function (date) {
    return date.getFullYear();
});
// An optimized implementation for this simple case.
year.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step * k);
    });
};
function ticker(year, month, week, day, hour, minute) {
    var tickIntervals = [
        [second, 1, durationSecond],
        [second, 5, 5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute, 1, durationMinute],
        [minute, 5, 5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [hour, 1, durationHour],
        [hour, 3, 3 * durationHour],
        [hour, 6, 6 * durationHour],
        [hour, 12, 12 * durationHour],
        [day, 1, durationDay],
        [day, 2, 2 * durationDay],
        [week, 1, durationWeek],
        [month, 1, durationMonth],
        [month, 3, 3 * durationMonth],
        [year, 1, durationYear]
    ];
    function ticks(start, stop, count) {
        var _a;
        var reverse = stop < start;
        if (reverse)
            _a = [stop, start], start = _a[0], stop = _a[1];
        var interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        var ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
    }
    function tickInterval(start, stop, count) {
        var target = Math.abs(stop - start) / count;
        var i = bisector(function (_a) {
            var step = _a[2];
            return step;
        }).right(tickIntervals, target);
        if (i === tickIntervals.length)
            return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0)
            return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        var _a = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i], t = _a[0], step = _a[1];
        return t.every(step);
    }
    return [ticks, tickInterval];
}
var _a = ticker(year, month, sunday, day, hour, minute), timeTicks = _a[0], timeTickInterval = _a[1];
var t0$1 = new Date, t1$1 = new Date;
function newInterval$1(floori, offseti, count, field) {
    function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
    }
    interval.floor = function (date) {
        return floori(date = new Date(+date)), date;
    };
    interval.ceil = function (date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };
    interval.round = function (date) {
        var d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
    };
    interval.offset = function (date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };
    interval.range = function (start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0))
            return range; // also handles Invalid Date
        do
            range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
    };
    interval.filter = function (test) {
        return newInterval$1(function (date) {
            if (date >= date)
                while (floori(date), !test(date))
                    date.setTime(date - 1);
        }, function (date, step) {
            if (date >= date) {
                if (step < 0)
                    while (++step <= 0) {
                        while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                    }
                else
                    while (--step >= 0) {
                        while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                    }
            }
        });
    };
    if (count) {
        interval.count = function (start, end) {
            t0$1.setTime(+start), t1$1.setTime(+end);
            floori(t0$1), floori(t1$1);
            return Math.floor(count(t0$1, t1$1));
        };
        interval.every = function (step) {
            step = Math.floor(step);
            return !isFinite(step) || !(step > 0) ? null
                : !(step > 1) ? interval
                    : interval.filter(field
                        ? function (d) { return field(d) % step === 0; }
                        : function (d) { return interval.count(0, d) % step === 0; });
        };
    }
    return interval;
}
var durationSecond$1 = 1000;
var durationMinute$1 = durationSecond$1 * 60;
var durationHour$1 = durationMinute$1 * 60;
var durationDay$1 = durationHour$1 * 24;
var durationWeek$1 = durationDay$1 * 7;
var day$1 = newInterval$1(function (date) { return date.setHours(0, 0, 0, 0); }, function (date, step) { return date.setDate(date.getDate() + step); }, function (start, end) { return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1; }, function (date) { return date.getDate() - 1; });
function weekday$1(i) {
    return newInterval$1(function (date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step * 7);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
    });
}
var sunday$1 = weekday$1(0);
var monday$1 = weekday$1(1);
var tuesday$1 = weekday$1(2);
var wednesday$1 = weekday$1(3);
var thursday$1 = weekday$1(4);
var friday$1 = weekday$1(5);
var saturday$1 = weekday$1(6);
var year$1 = newInterval$1(function (date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
}, function (date, step) {
    date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
    return end.getFullYear() - start.getFullYear();
}, function (date) {
    return date.getFullYear();
});
// An optimized implementation for this simple case.
year$1.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$1(function (date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step * k);
    });
};
var utcDay = newInterval$1(function (date) {
    date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
    return (end - start) / durationDay$1;
}, function (date) {
    return date.getUTCDate() - 1;
});
function utcWeekday(i) {
    return newInterval$1(function (date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
    }, function (start, end) {
        return (end - start) / durationWeek$1;
    });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcYear = newInterval$1(function (date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
    return date.getUTCFullYear();
});
// An optimized implementation for this simple case.
utcYear.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$1(function (date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
};
function localDate(d) {
    if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
    return { y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale$1(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
    };
    var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
    };
    var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
    };
    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats) {
        return function (date) {
            var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
            if (!(date instanceof Date))
                date = new Date(+date);
            while (++i < n) {
                if (specifier.charCodeAt(i) === 37) {
                    string.push(specifier.slice(j, i));
                    if ((pad = pads[c = specifier.charAt(++i)]) != null)
                        c = specifier.charAt(++i);
                    else
                        pad = c === "e" ? " " : "0";
                    if (format = formats[c])
                        c = format(date, pad);
                    string.push(c);
                    j = i + 1;
                }
            }
            string.push(specifier.slice(j, i));
            return string.join("");
        };
    }
    function newParse(specifier, Z) {
        return function (string) {
            var d = newDate(1900, undefined, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
            if (i != string.length)
                return null;
            // If a UNIX timestamp is specified, return it.
            if ("Q" in d)
                return new Date(d.Q);
            if ("s" in d)
                return new Date(d.s * 1000 + ("L" in d ? d.L : 0));
            // If this is utcParse, never use the local timezone.
            if (Z && !("Z" in d))
                d.Z = 0;
            // The am-pm flag is 0 for AM, and 1 for PM.
            if ("p" in d)
                d.H = d.H % 12 + d.p * 12;
            // If the month was not specified, inherit from the quarter.
            if (d.m === undefined)
                d.m = "q" in d ? d.q : 0;
            // Convert day-of-week and week-of-year to day-of-year.
            if ("V" in d) {
                if (d.V < 1 || d.V > 53)
                    return null;
                if (!("w" in d))
                    d.w = 1;
                if ("Z" in d) {
                    week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                    week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
                    week = utcDay.offset(week, (d.V - 1) * 7);
                    d.y = week.getUTCFullYear();
                    d.m = week.getUTCMonth();
                    d.d = week.getUTCDate() + (d.w + 6) % 7;
                }
                else {
                    week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                    week = day > 4 || day === 0 ? monday$1.ceil(week) : monday$1(week);
                    week = day$1.offset(week, (d.V - 1) * 7);
                    d.y = week.getFullYear();
                    d.m = week.getMonth();
                    d.d = week.getDate() + (d.w + 6) % 7;
                }
            }
            else if ("W" in d || "U" in d) {
                if (!("w" in d))
                    d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
            }
            // If a time zone is specified, all fields are interpreted as UTC and then
            // offset according to the specified time zone.
            if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
            }
            // Otherwise, all fields are in local time.
            return localDate(d);
        };
    }
    function parseSpecifier(d, specifier, string, j) {
        var i = 0, n = specifier.length, m = string.length, c, parse;
        while (i < n) {
            if (j >= m)
                return -1;
            c = specifier.charCodeAt(i++);
            if (c === 37) {
                c = specifier.charAt(i++);
                parse = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse || ((j = parse(d, string, j)) < 0))
                    return -1;
            }
            else if (c != string.charCodeAt(j++)) {
                return -1;
            }
        }
        return j;
    }
    function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
        return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
        format: function (specifier) {
            var f = newFormat(specifier += "", formats);
            f.toString = function () { return specifier; };
            return f;
        },
        parse: function (specifier) {
            var p = newParse(specifier += "", false);
            p.toString = function () { return specifier; };
            return p;
        },
        utcFormat: function (specifier) {
            var f = newFormat(specifier += "", utcFormats);
            f.toString = function () { return specifier; };
            return f;
        },
        utcParse: function (specifier) {
            var p = newParse(specifier += "", true);
            p.toString = function () { return specifier; };
            return p;
        }
    };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, // note: ignores next directive
percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s) {
    return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
    return new Map(names.map(function (name, i) { return [name.toLowerCase(), i]; }));
}
function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
    return pad(1 + day$1.count(year$1(d), d), p, 3);
}
function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
    return pad(sunday$1.count(year$1(d) - 1, d), p, 2);
}
function dISO(d) {
    var day = d.getDay();
    return (day >= 4 || day === 0) ? thursday$1(d) : thursday$1.ceil(d);
}
function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad(thursday$1.count(year$1(d), d) + (year$1(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
    return d.getDay();
}
function formatWeekNumberMonday(d, p) {
    return pad(monday$1.count(year$1(d) - 1, d), p, 2);
}
function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
    d = dISO(d);
    return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
}
function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = (day >= 4 || day === 0) ? thursday$1(d) : thursday$1.ceil(d);
    return pad(d.getFullYear() % 10000, p, 4);
}
function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
    var day = d.getUTCDay();
    return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    return pad(d.getUTCFullYear() % 10000, p, 4);
}
function formatUTCZone() {
    return "+0000";
}
function formatLiteralPercent() {
    return "%";
}
function formatUnixTimestamp(d) {
    return +d;
}
function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
}
var locale$1;
var timeFormat;
defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    timeFormat = locale$1.format;
    return locale$1;
}
function date$1(t) {
    return new Date(t);
}
function number$2(t) {
    return t instanceof Date ? +t : +new Date(+t);
}
function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
    var scale = continuous(), invert = scale.invert, domain = scale.domain;
    var formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear = format("%Y");
    function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
                : hour(date) < date ? formatMinute
                    : day(date) < date ? formatHour
                        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
                            : year(date) < date ? formatMonth
                                : formatYear)(date);
    }
    scale.invert = function (y) {
        return new Date(invert(y));
    };
    scale.domain = function (_) {
        return arguments.length ? domain(Array.from(_, number$2)) : domain().map(date$1);
    };
    scale.ticks = function (interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
    };
    scale.tickFormat = function (count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
    };
    scale.nice = function (interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function")
            interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
    };
    scale.copy = function () {
        return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
    };
    return scale;
}
function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
        name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
    return function () {
        var document = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
    };
}
function creatorFixed(fullname) {
    return function () {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
}
function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
}
function none() { }
function selector(selector) {
    return selector == null ? none : function () {
        return this.querySelector(selector);
    };
}
function selection_select(select) {
    if (typeof select !== "function")
        select = selector(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                if ("__data__" in node)
                    subnode.__data__ = node.__data__;
                subgroup[i] = subnode;
            }
        }
    }
    return new Selection(subgroups, this._parents);
}
function empty() {
    return [];
}
function selectorAll(selector) {
    return selector == null ? empty : function () {
        return this.querySelectorAll(selector);
    };
}
function selection_selectAll(select) {
    if (typeof select !== "function")
        select = selectorAll(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
                subgroups.push(select.call(node, node.__data__, i, group));
                parents.push(node);
            }
        }
    }
    return new Selection(subgroups, parents);
}
function matcher(selector) {
    return function () {
        return this.matches(selector);
    };
}
function selection_filter(match) {
    if (typeof match !== "function")
        match = matcher(match);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                subgroup.push(node);
            }
        }
    }
    return new Selection(subgroups, this._parents);
}
function sparse(update) {
    return new Array(update.length);
}
function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
}
EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function (selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
};
function constant$1(x) {
    return function () {
        return x;
    };
}
var keyPrefix = "$"; // Protect against keys like “__proto__”.
function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
        if (node = group[i]) {
            node.__data__ = data[i];
            update[i] = node;
        }
        else {
            enter[i] = new EnterNode(parent, data[i]);
        }
    }
    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
        if (node = group[i]) {
            exit[i] = node;
        }
    }
}
function bindKey(parent, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
            keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
            if (keyValue in nodeByKeyValue) {
                exit[i] = node;
            }
            else {
                nodeByKeyValue[keyValue] = node;
            }
        }
    }
    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
            update[i] = node;
            node.__data__ = data[i];
            nodeByKeyValue[keyValue] = null;
        }
        else {
            enter[i] = new EnterNode(parent, data[i]);
        }
    }
    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
            exit[i] = node;
        }
    }
}
function selection_data(value, key) {
    if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function (d) { data[++j] = d; });
        return data;
    }
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
        value = constant$1(value);
    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
            if (previous = enterGroup[i0]) {
                if (i0 >= i1)
                    i1 = i0 + 1;
                while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                    ;
                previous._next = next || null;
            }
        }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
}
function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null)
        update = onupdate(update);
    if (onexit == null)
        exit.remove();
    else
        onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(selection) {
    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
                merge[i] = node;
            }
        }
    }
    for (; j < m0; ++j) {
        merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
}
function selection_order() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
            if (node = group[i]) {
                if (next && node.compareDocumentPosition(next) ^ 4)
                    next.parentNode.insertBefore(node, next);
                next = node;
            }
        }
    }
    return this;
}
function selection_sort(compare) {
    if (!compare)
        compare = ascending;
    function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group[i]) {
                sortgroup[i] = node;
            }
        }
        sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
}
function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function () { nodes[++i] = this; });
    return nodes;
}
function selection_node() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
            var node = group[i];
            if (node)
                return node;
        }
    }
    return null;
}
function selection_size() {
    var size = 0;
    this.each(function () { ++size; });
    return size;
}
function selection_empty() {
    return !this.node();
}
function selection_each(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
            if (node = group[i])
                callback.call(node, node.__data__, i, group);
        }
    }
    return this;
}
function attrRemove(name) {
    return function () {
        this.removeAttribute(name);
    };
}
function attrRemoveNS(fullname) {
    return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
    };
}
function attrConstant(name, value) {
    return function () {
        this.setAttribute(name, value);
    };
}
function attrConstantNS(fullname, value) {
    return function () {
        this.setAttributeNS(fullname.space, fullname.local, value);
    };
}
function attrFunction(name, value) {
    return function () {
        var v = value.apply(this, arguments);
        if (v == null)
            this.removeAttribute(name);
        else
            this.setAttribute(name, v);
    };
}
function attrFunctionNS(fullname, value) {
    return function () {
        var v = value.apply(this, arguments);
        if (v == null)
            this.removeAttributeNS(fullname.space, fullname.local);
        else
            this.setAttributeNS(fullname.space, fullname.local, v);
    };
}
function selection_attr(name, value) {
    var fullname = namespace(name);
    if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
    }
    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}
function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
}
function styleRemove(name) {
    return function () {
        this.style.removeProperty(name);
    };
}
function styleConstant(name, value, priority) {
    return function () {
        this.style.setProperty(name, value, priority);
    };
}
function styleFunction(name, value, priority) {
    return function () {
        var v = value.apply(this, arguments);
        if (v == null)
            this.style.removeProperty(name);
        else
            this.style.setProperty(name, v, priority);
    };
}
function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
}
function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
    return function () {
        delete this[name];
    };
}
function propertyConstant(name, value) {
    return function () {
        this[name] = value;
    };
}
function propertyFunction(name, value) {
    return function () {
        var v = value.apply(this, arguments);
        if (v == null)
            delete this[name];
        else
            this[name] = v;
    };
}
function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
}
function classArray(string) {
    return string.trim().split(/^|\s+/);
}
function classList(node) {
    return node.classList || new ClassList(node);
}
function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
    add: function (name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    remove: function (name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
            this._names.splice(i, 1);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    contains: function (name) {
        return this._names.indexOf(name) >= 0;
    }
};
function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
        list.add(names[i]);
}
function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
        list.remove(names[i]);
}
function classedTrue(names) {
    return function () {
        classedAdd(this, names);
    };
}
function classedFalse(names) {
    return function () {
        classedRemove(this, names);
    };
}
function classedFunction(names, value) {
    return function () {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
}
function selection_classed(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n)
            if (!list.contains(names[i]))
                return false;
        return true;
    }
    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
}
function textRemove() {
    this.textContent = "";
}
function textConstant(value) {
    return function () {
        this.textContent = value;
    };
}
function textFunction(value) {
    return function () {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
    };
}
function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
}
function htmlRemove() {
    this.innerHTML = "";
}
function htmlConstant(value) {
    return function () {
        this.innerHTML = value;
    };
}
function htmlFunction(value) {
    return function () {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
    };
}
function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
}
function raise() {
    if (this.nextSibling)
        this.parentNode.appendChild(this);
}
function selection_raise() {
    return this.each(raise);
}
function lower() {
    if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
    return this.each(lower);
}
function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function () {
        return this.appendChild(create.apply(this, arguments));
    });
}
function constantNull() {
    return null;
}
function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name), select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function () {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
}
function remove() {
    var parent = this.parentNode;
    if (parent)
        parent.removeChild(this);
}
function selection_remove() {
    return this.each(remove);
}
function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
}
var filterEvents = {};
var event = null;
if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
        filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
    }
}
function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function (event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
            listener.call(this, event);
        }
    };
}
function contextListener(listener, index, group) {
    return function (event1) {
        var event0 = event; // Events can be reentrant (e.g., focus).
        event = event1;
        try {
            listener.call(this, this.__data__, index, group);
        }
        finally {
            event = event0;
        }
    };
}
function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0)
            name = t.slice(i + 1), t = t.slice(0, i);
        return { type: t, name: name };
    });
}
function onRemove(typename) {
    return function () {
        var on = this.__on;
        if (!on)
            return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
            if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                this.removeEventListener(o.type, o.listener, o.capture);
            }
            else {
                on[++i] = o;
            }
        }
        if (++i)
            on.length = i;
        else
            delete this.__on;
    };
}
function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function (d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on)
            for (var j = 0, m = on.length; j < m; ++j) {
                if ((o = on[j]).type === typename.type && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                    this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                    o.value = value;
                    return;
                }
            }
        this.addEventListener(typename.type, listener, capture);
        o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
        if (!on)
            this.__on = [o];
        else
            on.push(o);
    };
}
function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
        var on = this.node().__on;
        if (on)
            for (var j = 0, m = on.length, o; j < m; ++j) {
                for (i = 0, o = on[j]; i < n; ++i) {
                    if ((t = typenames[i]).type === o.type && t.name === o.name) {
                        return o.value;
                    }
                }
            }
        return;
    }
    on = value ? onAdd : onRemove;
    if (capture == null)
        capture = false;
    for (i = 0; i < n; ++i)
        this.each(on(typenames[i], value, capture));
    return this;
}
function customEvent(event1, listener, that, args) {
    var event0 = event;
    event1.sourceEvent = event;
    event = event1;
    try {
        return listener.apply(that, args);
    }
    finally {
        event = event0;
    }
}
function dispatchEvent(node, type, params) {
    var window = defaultView(node), event = window.CustomEvent;
    if (typeof event === "function") {
        event = new event(type, params);
    }
    else {
        event = window.document.createEvent("Event");
        if (params)
            event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else
            event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
    return function () {
        return dispatchEvent(this, type, params);
    };
}
function dispatchFunction(type, params) {
    return function () {
        return dispatchEvent(this, type, params.apply(this, arguments));
    };
}
function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
}
var root = [null];
function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
}
function selection() {
    return new Selection([[document.documentElement]], root);
}
Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
};
function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
}
function sourceEvent() {
    var current = event, source;
    while (source = current.sourceEvent)
        current = source;
    return current;
}
function point(node, event) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
    }
    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}
function mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches)
        event = event.changedTouches[0];
    return point(node, event);
}
function touch(node, touches, identifier) {
    if (arguments.length < 3)
        identifier = touches, touches = sourceEvent().changedTouches;
    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
        if ((touch = touches[i]).identifier === identifier) {
            return point(node, touch);
        }
    }
    return null;
}
var noop = { value: function () { } };
function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t))
            throw new Error("illegal type: " + t);
        _[t] = [];
    }
    return new Dispatch(_);
}
function Dispatch(_) {
    this._ = _;
}
function parseTypenames$1(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0)
            name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t))
            throw new Error("unknown type: " + t);
        return { type: t, name: name };
    });
}
Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function (typename, callback) {
        var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;
        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
            while (++i < n)
                if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
                    return t;
            return;
        }
        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function")
            throw new Error("invalid callback: " + callback);
        while (++i < n) {
            if (t = (typename = T[i]).type)
                _[t] = set(_[t], typename.name, callback);
            else if (callback == null)
                for (t in _)
                    _[t] = set(_[t], typename.name, null);
        }
        return this;
    },
    copy: function () {
        var copy = {}, _ = this._;
        for (var t in _)
            copy[t] = _[t].slice();
        return new Dispatch(copy);
    },
    call: function (type, that) {
        if ((n = arguments.length - 2) > 0)
            for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type))
            throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i)
            t[i].value.apply(that, args);
    },
    apply: function (type, that, args) {
        if (!this._.hasOwnProperty(type))
            throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
            t[i].value.apply(that, args);
    }
};
function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
            return c.value;
        }
    }
}
function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
            type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
            break;
        }
    }
    if (callback != null)
        type.push({ name: name, value: callback });
    return type;
}
function nopropagation() {
    event.stopImmediatePropagation();
}
function noevent() {
    event.preventDefault();
    event.stopImmediatePropagation();
}
function dragDisable(view) {
    var root = view.document.documentElement, selection = select(view).on("dragstart.drag", noevent, true);
    if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent, true);
    }
    else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
    }
}
function yesdrag(view, noclick) {
    var root = view.document.documentElement, selection = select(view).on("dragstart.drag", null);
    if (noclick) {
        selection.on("click.drag", noevent, true);
        setTimeout(function () { selection.on("click.drag", null); }, 0);
    }
    if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
    }
    else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
    }
}
function constant$2(x) {
    return function () {
        return x;
    };
}
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
    this.target = target;
    this.type = type;
    this.subject = subject;
    this.identifier = id;
    this.active = active;
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this._ = dispatch;
}
DragEvent.prototype.on = function () {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
};
// Ignore right-click, since that should open the context menu.
function defaultFilter() {
    return !event.ctrlKey && !event.button;
}
function defaultContainer() {
    return this.parentNode;
}
function defaultSubject(d) {
    return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
}
function drag() {
    var filter = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
            .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned() {
        if (touchending || !filter.apply(this, arguments))
            return;
        var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
        if (!gesture)
            return;
        select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
        dragDisable(event.view);
        nopropagation();
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start");
    }
    function mousemoved() {
        noevent();
        if (!mousemoving) {
            var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
            mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag");
    }
    function mouseupped() {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent();
        gestures.mouse("end");
    }
    function touchstarted() {
        if (!filter.apply(this, arguments))
            return;
        var touches = event.changedTouches, c = container.apply(this, arguments), n = touches.length, i, gesture;
        for (i = 0; i < n; ++i) {
            if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
                nopropagation();
                gesture("start");
            }
        }
    }
    function touchmoved() {
        var touches = event.changedTouches, n = touches.length, i, gesture;
        for (i = 0; i < n; ++i) {
            if (gesture = gestures[touches[i].identifier]) {
                noevent();
                gesture("drag");
            }
        }
    }
    function touchended() {
        var touches = event.changedTouches, n = touches.length, i, gesture;
        if (touchending)
            clearTimeout(touchending);
        touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
            if (gesture = gestures[touches[i].identifier]) {
                nopropagation();
                gesture("end");
            }
        }
    }
    function beforestart(id, container, point, that, args) {
        var p = point(container, id), s, dx, dy, sublisteners = listeners.copy();
        if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
            if ((event.subject = s = subject.apply(that, args)) == null)
                return false;
            dx = s.x - p[0] || 0;
            dy = s.y - p[1] || 0;
            return true;
        }))
            return;
        return function gesture(type) {
            var p0 = p, n;
            switch (type) {
                case "start":
                    gestures[id] = gesture, n = active++;
                    break;
                case "end": delete gestures[id], --active; // nobreak
                case "drag":
                    p = point(container, id), n = active;
                    break;
            }
            customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
        };
    }
    drag.filter = function (_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
    };
    drag.container = function (_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
    };
    drag.subject = function (_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
    };
    drag.touchable = function (_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
    };
    drag.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
    };
    drag.clickDistance = function (_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
}
function define$1(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
}
function extend$1(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
        prototype[key] = definition[key];
    return prototype;
}
function Color$1() { }
var darker$1 = 0.7;
var brighter$1 = 1 / darker$1;
var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"), reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"), reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"), reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"), reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"), reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
var named$1 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
};
define$1(Color$1, color$1, {
    copy: function (channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable: function () {
        return this.rgb().displayable();
    },
    hex: color_formatHex$1,
    formatHex: color_formatHex$1,
    formatHsl: color_formatHsl$1,
    formatRgb: color_formatRgb$1,
    toString: color_formatRgb$1
});
function color_formatHex$1() {
    return this.rgb().formatHex();
}
function color_formatHsl$1() {
    return hslConvert$1(this).formatHsl();
}
function color_formatRgb$1() {
    return this.rgb().formatRgb();
}
function color$1(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) // #ff0000
        : l === 3 ? new Rgb$1((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
            : l === 8 ? rgba$1(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                : l === 4 ? rgba$1((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                    : null) // invalid hex
        : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
            : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                    : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                        : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                            : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) // eslint-disable-line no-prototype-builtins
                                    : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0)
                                        : null;
}
function rgbn$1(n) {
    return new Rgb$1(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba$1(r, g, b, a) {
    if (a <= 0)
        r = g = b = NaN;
    return new Rgb$1(r, g, b, a);
}
function rgbConvert$1(o) {
    if (!(o instanceof Color$1))
        o = color$1(o);
    if (!o)
        return new Rgb$1;
    o = o.rgb();
    return new Rgb$1(o.r, o.g, o.b, o.opacity);
}
function rgb$2(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb$1(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
define$1(Rgb$1, rgb$2, extend$1(Color$1, {
    brighter: function (k) {
        k = k == null ? brighter$1 : Math.pow(brighter$1, k);
        return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function (k) {
        k = k == null ? darker$1 : Math.pow(darker$1, k);
        return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function () {
        return this;
    },
    displayable: function () {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex$1,
    formatHex: rgb_formatHex$1,
    formatRgb: rgb_formatRgb$1,
    toString: rgb_formatRgb$1
}));
function rgb_formatHex$1() {
    return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
}
function rgb_formatRgb$1() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
}
function hex$1(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h, s, l, a) {
    if (a <= 0)
        h = s = l = NaN;
    else if (l <= 0 || l >= 1)
        h = s = NaN;
    else if (s <= 0)
        h = NaN;
    return new Hsl$1(h, s, l, a);
}
function hslConvert$1(o) {
    if (o instanceof Hsl$1)
        return new Hsl$1(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$1))
        o = color$1(o);
    if (!o)
        return new Hsl$1;
    if (o instanceof Hsl$1)
        return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max)
            h = (g - b) / s + (g < b) * 6;
        else if (g === max)
            h = (b - r) / s + 2;
        else
            h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    }
    else {
        s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$1(h, s, l, o.opacity);
}
function hsl$1(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl$1(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
define$1(Hsl$1, hsl$1, extend$1(Color$1, {
    brighter: function (k) {
        k = k == null ? brighter$1 : Math.pow(brighter$1, k);
        return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
        k = k == null ? darker$1 : Math.pow(darker$1, k);
        return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb$1(hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$1(h, m1, m2), hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function () {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
    }
}));
/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb$1(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
            : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                : m1) * 255;
}
function constant$3(x) {
    return function () {
        return x;
    };
}
function linear$2(a, d) {
    return function (t) {
        return a + t * d;
    };
}
function exponential$1(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
    };
}
function gamma$1(y) {
    return (y = +y) === 1 ? nogamma$1 : function (a, b) {
        return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);
    };
}
function nogamma$1(a, b) {
    var d = b - a;
    return d ? linear$2(a, d) : constant$3(isNaN(a) ? b : a);
}
var interpolateRgb = (function rgbGamma(y) {
    var color = gamma$1(y);
    function rgb(start, end) {
        var r = color((start = rgb$2(start)).r, (end = rgb$2(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma$1(start.opacity, end.opacity);
        return function (t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb.gamma = rgbGamma;
    return rgb;
})(1);
function interpolateNumber$1(a, b) {
    return a = +a, b = +b, function (t) {
        return a * (1 - t) + b * t;
    };
}
var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$1 = new RegExp(reA$1.source, "g");
function zero$1(b) {
    return function () {
        return b;
    };
}
function one$1(b) {
    return function (t) {
        return b(t) + "";
    };
}
function interpolateString(a, b) {
    var bi = reA$1.lastIndex = reB$1.lastIndex = 0, // scan index for next number in b
    am, // current match in a
    bm, // current match in b
    bs, // string preceding current number in b, if any
    i = -1, // index in s
    s = [], // string constants and placeholders
    q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while ((am = reA$1.exec(a))
        && (bm = reB$1.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
            bs = b.slice(bi, bs);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
            if (s[i])
                s[i] += bm; // coalesce with previous string
            else
                s[++i] = bm;
        }
        else { // interpolate non-matching numbers
            s[++i] = null;
            q.push({ i: i, x: interpolateNumber$1(am, bm) });
        }
        bi = reB$1.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i])
            s[i] += bs; // coalesce with previous string
        else
            s[++i] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one$1(q[0].x)
        : zero$1(b))
        : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
}
var degrees = 180 / Math.PI;
var identity$2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
};
function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b))
        a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d)
        c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d))
        c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c)
        a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
    };
}
var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
    if (value === "none")
        return identity$2;
    if (!cssNode)
        cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    value = value.slice(7, -1).split(",");
    return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
    if (value == null)
        return identity$2;
    if (!svgNode)
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
        return identity$2;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s) {
        return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
            var i = s.push("translate(", null, pxComma, null, pxParen);
            q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
        }
        else if (xb || yb) {
            s.push("translate(" + xb + pxComma + yb + pxParen);
        }
    }
    function rotate(a, b, s, q) {
        if (a !== b) {
            if (a - b > 180)
                b += 360;
            else if (b - a > 180)
                a += 360; // shortest path
            q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
        }
        else if (b) {
            s.push(pop(s) + "rotate(" + b + degParen);
        }
    }
    function skewX(a, b, s, q) {
        if (a !== b) {
            q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
        }
        else if (b) {
            s.push(pop(s) + "skewX(" + b + degParen);
        }
    }
    function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
            var i = s.push(pop(s) + "scale(", null, ",", null, ")");
            q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
        }
        else if (xb !== 1 || yb !== 1) {
            s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
    }
    return function (a, b) {
        var s = [], // string constants and placeholders
        q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function (t) {
            var i = -1, n = q.length, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2 = 1e-12;
function cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function interpolateZoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
        S = Math.log(w1 / w0) / rho;
        i = function (t) {
            return [
                ux0 + t * dx,
                uy0 + t * dy,
                w0 * Math.exp(rho * t * S)
            ];
        };
    }
    // General case.
    else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function (t) {
            var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
                ux0 + u * dx,
                uy0 + u * dy,
                w0 * coshr0 / cosh(rho * s + r0)
            ];
        };
    }
    i.duration = S * 1000;
    return i;
}
var frame = 0, // is an animation frame pending?
timeout = 0, // is a timeout pending?
interval = 0, // are any timers active?
pokeDelay = 1000, // how frequently we check for clock skew
taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) { setTimeout(f, 17); };
function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
    clockNow = 0;
}
function Timer() {
    this._call =
        this._time =
            this._next = null;
}
Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function (callback, delay, time) {
        if (typeof callback !== "function")
            throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
            if (taskTail)
                taskTail._next = this;
            else
                taskHead = this;
            taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
    },
    stop: function () {
        if (this._call) {
            this._call = null;
            this._time = Infinity;
            sleep();
        }
    }
};
function timer(callback, delay, time) {
    var t = new Timer;
    t.restart(callback, delay, time);
    return t;
}
function timerFlush() {
    now(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead, e;
    while (t) {
        if ((e = clockNow - t._time) >= 0)
            t._call.call(null, e);
        t = t._next;
    }
    --frame;
}
function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
        timerFlush();
    }
    finally {
        frame = 0;
        nap();
        clockNow = 0;
    }
}
function poke() {
    var now = clock.now(), delay = now - clockLast;
    if (delay > pokeDelay)
        clockSkew -= delay, clockLast = now;
}
function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
        if (t1._call) {
            if (time > t1._time)
                time = t1._time;
            t0 = t1, t1 = t1._next;
        }
        else {
            t2 = t1._next, t1._next = null;
            t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
    }
    taskTail = t0;
    sleep(time);
}
function sleep(time) {
    if (frame)
        return; // Soonest alarm already set, or will be.
    if (timeout)
        timeout = clearTimeout(timeout);
    var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
        if (time < Infinity)
            timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval)
            interval = clearInterval(interval);
    }
    else {
        if (!interval)
            clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
    }
}
function timeout$1(callback, delay, time) {
    var t = new Timer;
    delay = delay == null ? 0 : +delay;
    t.restart(function (elapsed) {
        t.stop();
        callback(elapsed + delay);
    }, delay, time);
    return t;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules)
        node.__transition = {};
    else if (id in schedules)
        return;
    create(node, id, {
        name: name,
        index: index,
        group: group,
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
    });
}
function init(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > CREATED)
        throw new Error("too late; already scheduled");
    return schedule;
}
function set$1(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > STARTED)
        throw new Error("too late; already running");
    return schedule;
}
function get$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id]))
        throw new Error("transition not found");
    return schedule;
}
function create(node, id, self) {
    var schedules = node.__transition, tween;
    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = timer(schedule, 0, self.time);
    function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);
        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed)
            start(elapsed - self.delay);
    }
    function start(elapsed) {
        var i, j, n, o;
        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED)
            return stop();
        for (i in schedules) {
            o = schedules[i];
            if (o.name !== self.name)
                continue;
            // While this element already has a starting transition during this frame,
            // defer starting an interrupting transition until that transition has a
            // chance to tick (and possibly end); see d3/d3-transition#54!
            if (o.state === STARTED)
                return timeout$1(start);
            // Interrupt the active transition, if any.
            if (o.state === RUNNING) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("interrupt", node, node.__data__, o.index, o.group);
                delete schedules[i];
            }
            // Cancel any pre-empted transitions.
            else if (+i < id) {
                o.state = ENDED;
                o.timer.stop();
                o.on.call("cancel", node, node.__data__, o.index, o.group);
                delete schedules[i];
            }
        }
        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout$1(function () {
            if (self.state === STARTED) {
                self.state = RUNNING;
                self.timer.restart(tick, self.delay, self.time);
                tick(elapsed);
            }
        });
        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING)
            return; // interrupted
        self.state = STARTED;
        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
            if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                tween[++j] = o;
            }
        }
        tween.length = j + 1;
    }
    function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
        while (++i < n) {
            tween[i].call(node, t);
        }
        // Dispatch the end event.
        if (self.state === ENDING) {
            self.on.call("end", node, node.__data__, self.index, self.group);
            stop();
        }
    }
    function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules)
            return; // eslint-disable-line no-unused-vars
        delete node.__transition;
    }
}
function interrupt(node, name) {
    var schedules = node.__transition, schedule, active, empty = true, i;
    if (!schedules)
        return;
    name = name == null ? null : name + "";
    for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) {
            empty = false;
            continue;
        }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
    }
    if (empty)
        delete node.__transition;
}
function selection_interrupt(name) {
    return this.each(function () {
        interrupt(this, name);
    });
}
function tweenRemove(id, name) {
    var tween0, tween1;
    return function () {
        var schedule = set$1(this, id), tween = schedule.tween;
        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
            tween1 = tween0 = tween;
            for (var i = 0, n = tween1.length; i < n; ++i) {
                if (tween1[i].name === name) {
                    tween1 = tween1.slice();
                    tween1.splice(i, 1);
                    break;
                }
            }
        }
        schedule.tween = tween1;
    };
}
function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function")
        throw new Error;
    return function () {
        var schedule = set$1(this, id), tween = schedule.tween;
        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
            tween1 = (tween0 = tween).slice();
            for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
                if (tween1[i].name === name) {
                    tween1[i] = t;
                    break;
                }
            }
            if (i === n)
                tween1.push(t);
        }
        schedule.tween = tween1;
    };
}
function transition_tween(name, value) {
    var id = this._id;
    name += "";
    if (arguments.length < 2) {
        var tween = get$1(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
            if ((t = tween[i]).name === name) {
                return t.value;
            }
        }
        return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}
function tweenValue(transition, name, value) {
    var id = transition._id;
    transition.each(function () {
        var schedule = set$1(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function (node) {
        return get$1(node, id).value[name];
    };
}
function interpolate$1(a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber$1
        : b instanceof color$1 ? interpolateRgb
            : (c = color$1(b)) ? (b = c, interpolateRgb)
                : interpolateString)(a, b);
}
function attrRemove$1(name) {
    return function () {
        this.removeAttribute(name);
    };
}
function attrRemoveNS$1(fullname) {
    return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
    };
}
function attrConstant$1(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function () {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
                : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function attrConstantNS$1(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function () {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
                : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function attrFunction$1(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function () {
        var string0, value1 = value(this), string1;
        if (value1 == null)
            return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
                : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
function attrFunctionNS$1(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function () {
        var string0, value1 = value(this), string1;
        if (value1 == null)
            return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
                : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
function transition_attr(name, value) {
    var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
    return this.attrTween(name, typeof value === "function"
        ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
        : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
            : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
}
function attrInterpolate(name, i) {
    return function (t) {
        this.setAttribute(name, i.call(this, t));
    };
}
function attrInterpolateNS(fullname, i) {
    return function (t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
}
function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
            t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
    }
    tween._value = value;
    return tween;
}
function attrTween(name, value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
            t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
    }
    tween._value = value;
    return tween;
}
function transition_attrTween(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
    if (value == null)
        return this.tween(key, null);
    if (typeof value !== "function")
        throw new Error;
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id, value) {
    return function () {
        init(this, id).delay = +value.apply(this, arguments);
    };
}
function delayConstant(id, value) {
    return value = +value, function () {
        init(this, id).delay = value;
    };
}
function transition_delay(value) {
    var id = this._id;
    return arguments.length
        ? this.each((typeof value === "function"
            ? delayFunction
            : delayConstant)(id, value))
        : get$1(this.node(), id).delay;
}
function durationFunction(id, value) {
    return function () {
        set$1(this, id).duration = +value.apply(this, arguments);
    };
}
function durationConstant(id, value) {
    return value = +value, function () {
        set$1(this, id).duration = value;
    };
}
function transition_duration(value) {
    var id = this._id;
    return arguments.length
        ? this.each((typeof value === "function"
            ? durationFunction
            : durationConstant)(id, value))
        : get$1(this.node(), id).duration;
}
function easeConstant(id, value) {
    if (typeof value !== "function")
        throw new Error;
    return function () {
        set$1(this, id).ease = value;
    };
}
function transition_ease(value) {
    var id = this._id;
    return arguments.length
        ? this.each(easeConstant(id, value))
        : get$1(this.node(), id).ease;
}
function transition_filter(match) {
    if (typeof match !== "function")
        match = matcher(match);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
            if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                subgroup.push(node);
            }
        }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
    if (transition._id !== this._id)
        throw new Error;
    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
            if (node = group0[i] || group1[i]) {
                merge[i] = node;
            }
        }
    }
    for (; j < m0; ++j) {
        merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function (t) {
        var i = t.indexOf(".");
        if (i >= 0)
            t = t.slice(0, i);
        return !t || t === "start";
    });
}
function onFunction(id, name, listener) {
    var on0, on1, sit = start(name) ? init : set$1;
    return function () {
        var schedule = sit(this, id), on = schedule.on;
        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0)
            (on1 = (on0 = on).copy()).on(name, listener);
        schedule.on = on1;
    };
}
function transition_on(name, listener) {
    var id = this._id;
    return arguments.length < 2
        ? get$1(this.node(), id).on.on(name)
        : this.each(onFunction(id, name, listener));
}
function removeFunction(id) {
    return function () {
        var parent = this.parentNode;
        for (var i in this.__transition)
            if (+i !== id)
                return;
        if (parent)
            parent.removeChild(this);
    };
}
function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select) {
    var name = this._name, id = this._id;
    if (typeof select !== "function")
        select = selector(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
            if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                if ("__data__" in node)
                    subnode.__data__ = node.__data__;
                subgroup[i] = subnode;
                schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
            }
        }
    }
    return new Transition(subgroups, this._parents, name, id);
}
function transition_selectAll(select) {
    var name = this._name, id = this._id;
    if (typeof select !== "function")
        select = selectorAll(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
                for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
                    if (child = children[k]) {
                        schedule(child, name, id, k, children, inherit);
                    }
                }
                subgroups.push(children);
                parents.push(node);
            }
        }
    }
    return new Transition(subgroups, parents, name, id);
}
var Selection$1 = selection.prototype.constructor;
function transition_selection() {
    return new Selection$1(this._groups, this._parents);
}
function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function () {
        var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
                : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
}
function styleRemove$1(name) {
    return function () {
        this.style.removeProperty(name);
    };
}
function styleConstant$1(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function () {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
                : interpolate0 = interpolate(string00 = string0, value1);
    };
}
function styleFunction$1(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function () {
        var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
        if (value1 == null)
            string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
                : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
}
function styleMaybeRemove(id, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
    return function () {
        var schedule = set$1(this, id), on = schedule.on, listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;
        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener)
            (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule.on = on1;
    };
}
function transition_style(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
    return value == null ? this
        .styleTween(name, styleNull(name, i))
        .on("end.style." + name, styleRemove$1(name))
        : typeof value === "function" ? this
            .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
            .each(styleMaybeRemove(this._id, name))
            : this
                .styleTween(name, styleConstant$1(name, i, value), priority)
                .on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
    return function (t) {
        this.style.setProperty(name, i.call(this, t), priority);
    };
}
function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
            t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
    }
    tween._value = value;
    return tween;
}
function transition_styleTween(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
    if (value == null)
        return this.tween(key, null);
    if (typeof value !== "function")
        throw new Error;
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant$1(value) {
    return function () {
        this.textContent = value;
    };
}
function textFunction$1(value) {
    return function () {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
    };
}
function transition_text(value) {
    return this.tween("text", typeof value === "function"
        ? textFunction$1(tweenValue(this, "text", value))
        : textConstant$1(value == null ? "" : value + ""));
}
function textInterpolate(i) {
    return function (t) {
        this.textContent = i.call(this, t);
    };
}
function textTween(value) {
    var t0, i0;
    function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
            t0 = (i0 = i) && textInterpolate(i);
        return t0;
    }
    tween._value = value;
    return tween;
}
function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1)
        return (key = this.tween(key)) && key._value;
    if (value == null)
        return this.tween(key, null);
    if (typeof value !== "function")
        throw new Error;
    return this.tween(key, textTween(value));
}
function transition_transition() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
                var inherit = get$1(node, id0);
                schedule(node, name, id1, i, group, {
                    time: inherit.time + inherit.delay + inherit.duration,
                    delay: 0,
                    duration: inherit.duration,
                    ease: inherit.ease
                });
            }
        }
    }
    return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
    var on0, on1, that = this, id = that._id, size = that.size();
    return new Promise(function (resolve, reject) {
        var cancel = { value: reject }, end = { value: function () { if (--size === 0)
                resolve(); } };
        that.each(function () {
            var schedule = set$1(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0) {
                on1 = (on0 = on).copy();
                on1._.cancel.push(cancel);
                on1._.interrupt.push(cancel);
                on1._.end.push(end);
            }
            schedule.on = on1;
        });
    });
}
var id = 0;
function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
}
function transition(name) {
    return selection().transition(name);
}
function newId() {
    return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    end: transition_end
};
function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
};
function inherit(node, id) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
            return defaultTiming.time = now(), defaultTiming;
        }
    }
    return timing;
}
function selection_transition(name) {
    var id, timing;
    if (name instanceof Transition) {
        id = name._id, name = name._name;
    }
    else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
            if (node = group[i]) {
                schedule(node, name, id, i, group, timing || inherit(node, id));
            }
        }
    }
    return new Transition(groups, this._parents, name, id);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
function constant$4(x) {
    return function () {
        return x;
    };
}
function ZoomEvent(target, type, transform) {
    this.target = target;
    this.type = type;
    this.transform = transform;
}
function Transform(k, x, y) {
    this.k = k;
    this.x = x;
    this.y = y;
}
Transform.prototype = {
    constructor: Transform,
    scale: function (k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function (x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
    },
    apply: function (point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function (x) {
        return x * this.k + this.x;
    },
    applyY: function (y) {
        return y * this.k + this.y;
    },
    invert: function (location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function (x) {
        return (x - this.x) / this.k;
    },
    invertY: function (y) {
        return (y - this.y) / this.k;
    },
    rescaleX: function (x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
    },
    rescaleY: function (y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
    },
    toString: function () {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
};
var identity$3 = new Transform(1, 0, 0);
function nopropagation$1() {
    event.stopImmediatePropagation();
}
function noevent$1() {
    event.preventDefault();
    event.stopImmediatePropagation();
}
// Ignore right-click, since that should open the context menu.
function defaultFilter$1() {
    return !event.ctrlKey && !event.button;
}
function defaultExtent() {
    var e = this;
    if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
            e = e.viewBox.baseVal;
            return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
    }
    return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
    return this.__zoom || identity$3;
}
function defaultWheelDelta() {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002);
}
function defaultTouchable$1() {
    return navigator.maxTouchPoints || ("ontouchstart" in this);
}
function defaultConstrain(transform, extent, translateExtent) {
    var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
    return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function zoom() {
    var filter = defaultFilter$1, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable$1, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
    function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled)
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
            .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function (collection, transform, point) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
            schedule(collection, transform, point);
        }
        else {
            selection.interrupt().each(function () {
                gesture(this, arguments)
                    .start()
                    .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
                    .end();
            });
        }
    };
    zoom.scaleBy = function (selection, k, p) {
        zoom.scaleTo(selection, function () {
            var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return k0 * k1;
        }, p);
    };
    zoom.scaleTo = function (selection, k, p) {
        zoom.transform(selection, function () {
            var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p);
    };
    zoom.translateBy = function (selection, x, y) {
        zoom.transform(selection, function () {
            return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
        });
    };
    zoom.translateTo = function (selection, x, y, p) {
        zoom.transform(selection, function () {
            var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
            return constrain(identity$3.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
        }, p);
    };
    function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
    }
    function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
    }
    function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
    }
    function schedule(transition, transform, point) {
        transition
            .on("start.zoom", function () { gesture(this, arguments).start(); })
            .on("interrupt.zoom end.zoom", function () { gesture(this, arguments).end(); })
            .tween("zoom", function () {
            var that = this, args = arguments, g = gesture(that, args), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
            return function (t) {
                if (t === 1)
                    t = b; // Avoid rounding error on end.
                else {
                    var l = i(t), k = w / l[2];
                    t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
                }
                g.zoom(null, t);
            };
        });
    }
    function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
    }
    function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.extent = extent.apply(that, args);
        this.taps = 0;
    }
    Gesture.prototype = {
        start: function () {
            if (++this.active === 1) {
                this.that.__zooming = this;
                this.emit("start");
            }
            return this;
        },
        zoom: function (key, transform) {
            if (this.mouse && key !== "mouse")
                this.mouse[1] = transform.invert(this.mouse[0]);
            if (this.touch0 && key !== "touch")
                this.touch0[1] = transform.invert(this.touch0[0]);
            if (this.touch1 && key !== "touch")
                this.touch1[1] = transform.invert(this.touch1[0]);
            this.that.__zoom = transform;
            this.emit("zoom");
            return this;
        },
        end: function () {
            if (--this.active === 0) {
                delete this.that.__zooming;
                this.emit("end");
            }
            return this;
        },
        emit: function (type) {
            customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
        }
    };
    function wheeled() {
        if (!filter.apply(this, arguments))
            return;
        var g = gesture(this, arguments), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = mouse(this);
        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
            if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
                g.mouse[1] = t.invert(g.mouse[0] = p);
            }
            clearTimeout(g.wheel);
        }
        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k)
            return;
        // Otherwise, capture the mouse point and location at the start.
        else {
            g.mouse = [p, t.invert(p)];
            interrupt(this);
            g.start();
        }
        noevent$1();
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
        function wheelidled() {
            g.wheel = null;
            g.end();
        }
    }
    function mousedowned() {
        if (touchending || !filter.apply(this, arguments))
            return;
        var g = gesture(this, arguments, true), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = mouse(this), x0 = event.clientX, y0 = event.clientY;
        dragDisable(event.view);
        nopropagation$1();
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();
        function mousemoved() {
            noevent$1();
            if (!g.moved) {
                var dx = event.clientX - x0, dy = event.clientY - y0;
                g.moved = dx * dx + dy * dy > clickDistance2;
            }
            g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
        }
        function mouseupped() {
            v.on("mousemove.zoom mouseup.zoom", null);
            yesdrag(event.view, g.moved);
            noevent$1();
            g.end();
        }
    }
    function dblclicked() {
        if (!filter.apply(this, arguments))
            return;
        var t0 = this.__zoom, p0 = mouse(this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
        noevent$1();
        if (duration > 0)
            select(this).transition().duration(duration).call(schedule, t1, p0);
        else
            select(this).call(zoom.transform, t1);
    }
    function touchstarted() {
        if (!filter.apply(this, arguments))
            return;
        var touches = event.touches, n = touches.length, g = gesture(this, arguments, event.changedTouches.length === n), started, i, t, p;
        nopropagation$1();
        for (i = 0; i < n; ++i) {
            t = touches[i], p = touch(this, touches, t.identifier);
            p = [p, this.__zoom.invert(p), t.identifier];
            if (!g.touch0)
                g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
            else if (!g.touch1 && g.touch0[2] !== p[2])
                g.touch1 = p, g.taps = 0;
        }
        if (touchstarting)
            touchstarting = clearTimeout(touchstarting);
        if (started) {
            if (g.taps < 2)
                touchstarting = setTimeout(function () { touchstarting = null; }, touchDelay);
            interrupt(this);
            g.start();
        }
    }
    function touchmoved() {
        if (!this.__zooming)
            return;
        var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t, p, l;
        noevent$1();
        if (touchstarting)
            touchstarting = clearTimeout(touchstarting);
        g.taps = 0;
        for (i = 0; i < n; ++i) {
            t = touches[i], p = touch(this, touches, t.identifier);
            if (g.touch0 && g.touch0[2] === t.identifier)
                g.touch0[0] = p;
            else if (g.touch1 && g.touch1[2] === t.identifier)
                g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
            var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
            t = scale(t, Math.sqrt(dp / dl));
            p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
            l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0)
            p = g.touch0[0], l = g.touch0[1];
        else
            return;
        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
    }
    function touchended() {
        if (!this.__zooming)
            return;
        var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t;
        nopropagation$1();
        if (touchending)
            clearTimeout(touchending);
        touchending = setTimeout(function () { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
            t = touches[i];
            if (g.touch0 && g.touch0[2] === t.identifier)
                delete g.touch0;
            else if (g.touch1 && g.touch1[2] === t.identifier)
                delete g.touch1;
        }
        if (g.touch1 && !g.touch0)
            g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0)
            g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
            g.end();
            // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
            if (g.taps === 2) {
                var p = select(this).on("dblclick.zoom");
                if (p)
                    p.apply(this, arguments);
            }
        }
    }
    zoom.wheelDelta = function (_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$4(+_), zoom) : wheelDelta;
    };
    zoom.filter = function (_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), zoom) : filter;
    };
    zoom.touchable = function (_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), zoom) : touchable;
    };
    zoom.extent = function (_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
    };
    zoom.scaleExtent = function (_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function (_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function (_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
    };
    zoom.duration = function (_) {
        return arguments.length ? (duration = +_, zoom) : duration;
    };
    zoom.interpolate = function (_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
    };
    zoom.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function (_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
    };
    return zoom;
}
var transformScales = function (transform, movementOptions, _a) {
    var xScale = _a.xScale, yScale = _a.yScale;
    return ({
        xScale: movementOptions.enableXScroll ? transform.rescaleX(xScale) : xScale,
        yScale: movementOptions.enableYScroll ? transform.rescaleY(yScale) : yScale,
    });
};
var getTransformFromDates = function (_a) {
    var prevXScale = _a.prevXScale, prevDates = _a.prevDates, currDates = _a.currDates;
    // Determine k, our scaling factor
    var prevTimeSpan = prevDates.end.getTime() - prevDates.start.getTime();
    var currTimeSpan = currDates.end.getTime() - currDates.start.getTime();
    var k = prevTimeSpan / currTimeSpan;
    // Determine t, our translation x-offset
    // since transform(xCurrStartDate) = 0 = xCurrStartDate * k + t => t = -1 * xCurrStartDate * k
    var xCurrStartDate = prevXScale(currDates.start);
    var t = -1 * xCurrStartDate * k;
    return identity$3.translate(t, 0).scale(k); // NOTE: Only supporting x brushing for now.
};
/**
 * Get Transformed Date Range
 * Apply a given transformation to the given date range
 *
 * NOTE: The reason to pass in an `xScale` as opposed to the start and end date directly
 * is that a transform is in terms of the pixel space,
 * rather than the input space (the domain in which the data is in, which is time plus some number value).
 */
var getTransformedDateRange = function (_a) {
    var xScale = _a.xScale, transform = _a.transform;
    // Convert our date range to a domain since transformations have a built in function to transform scales.
    var transformedScale = transform.rescaleX(xScale);
    var _b = transformedScale.domain(), startTime = _b[0], endTime = _b[1];
    return {
        startDate: new Date(startTime),
        endDate: new Date(endTime),
    };
};
/**
 * Filter which gestures fire which events which will get
 * interpreted as zoom/panning events within the chart.
 */
var filterGestures = function () {
    // Disables multi touch drag & mouse wheel sense these interfere with scrolling gestures,
    // Since the charts are used in a context where horizontal and vertical scroll are used.
    if (event.type === 'wheel') {
        return false;
    }
    if (event.type === 'mousedown') {
        // don't allow panning without pressing [shift] key
        return event.shiftKey;
    }
    // Default filter applied to `d3-zoom`
    return !event.ctrlKey && !event.button;
};
/**
 * Zoom
 *
 * A facade over `d3-zoom` which allows us to utilize the gesture support and concept of transforms, but
 * translated into terms of date range which are more useful for our usecase within sc-webgl-base-chart since
 * we communicate with the dashboards in terms of start and end dates, rather than view port pixel specific transforms.
 */
var Zoom = /** @class */ (function () {
    function Zoom(_a, movement, getContainer) {
        var xScale = _a.xScale, yScale = _a.yScale;
        this.zoomBehavior = zoom()
            .scaleExtent([movement.zoomMin, movement.zoomMax])
            .filter(filterGestures);
        this.xScale = xScale.copy();
        this.yScale = yScale.copy();
        this.movement = movement;
        this.getContainer = getContainer;
    }
    /**
     * Initializes the zoom behavior to a DOM element.
     * This must be called after the DOM is already instantiated.
     *
     * This is separated from the constructor since it's possible to have a scenario where
     * the component which the zoom behavior is bound to also is passed down the `Zoom` object,
     * resulting in a scenario where you can't create the `Zoom` class until the component is mounted but
     * you must pass in the `Zoom` object to properly mount the component.
     */
    Zoom.prototype.init = function () {
        var container = this.getContainer();
        if (container == null) {
            throw new Error('Must not init Zoom before the container is available!');
        }
        select(container).call(this.zoomBehavior);
    };
    Zoom.prototype.transform = function (transitionContainer, transform) {
        this.zoomBehavior.transform(transitionContainer, transform);
    };
    /**
     * On Zoom Event
     *
     * Calls the specified listener passing in the date range which is being requested via some gesture (scroll, pan, etc)
     */
    Zoom.prototype.on = function (type, listener) {
        var _this = this;
        this.zoomBehavior.on(type, function () {
            var _a = getTransformedDateRange({
                xScale: _this.xScale,
                transform: event.transform,
            }), startDate = _a.startDate, endDate = _a.endDate;
            listener(startDate, endDate);
        });
    };
    /**
     * Update View Port
     *
     * Returns the x and y scale with the date range transformed to the specified view port
     * Maintains the internal state of the zoom behavior.
     * TODO: Support gestures on the y axis
     */
    Zoom.prototype.updateViewPort = function (_a) {
        var start = _a.start, end = _a.end, yMin = _a.yMin, yMax = _a.yMax;
        var _b = this.xScale.domain(), prevStart = _b[0], prevEnd = _b[1];
        var transform = getTransformFromDates({
            prevXScale: this.xScale,
            prevDates: { start: prevStart, end: prevEnd },
            currDates: { start: start, end: end },
        });
        this.setTransform(transform);
        return transformScales(transform, this.movement, {
            xScale: this.xScale,
            yScale: this.yScale.domain([yMin, yMax]),
        });
    };
    /**
     * Update View Port
     *
     * Updates the view port of the scales used as the frame of reference.
     * Also transforms the internal transform state of zoom to map it into the new view port.
     */
    Zoom.prototype.updateSize = function (_a) {
        var xMin = _a.xMin, xMax = _a.xMax, yMin = _a.yMin, yMax = _a.yMax;
        // Apply the new view port to the transform (transform the transform!)
        var _b = this.getTransform(), x = _b.x, y = _b.y, k = _b.k;
        var _c = this.xScale.range(), prevXMin = _c[0], prevXMax = _c[1];
        var xRatio = (xMax - xMin) / (prevXMax - prevXMin);
        // Update Viewports
        this.xScale.range([xMin, xMax]);
        this.yScale.range([yMin, yMax]);
        this.setTransform(identity$3.translate(x * xRatio, y).scale(k));
        return transformScales(this.getTransform(), this.movement, {
            xScale: this.xScale,
            yScale: this.yScale,
        });
    };
    /**
     * Get Transform
     *
     * Returns the transform which is currently applied to our container.
     */
    Zoom.prototype.getTransform = function () {
        var container = this.getContainer();
        if (container == null) {
            throw new Error('Container must not be null to set a internal zoom transform');
        }
        /* eslint-disable-next-line no-underscore-dangle */
        return container.__zoom;
    };
    /**
     * Set Internal Zoom Transform
     *
     * Updates the zoom containers state. This is necessary because we wish to apply
     * transforms which did not stem from the zoom behavior itself.
     *
     * IMPORTANT: Whenever a transformation is applied to the DOM from a transform
     * emitted by something other than the associated zoom container, one must
     * set the internal zoom transform manually.
     *
     * You can see from the source code, https://github.com/d3/d3-zoom/blob/master/src/transform.js
     * that `__zoom` is the property which stores the internal state of which transform is currently applied.
     *
     * NOTE: This does not apply the transform. It simply tells d3-zoom what transform was last set.
     */
    Zoom.prototype.setTransform = function (transform) {
        var container = this.getContainer();
        if (container == null) {
            throw new Error('Container must not be null to set a internal zoom transform');
        }
        /* eslint-disable-next-line no-underscore-dangle */
        container.__zoom = transform;
    };
    return Zoom;
}());
// DERIVATION NOTES:
// transformations are defined as following:
// t(x) := x * k + t
// let `xMin` be defined as the pixel position of `xSelectedPixelMin` in the frame of reference of
// `xScaleOriginal`.
// Then by definition we want to find `k` and `t` such that
// t(xMin) = 0
// thus,
// xMin * k + t = 0
// therefore
// t = -1 * k * xMin
//
// Additionally, our scaling factor should map our original range to the new range,
// thus `k` is simply the ratio of the width of the ranges.
var createBrushTransform = function (_a) {
    var xScale = _a.xScale, xSelectedPixelMax = _a.xSelectedPixelMax, xSelectedPixelMin = _a.xSelectedPixelMin, xScaleOriginal = _a.xScaleOriginal, movement = _a.movement;
    // Determine k, our scaling factor
    var timeSpan = xScale.invert(xSelectedPixelMax).getTime() - xScale.invert(xSelectedPixelMin).getTime();
    var prevTimeSpan = xScaleOriginal.domain()[1].getTime() - xScaleOriginal.domain()[0].getTime();
    var k = Math.max(Math.min(prevTimeSpan / timeSpan, movement.zoomMax), movement.zoomMin);
    // Determine t, our translation x-offset
    // NOTE: converting to an absolute date and then map that date to the frame of reference of the original scale.
    // See derivation notes above for more detail.
    var xMin = xScaleOriginal(xScale.invert(xSelectedPixelMin));
    var t = -1 * k * xMin;
    return identity$3.translate(t, 0).scale(k); // NOTE: Only supporting x brushing for now.
};
var scGestureHandlerCss = "sc-gesture-handler svg{position:absolute;width:100%;height:100%}sc-gesture-handler line{stroke:var(--selection-color);opacity:0.3;stroke-width:1.5px}sc-gesture-handler .overlay{fill:none;pointer-events:all;cursor:crosshair}sc-gesture-handler .brush-box{fill:var(--selection-color);opacity:0.2}";
var TRANSITION_DURATION = 600;
// Want to prevent double clicking accident firing a teeny tiny brush gesture
var MIN_BRUSH_WIDTH = 6;
var MOVEMENT_CONFIG = {
    enableXScroll: true,
    enableYScroll: false,
    zoomMax: Infinity,
    zoomMin: 0.00001,
};
var ScGestureHandler = /** @class */ (function () {
    function ScGestureHandler(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.zoomContainer = undefined;
        /**
         * Initiate the start of a brush gesture by clicking
         */
        this.beginBrush = function (_a) {
            var offsetX = _a.offsetX, shiftKey = _a.shiftKey;
            if (!shiftKey) {
                _this.start = offsetX;
                _this.end = offsetX;
            }
        };
        /**
         * Continue a brushing gesture by holding the mouse button and dragging
         */
        this.moveBrush = function (_a) {
            var offsetX = _a.offsetX, buttons = _a.buttons, shiftKey = _a.shiftKey;
            var isButtonPressed = buttons > 0;
            if (isButtonPressed && _this.start != null && !shiftKey) {
                _this.end = offsetX;
            }
            else {
                _this.start = undefined;
                _this.end = undefined;
            }
        };
        /**
         * Conclude a brushing gesture by letting the mouse button go.
         */
        this.finishBrush = function (_a) {
            var shiftKey = _a.shiftKey;
            // check if were actually finishing a brush motion.
            // this event will also be fired when someone clicks and drags
            // into the brush container
            if (_this.start != null && _this.end != null && !shiftKey) {
                var startPx = Math.min(_this.start, _this.end);
                var endPx = Math.max(_this.start, _this.end);
                if (endPx - startPx > MIN_BRUSH_WIDTH) {
                    _this.initiateTransform(startPx, endPx);
                }
            }
            _this.start = undefined;
            _this.end = undefined;
        };
        this.cancelBrush = function () {
            _this.start = undefined;
            _this.end = undefined;
        };
        this.initiateTransform = function (startPx, endPx) {
            var xScale = time()
                .domain([_this.viewport.start.getTime(), _this.viewport.end.getTime()])
                .range([0, _this.size.width]);
            var xScaleOriginal = time()
                .domain([_this.initialViewPort.start.getTime(), _this.initialViewPort.end.getTime()])
                .range([0, _this.size.width]);
            var brushTransform = createBrushTransform({
                xSelectedPixelMin: startPx,
                xSelectedPixelMax: endPx,
                xScaleOriginal: xScaleOriginal,
                xScale: xScale,
                movement: MOVEMENT_CONFIG,
            });
            var transitionContainer = select(_this.getZoomContainer())
                .transition()
                .duration(TRANSITION_DURATION);
            _this.zoom.transform(transitionContainer, brushTransform);
        };
        this.getZoomContainer = function () {
            if (!_this.zoomContainer) {
                // Prevent the continual dom querying.
                _this.zoomContainer = _this.el.querySelector('.zoom-container');
            }
            return _this.zoomContainer;
        };
    }
    ScGestureHandler.prototype.componentDidLoad = function () {
        this.initialViewPort = this.viewport;
        this.setupZoom();
        this.el.addEventListener('mousedown', this.beginBrush, { capture: true });
        this.el.addEventListener('mousemove', this.moveBrush);
        this.el.addEventListener('mouseup', this.finishBrush);
        this.el.addEventListener('mouseleave', this.cancelBrush);
    };
    ScGestureHandler.prototype.disconnectedCallback = function () {
        this.el.removeEventListener('mousedown', this.beginBrush);
        this.el.removeEventListener('mousemove', this.moveBrush);
        this.el.removeEventListener('mouseup', this.finishBrush);
        this.el.removeEventListener('mouseleave', this.cancelBrush);
    };
    ScGestureHandler.prototype.onViewPortChange = function (newViewPort) {
        this.zoom.updateViewPort(newViewPort);
    };
    ScGestureHandler.prototype.onSizeChange = function () {
        var _a = this.size, chartWidth = _a.width, chartHeight = _a.height;
        this.zoom.updateSize({
            xMin: 0,
            xMax: chartWidth,
            yMax: 0,
            yMin: chartHeight,
        });
    };
    ScGestureHandler.prototype.scales = function () {
        var _a = this.viewport, yMin = _a.yMin, yMax = _a.yMax, start = _a.start, end = _a.end;
        var _b = this.size, width = _b.width, height = _b.height;
        var xScale = time()
            .domain([start.getTime(), end.getTime()])
            .range([0, width]);
        var yScale = linear$1()
            .domain([yMin, yMax])
            .range([height, 0]);
        return {
            xScale: xScale,
            yScale: yScale,
        };
    };
    /**
     * Setup Zoom
     * Establishes how the chart pans and scales due to gestures and outside date range changes.
     */
    ScGestureHandler.prototype.setupZoom = function () {
        var _this = this;
        var _a = this.scales(), xScale = _a.xScale, yScale = _a.yScale;
        this.zoom = new Zoom({ xScale: xScale, yScale: yScale }, MOVEMENT_CONFIG, this.getZoomContainer);
        this.zoom.on('zoom.base-chart', function (start, end) {
            _this.onDateRangeChange({ start: start, end: end });
        });
        this.zoom.init();
    };
    ScGestureHandler.prototype.render = function () {
        var _a = this.size, width = _a.width, height = _a.height;
        return (h("svg", null, this.start != null && this.end != null && h("line", { x1: this.start, y1: 0, x2: this.start, y2: height }), this.start != null && this.end != null && (h("rect", { class: "brush-box", x: Math.min(this.start, this.end), height: height, width: Math.abs(this.end - this.start), y: 0 })), this.start != null && this.end != null && h("line", { x1: this.end, y1: 0, x2: this.end, y2: height }), h("rect", { class: "overlay zoom-container", width: width, height: height })));
    };
    Object.defineProperty(ScGestureHandler.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScGestureHandler, "watchers", {
        get: function () {
            return {
                "viewport": ["onViewPortChange"],
                "size": ["onSizeChange"]
            };
        },
        enumerable: false,
        configurable: true
    });
    return ScGestureHandler;
}());
ScGestureHandler.style = scGestureHandlerCss;
/**
 * Determines the ideal least-squares line of best fit over a given data set.
 * @param data The data stream over which to compute the linear regression.
 */
var linearRegression = function (data) {
    var dataPoints = data.data;
    var len = dataPoints.length;
    if (len === 0) {
        return null;
    }
    var startDate = dataPoints[0].x;
    var sumX = 0;
    var sumY = 0;
    var sumXX = 0;
    var sumXY = 0;
    for (var i = 0; i < len; i += 1) {
        var _a = dataPoints[i], x = _a.x, y = _a.y;
        var time_1 = x - startDate;
        sumX += time_1;
        sumY += y;
        sumXX += time_1 * time_1;
        sumXY += time_1 * y;
    }
    var run = len * sumXX - sumX * sumX;
    var rise = len * sumXY - sumX * sumY;
    var gradient = run === 0 ? 0 : rise / run;
    var intercept = sumY / len - (gradient * sumX) / len;
    return {
        type: TREND_TYPE.LINEAR,
        dataStreamId: data.id,
        equation: { gradient: gradient, intercept: intercept },
        startDate: new Date(startDate),
    };
};
/**
 * Reads in a data stream and a trend type, then computes the trend result.
 * @param data The data stream over which to compute the trend.
 * @param trendType The type of trend to compute.
 */
var computeTrendResult = function (dataStream, trendType) {
    switch (trendType) {
        case TREND_TYPE.LINEAR:
            return linearRegression(dataStream);
        default:
            /* eslint-disable-next-line no-console */
            console.error("Unable to compute trend result for trend type '" + trendType + "'.");
            return null;
    }
};
/**
 * Computes trend results for all requested trends using the data in the provided viewport (including boundary points).
 */
var getAllTrendResults = function (viewport, dataStreams, trends) {
    var trendResults = [];
    dataStreams.forEach(function (stream) {
        var id = stream.id;
        var dataPoints = getDataPoints(stream, stream.resolution);
        // only compute a trend line if there are at least two visible and/or boundary data points, the reason being that
        // a trend line based on a single point of data has no informational value and may actually be misleading
        var dataInViewport = getVisibleData(dataPoints, viewport);
        if (dataInViewport.length >= 2) {
            trends
                .filter(function (_a) {
                var dataStreamId = _a.dataStreamId;
                return id === dataStreamId;
            })
                .forEach(function (_a) {
                var type = _a.type, color = _a.color;
                var trendResult = computeTrendResult(Object.assign(Object.assign({}, stream), { data: dataInViewport }), type);
                if (trendResult) {
                    trendResults.push(Object.assign(Object.assign({}, trendResult), { color: color }));
                }
            });
        }
    });
    return trendResults;
};
/**
 * Calculates the value of the given trend result at the requested date.
 */
var getTrendValue = function (trendResult, timestamp) {
    switch (trendResult.type) {
        case TREND_TYPE.LINEAR:
            return ((timestamp - trendResult.startDate.getTime()) * trendResult.equation.gradient + trendResult.equation.intercept);
        default:
            throw new Error("Cannot compute trend value for trend of type '" + trendResult.type + "' on data stream " + trendResult.dataStreamId + ".");
    }
};
var TREND_LINE_STROKE_WIDTH = 2;
var TREND_LINE_DASH_ARRAY = '4, 7';
var getTrendLabel = function (dataStreamName, trendType) {
    var trendTypeLabel;
    switch (trendType) {
        case TREND_TYPE.LINEAR:
            trendTypeLabel = 'linear';
            break;
        default:
            /* eslint-disable-next-line no-console */
            console.warn("No label associated with trend type " + trendType + ".");
            trendTypeLabel = 'trend';
    }
    return dataStreamName + " (" + trendTypeLabel + ")";
};
var scLegendCss = "sc-legend .legend-container{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;font-size:var(--font-size-1);overflow-y:scroll;overflow-x:hidden;-ms-overflow-style:none;scrollbar-width:none}sc-legend .legend-container::-webkit-scrollbar{display:none}";
var noop$1 = function () { };
var ScLegend = /** @class */ (function () {
    function ScLegend(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.isEditing = false;
        this.trendResults = [];
        this.visualizedDataStreams = function () {
            var streams = _this.dataStreams.filter(isSupportedDataType(_this.supportString));
            if (_this.visualizesAlarms) {
                // Visualize all data streams with a valid data type
                return streams;
            }
            // Visualize only property-streams (non-alarms) with a valid data type
            return streams.filter(function (_a) {
                var streamType = _a.streamType;
                return streamType !== StreamType.ALARM;
            });
        };
        /**
         * Returns the given color of a breached threshold, if there is one.
         */
        this.breachedThresholdColor = function (point, dataStream) {
            var threshold = breachedThreshold({
                value: point && point.y,
                date: _this.viewport.end,
                dataStreams: _this.dataStreams,
                dataStream: dataStream,
                thresholds: _this.thresholds,
            });
            return threshold ? { color: threshold.color, icon: threshold.icon } : undefined;
        };
    }
    ScLegend.prototype.render = function () {
        var _this = this;
        var points = activePoints({
            viewport: this.viewport,
            dataStreams: this.dataStreams,
            selectedDate: this.viewport.end,
            allowMultipleDates: true,
            dataAlignment: DATA_ALIGNMENT.EITHER,
        });
        var lastDate = points.length === 0 || points[0].point == null ? this.viewport.end.getTime() : points[0].point.x;
        return (h("div", { class: "legend-container", style: { flexDirection: this.config.position === LEGEND_POSITION.RIGHT ? 'column' : 'unset' } }, this.visualizedDataStreams().map(function (dataStream) {
            var dataPoint = points.find(function (p) { return p.streamId === dataStream.id; });
            var point = dataPoint ? dataPoint.point : undefined;
            var _a = _this.breachedThresholdColor(point, dataStream) || {}, _b = _a.color, valueColor = _b === void 0 ? undefined : _b, _c = _a.icon, icon = _c === void 0 ? undefined : _c;
            return __spreadArrays([
                h("sc-legend-row", { streamId: dataStream.id, label: dataStream.name, detailedLabel: dataStream.detailedName, color: dataStream.color || 'black', valueColor: valueColor, point: point, pointType: dataPoint && "data" /* DATA */, unit: dataStream.unit, updateDataStreamName: _this.updateDataStreamName, isEditing: _this.isEditing, isLoading: _this.isLoading, showDataStreamColor: _this.showDataStreamColor, icon: icon })
            ], _this.trendResults.reduce(function (rows, trendResult) {
                if (trendResult.dataStreamId === dataStream.id) {
                    rows.push(h("sc-legend-row", { streamId: dataStream.id, label: getTrendLabel(dataStream.name, trendResult.type), detailedLabel: dataStream.detailedName && getTrendLabel(dataStream.detailedName, trendResult.type), color: trendResult.color || dataStream.color || 'black', valueColor: valueColor, point: {
                            x: lastDate,
                            y: getTrendValue(trendResult, lastDate),
                        }, pointType: "trend" /* TREND */, unit: dataStream.unit, updateDataStreamName: noop$1, isEditing: false, isLoading: _this.isLoading, showDataStreamColor: _this.showDataStreamColor }));
                }
                return rows;
            }, []));
        })));
    };
    return ScLegend;
}());
ScLegend.style = scLegendCss;
var DEFAULT_LEGEND_TEXT_COLOR = '#000';
var scLegendRowCss = "sc-legend-row{--color-container-width:18px;overflow:hidden;display:inline-block;margin-right:var(--margin-small);color:var(--secondary-font-color);padding-right:var(--margin-small)}sc-legend-row .legend-row-container{display:-ms-flexbox;display:flex;margin-left:8px}sc-legend-row .legend-value{position:relative;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}sc-legend-row .color-container{display:-ms-flexbox;display:flex;-ms-flex-direction:column-reverse;flex-direction:column-reverse;width:var(--color-container-width);height:20px;padding-top:11px}sc-data-stream-info .spinner-container{position:relative;top:5px}sc-legend-row .bar{width:var(--color-container-width)}sc-legend-row .info{padding-left:var(--margin-small);display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column}sc-legend-row .info h4{line-height:0.2em;font-size:14px}sc-legend-row .sc-expandable-input{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}";
// Styling to control the height of the gap between the stream-name and the unit
var EDIT_MODE_STYLE = {
    top: '-2px',
};
var VIEW_MODE_STYLE = {
    top: '-11px',
};
var ScLegendRow = /** @class */ (function () {
    function ScLegendRow(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.valueColor = DEFAULT_LEGEND_TEXT_COLOR;
        this.updateName = function (name) {
            _this.updateDataStreamName({
                streamId: _this.streamId,
                name: name,
            });
        };
    }
    ScLegendRow.prototype.render = function () {
        var isTrendPoint = this.pointType && this.pointType === "trend" /* TREND */;
        return (h(Host, null, h("div", { class: "legend-row-container awsui" }, this.showDataStreamColor && (h("div", { class: "color-container" }, this.isLoading ? (h("div", { class: "spinner-container" }, h("sc-loading-spinner", { dark: true, size: 12 }))) : (h("svg", { class: "bar", "data-testid": "legend-icon-" + this.pointType }, h("path", { stroke: this.color, "stroke-dasharray": isTrendPoint ? TREND_ICON_DASH_ARRAY : '', "stroke-linecap": STREAM_ICON_STROKE_LINECAP, "stroke-width": STREAM_ICON_STROKE_WIDTH, d: STREAM_ICON_PATH_COMMAND }))))), h("div", { class: "info" }, h("sc-data-stream-name", { onNameChange: this.updateName, isEditing: this.isEditing, label: this.label, detailedLabel: this.detailedLabel, pointType: this.pointType, date: this.point && new Date(this.point.x) }), h("div", { class: "legend-value", style: this.isEditing ? EDIT_MODE_STYLE : VIEW_MODE_STYLE }, this.icon && h("sc-chart-icon", { name: this.icon }), h("h4", { class: "awsui-util-d-i", "data-testid": "current-value", style: { color: this.valueColor } }, h(Value, { value: this.point ? this.point.y : undefined })), this.unit && h("small", null, "\u00A0", this.unit))))));
    };
    return ScLegendRow;
}());
ScLegendRow.style = scLegendRowCss;
var scLoadingSpinnerCss = "@-webkit-keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@-webkit-keyframes spin{from{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{from{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}svg{-webkit-animation:spin 900ms linear infinite, fadeIn 1s linear;animation:spin 900ms linear infinite, fadeIn 1s linear}path#c{fill:var(--loading-spinner-color)}.dark path#c{fill:var(--loading-spinner-color-dark)}";
var ScLoadingSpinner = /** @class */ (function () {
    function ScLoadingSpinner(hostRef) {
        registerInstance(this, hostRef);
    }
    ScLoadingSpinner.prototype.render = function () {
        var _a = this, size = _a.size, _b = _a.dark, dark = _b === void 0 ? false : _b;
        return (h("svg", { class: { dark: dark }, style: size != null ? { width: size + "px", height: size + "px" } : {}, "data-testid": "loading", viewBox: "0 0 200 200" }, h("defs", null, h("clipPath", { id: "a" }, h("path", { d: "M200 100a100 100 0 11-2.19-20.79l-9.78 2.08A90 90 0 10190 100z" })), h("filter", { id: "b", x: "0", y: "0" }, h("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "3" })), h("path", { id: "c", d: "M250 100a150 150 0 01-3.28 31.19L100 100z" })), h("g", { "clip-path": "url(#a)" }, h("g", { filter: "url(#b)", transform: "rotate(-6 100 100)" }, h("use", { xlinkHref: "#c", "fill-opacity": "0" }), h("use", { xlinkHref: "#c", "fill-opacity": ".03", transform: "rotate(12 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".07", transform: "rotate(24 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".1", transform: "rotate(36 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".14", transform: "rotate(48 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".17", transform: "rotate(60 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".2", transform: "rotate(72 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".24", transform: "rotate(84 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".28", transform: "rotate(96 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".31", transform: "rotate(108 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".34", transform: "rotate(120 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".38", transform: "rotate(132 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".41", transform: "rotate(144 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".45", transform: "rotate(156 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".48", transform: "rotate(168 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".52", transform: "rotate(180 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".55", transform: "rotate(192 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".59", transform: "rotate(204 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".62", transform: "rotate(216 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".66", transform: "rotate(228 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".69", transform: "rotate(240 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".7", transform: "rotate(252 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".72", transform: "rotate(264 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".76", transform: "rotate(276 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".79", transform: "rotate(288 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".83", transform: "rotate(300 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".86", transform: "rotate(312 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".93", transform: "rotate(324 100 100)" }), h("use", { xlinkHref: "#c", "fill-opacity": ".97", transform: "rotate(336 100 100)" }), h("use", { xlinkHref: "#c", transform: "rotate(348 100 100)" })))));
    };
    return ScLoadingSpinner;
}());
ScLoadingSpinner.style = scLoadingSpinnerCss;
var lodash_isequal = createCommonjsModule(function (module, exports) {
    /**
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright JS Foundation and other contributors <https://js.foundation/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                            typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                typedArrayTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function () {
        try {
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
        }
        catch (e) { }
    }());
    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }
    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
        return cache.has(key);
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
        return object == null ? undefined : object[key];
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
        return function (arg) {
            return func(transform(arg));
        };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }
    /** Used for built-in method references. */
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];
    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
    }());
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
        funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
        return this;
    }
    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        }
        else {
            splice.call(data, index, 1);
        }
        --this.size;
        return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            ++this.size;
            data.push([key, value]);
        }
        else {
            data[index][1] = value;
        }
        return this;
    }
    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
        };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
    }
    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache;
        while (++index < length) {
            this.add(values[index]);
        }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
        return this.__data__.has(value);
    }
    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
        var data = this.__data__, result = data['delete'](key);
        this.size = data.size;
        return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
        return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
        return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }
    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                // Safari 9 has enumerable `arguments.length` in strict mode.
                key == 'length' ||
                    // Node.js 0.10 has enumerable non-index properties on buffers.
                    (isBuff && (key == 'offset' || key == 'parent')) ||
                    // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                    // Skip index properties.
                    isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
            return true;
        }
        if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
                return false;
            }
            objIsArr = true;
            objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
                ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack);
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
        }
        if (!isSameTag) {
            return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
        return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
        if (!isPrototype(object)) {
            return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
            }
        }
        return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
            return stacked == other;
        }
        var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
        stack.set(array, other);
        stack.set(other, array);
        // Ignore non-index properties.
        while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
                var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
                if (compared) {
                    continue;
                }
                result = false;
                break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                    }
                })) {
                    result = false;
                    break;
                }
            }
            else if (!(arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
            }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
            case dataViewTag:
                if ((object.byteLength != other.byteLength) ||
                    (object.byteOffset != other.byteOffset)) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;
            case arrayBufferTag:
                if ((object.byteLength != other.byteLength) ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                }
                return true;
            case boolTag:
            case dateTag:
            case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);
            case errorTag:
                return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == (other + '');
            case mapTag:
                var convert = mapToArray;
            case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                    return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;
            case symbolTag:
                if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
        }
        return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
            return false;
        }
        var index = objLength;
        while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
            }
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
            return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
                var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined
                ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                : compared)) {
                result = false;
                break;
            }
            skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
            }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
            value[symToStringTag] = undefined;
            var unmasked = true;
        }
        catch (e) { }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag] = tag;
            }
            else {
                delete value[symToStringTag];
            }
        }
        return result;
    }
    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
            return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable.call(object, symbol);
        });
    };
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;
    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
        getTag = function (value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString: return dataViewTag;
                    case mapCtorString: return mapTag;
                    case promiseCtorString: return promiseTag;
                    case setCtorString: return setTag;
                    case weakMapCtorString: return weakMapTag;
                }
            }
            return result;
        };
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length &&
            (typeof value == 'number' || reIsUint.test(value)) &&
            (value > -1 && value % 1 == 0 && value < length);
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
        var type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
        var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
        return value === proto;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
        return nativeObjectToString.call(value);
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
        if (func != null) {
            try {
                return funcToString.call(func);
            }
            catch (e) { }
            try {
                return (func + '');
            }
            catch (e) { }
        }
        return '';
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
        return value === other || (value !== value && other !== other);
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
    };
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
        return baseIsEqual(value, other);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
        if (!isObject(value)) {
            return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
        return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
        return value != null && typeof value == 'object';
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
        return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
        return false;
    }
    module.exports = isEqual;
});
var renderChild = function (renderFunction, data) { return data && renderFunction(data); };
var scSizeProviderCss = "sc-size-provider .sc-size-provider-container{width:100%;height:100%}";
/**
 * The rate at which the layout will update for graphics projected onto some element.
 *
 * A smaller duration will make performance suffer but prevent ghosting.
 */
var MS_PER_RECT_POLL = 650;
var ScSizeProvider = /** @class */ (function () {
    function ScSizeProvider(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        /** The DOM Elements size as computed by the observer. corrected on resolution changes. */
        this.computedSize = null;
        this.rect = null;
        this.rectPollingHandler = null;
        this.setRect = function () {
            if (_this.el && _this.el.isConnected) {
                var newRect = rectScrollFixed(_this.el);
                var rectHasUpdated = !lodash_isequal(newRect, _this.rect);
                if (rectHasUpdated) {
                    if (_this.rect && _this.rect.density !== newRect.density) {
                        // When the density has changed, we need to trigger a resolution change. This will occur in scenarios
                        // such as attaching or detaching a monitor.
                        webGLRenderer.onResolutionChange();
                    }
                    // Note: It's important to only set this value if the contents actually change,
                    //       since it triggers a cascading re-render.
                    _this.rect = newRect;
                }
            }
        };
    }
    ScSizeProvider.prototype.componentWillLoad = function () {
        var _this = this;
        /**
         * Creates a listener for elements dimensions changing.
         * This allows us to dynamically set the widget dimensions.
         */
        this.resizer = new index(function (entries) {
            entries.forEach(function (entry) {
                /** Update Size */
                var _a = entry.contentRect, width = _a.width, height = _a.height;
                _this.computedSize = { width: width, height: height };
            });
        });
    };
    ScSizeProvider.prototype.componentDidLoad = function () {
        this.setRect();
        this.rectPollingHandler = window.setInterval(this.setRect, MS_PER_RECT_POLL);
        this.resizer.observe(this.el.firstElementChild);
    };
    ScSizeProvider.prototype.disconnectedCallback = function () {
        this.resizer.disconnect();
        if (this.rectPollingHandler) {
            window.clearInterval(this.rectPollingHandler);
        }
    };
    ScSizeProvider.prototype.render = function () {
        var rect = (this.size || this.computedSize) && this.rect
            ? Object.assign(Object.assign(Object.assign({}, this.rect), this.computedSize), this.size) : undefined;
        return h("div", { class: "sc-size-provider-container" }, renderChild(this.renderFunc, rect));
    };
    Object.defineProperty(ScSizeProvider.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    return ScSizeProvider;
}());
ScSizeProvider.style = scSizeProviderCss;
var scTooltipCss = "sc-tooltip{--tooltip-size:8px;--tooltip-line-width:2px;pointer-events:none;position:absolute}sc-tooltip small{white-space:nowrap}sc-tooltip .awsui{position:absolute;z-index:20;min-width:90px}sc-tooltip .tooltip-container{background:var(--awsui-color-white);position:relative;display:inline-block;min-width:90px;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-transition-property:left, top;transition-property:left, top;-webkit-transition-duration:120ms;transition-duration:120ms}sc-tooltip .tooltip-line{position:relative;margin-left:calc(-1 * calc(var(--tooltip-line-width) / 2));width:var(--selection-width);background-color:var(--selection-color);opacity:var(--selection-opacity)}";
var ScTooltip = /** @class */ (function () {
    function ScTooltip(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.trendResults = [];
        this.showDataStreamColor = true;
        // If false, do not display a tooltip row if there is no associated point.
        this.showBlankTooltipRows = false;
        this.sortPoints = true;
        this.setSelectedDate = function (_a) {
            var offsetX = _a.offsetX, buttons = _a.buttons;
            var isMouseBeingPressed = buttons > 0;
            if (!isMouseBeingPressed && offsetX != null) {
                // Determine the date which corresponds with the mouses position.
                var _b = _this.viewport, start_1 = _b.start, end = _b.end;
                var width = _this.size.width;
                var ratio = offsetX / width;
                var viewportDuration = end.getTime() - start_1.getTime();
                var selectedDateMS = start_1.getTime() + viewportDuration * ratio;
                _this.selectedDate = new Date(selectedDateMS);
            }
            else {
                _this.selectedDate = undefined;
            }
        };
        this.hideTooltip = function () {
            _this.selectedDate = undefined;
        };
    }
    ScTooltip.prototype.componentDidLoad = function () {
        this.dataContainer.addEventListener('mousemove', this.setSelectedDate);
        this.dataContainer.addEventListener('mouseleave', this.hideTooltip);
        this.dataContainer.addEventListener('mousedown', this.hideTooltip, { capture: true });
    };
    ScTooltip.prototype.disconnectedCallback = function () {
        this.dataContainer.removeEventListener('mousemove', this.setSelectedDate);
        this.dataContainer.removeEventListener('mouseleave', this.hideTooltip);
        this.dataContainer.removeEventListener('mousedown', this.hideTooltip);
    };
    ScTooltip.prototype.render = function () {
        var resolution = this.dataStreams.length > 0 ? this.dataStreams[0].resolution : undefined;
        if (resolution == null || this.selectedDate == null) {
            return null;
        }
        return (h("sc-tooltip-rows", { trendResults: this.trendResults, size: this.size, dataStreams: this.dataStreams, viewport: this.viewport, selectedDate: this.selectedDate, thresholds: this.thresholds, maxDurationFromDate: this.maxDurationFromDate, showDataStreamColor: this.showDataStreamColor, dataAlignment: this.dataAlignment, supportString: this.supportString, visualizesAlarms: this.visualizesAlarms, showBlankTooltipRows: this.showBlankTooltipRows, sortPoints: this.sortPoints, top: this.top }));
    };
    return ScTooltip;
}());
ScTooltip.style = scTooltipCss;
var scTooltipRowCss = "sc-tooltip-row{font-size:var(--font-size-1);--bar-size:18px}sc-tooltip-rows .left-offset{padding-left:4px}sc-tooltip-row .clearfix::after{content:'';clear:both;display:table}sc-tooltip-row .bar{display:inline-block;float:left;width:var(--bar-size);height:20px;padding-top:8px}sc-tooltip-row .label{padding-left:var(--margin-small);color:var(--light-text);float:left}sc-tooltip-row .value{font-weight:bold;float:right;margin-left:15px}";
var baseColor = '#000';
var AGGREGATED_LEVEL = 'average';
var ScTooltipRow = /** @class */ (function () {
    function ScTooltipRow(hostRef) {
        registerInstance(this, hostRef);
        this.valueColor = baseColor;
    }
    ScTooltipRow.prototype.render = function () {
        var isTrendPoint = this.pointType === "trend" /* TREND */;
        return (h("div", { class: "clearfix" }, this.showDataStreamColor && (h("span", { class: "awsui-util-mr-xs" }, h("svg", { class: "bar", "data-testid": "tooltip-icon-" + this.pointType }, h("path", { stroke: this.color, "stroke-dasharray": isTrendPoint ? TREND_ICON_DASH_ARRAY : undefined, "stroke-linecap": STREAM_ICON_STROKE_LINECAP, "stroke-width": STREAM_ICON_STROKE_WIDTH, d: STREAM_ICON_PATH_COMMAND })))), h("span", { class: "label awsui-util-d-i", "data-testid": "tooltip-row-label" }, this.label), h("span", { class: "value awsui-util-d-i", "data-testid": "current-value", style: { color: this.valueColor } }, this.icon && h("sc-chart-icon", { name: this.icon }), h(Value, { value: this.point && this.point.y })), this.resolution != null && (h("div", { class: "awsui-util-pb-s" }, h("small", null, getAggregationFrequency(this.resolution, AGGREGATED_LEVEL))))));
    };
    return ScTooltipRow;
}());
ScTooltipRow.style = scTooltipRowCss;
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;
/** `Object#toString` result references. */
var funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */
var root$1 = freeGlobal || freeSelf || Function('return this')();
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (comparator(value, array[index])) {
            return true;
        }
    }
    return false;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        }
        catch (e) { }
    }
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];
/** Used to detect methods masquerading as native. */
var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
}());
/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;
/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;
/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */
var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map'), Set = getNative(root$1, 'Set'), nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    }
    else {
        splice.call(data, index, 1);
    }
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([key, value]);
    }
    else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map$1 || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while (++index < length) {
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
            return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    }
    else {
        seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                    continue outer;
                }
            }
            if (iteratee) {
                seen.push(computed);
            }
            result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop$2 : function (values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        }
        catch (e) { }
        try {
            return (func + '');
        }
        catch (e) { }
    }
    return '';
}
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
    return (array && array.length)
        ? baseUniq(array)
        : [];
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
    return value === other || (value !== value && other !== other);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$2() {
    // No operation performed.
}
var lodash_uniq = uniq;
/**
 * The date we want to utilize as the 'date at which to display the tooltip cursor at'
 */
var utilizedTimestamp = function (_a) {
    var isRaw = _a.isRaw, points = _a.points, selectedTimestamp = _a.selectedTimestamp, viewport = _a.viewport;
    if (isRaw) {
        // always use the selected date when raw. this has the impact of having the tooltip cursor always at where the cursor is
        return selectedTimestamp;
    }
    var pointDate = points[0].point && points[0].point.x;
    if (pointDate == null) {
        return selectedTimestamp;
    }
    if (pointDate < viewport.start.getTime()) {
        // If the date is before the viewport, just use the start of the viewport. This has the effect of making a tooltip
        // appear flush at the left of the viewport when focusing on before-end-of-viewport positioned data.
        return viewport.start.getTime();
    }
    return pointDate;
};
var tooltipPosition = function (_a) {
    var viewport = _a.viewport, _b = _a.size, width = _b.width, height = _b.height, points = _a.points, resolution = _a.resolution, selectedTimestamp = _a.selectedTimestamp;
    if (points.length === 0) {
        return undefined;
    }
    var isRaw = resolution === 0;
    // represents the date which corresponds with the position to render the cursor at
    var timestamp = utilizedTimestamp({ isRaw: isRaw, points: points, selectedTimestamp: selectedTimestamp, viewport: viewport });
    var viewportDuration = viewport.end.getTime() - viewport.start.getTime();
    var datePositionRatio = (timestamp - viewport.start.getTime()) / viewportDuration;
    var pixelX = width * datePositionRatio;
    var modelY = Math.max.apply(Math, points.map(function (_a) {
        var point = _a.point;
        return (point ? point.y : undefined);
    }).filter(isNumber));
    var pixelY = Math.max(0, height * (1 - (modelY - viewport.yMin) / (viewport.yMax - viewport.yMin)));
    return { x: pixelX, y: pixelY };
};
var trendLinePoints = function (_a) {
    var trendResults = _a.trendResults, dataStreams = _a.dataStreams, displayedDate = _a.displayedDate;
    var timestamp = displayedDate.getTime();
    return trendResults
        .filter(function (_a) {
        var dataStreamId = _a.dataStreamId;
        return dataStreams.some(function (_a) {
            var id = _a.id;
            return id === dataStreamId;
        });
    })
        .map(function (trendResult) {
        var dataStream = dataStreams.find(function (_a) {
            var id = _a.id;
            return id === trendResult.dataStreamId;
        });
        return dataStream == null
            ? null
            : {
                streamId: dataStream.id,
                label: getTrendLabel(dataStream.name, trendResult.type),
                point: {
                    x: timestamp,
                    y: getTrendValue(trendResult, timestamp),
                },
                type: "trend" /* TREND */,
                color: trendResult.color,
            };
    })
        .filter(isDefined);
};
var AGGREGATED_LEVEL$1 = 'average';
var TOOLTIP_ROW_HEIGHT = 21;
var TOOLTIP_EMPTY_HEIGHT = 71;
var X_OFFSET = 8;
var ScTooltipRows = /** @class */ (function () {
    function ScTooltipRows(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.trendResults = [];
        this.showDataStreamColor = true;
        this.sortPoints = true;
        /** Total height of the tool tip display */
        this.tooltipHeight = function (numRows) { return numRows * TOOLTIP_ROW_HEIGHT + TOOLTIP_EMPTY_HEIGHT; };
        /**
         * Returns the color to display the value within a legend row.
         *
         * Takes into account whether the data stream is breached.
         * Does not take into account associated alarms
         */
        this.rowsValueColorAndIcon = function (id, _a, date) {
            var y = _a.y;
            var dataStream = _this.dataStreams.find(function (info) { return info.id === id; });
            if (dataStream == null) {
                return undefined;
            }
            var threshold = breachedThreshold({
                date: date,
                value: y,
                thresholds: _this.thresholds,
                dataStreams: [],
                dataStream: dataStream,
            });
            return threshold != null ? { color: threshold.color, icon: threshold.icon } : undefined;
        };
        /**
         * The point in time which is 'actively' being viewed within the tooltip.
         */
        this.getDisplayedDate = function (points) {
            var resolutions = _this.dataStreams.map(function (_a) {
                var resolution = _a.resolution;
                return resolution;
            });
            var minResolution = resolutions.length > 0 ? Math.min.apply(Math, resolutions) : 0;
            if (minResolution === 0) {
                return _this.selectedDate;
            }
            var firstPoint = points[0] && points[0].point ? new Date(points[0].point.x) : undefined;
            var firstPointTrend = _this.trendResults[0] ? _this.trendResults[0].startDate : undefined;
            return firstPoint || firstPointTrend || _this.selectedDate;
        };
        /**
         * Returns the data which is supported
         *
         * i.e. if `supportsString` is false, do not return any data streams of string type
         */
        this.visualizedDataStreams = function () {
            var streams = _this.dataStreams.filter(isSupportedDataType(_this.supportString));
            if (_this.visualizesAlarms) {
                // Visualize all infos with a valid data type
                return streams;
            }
            // Visualize only property-infos (non-alarms) with a valid data type
            return streams.filter(function (_a) {
                var streamType = _a.streamType;
                return streamType !== StreamType.ALARM;
            });
        };
        /**
         * Return each of the 'points' to be displayed
         *
         * each of these will correspond to one `tooltip-row`
         */
        this.getTooltipPoints = function () {
            var resolutions = _this.dataStreams.map(function (_a) {
                var resolution = _a.resolution;
                return resolution;
            });
            var minResolution = resolutions.length > 0 ? Math.min.apply(Math, resolutions) : 0;
            var dataPoints = activePoints({
                viewport: _this.viewport,
                dataStreams: _this.visualizedDataStreams(),
                dataAlignment: _this.dataAlignment,
                selectedDate: _this.selectedDate,
                allowMultipleDates: minResolution === 0,
                maxDurationFromDate: _this.maxDurationFromDate,
            }).map(function (p) { return (Object.assign(Object.assign({}, p), { type: "data" /* DATA */ })); });
            var trendPoints = trendLinePoints({
                dataStreams: _this.dataStreams,
                displayedDate: _this.getDisplayedDate(dataPoints),
                trendResults: _this.trendResults,
            });
            var tooltipPoints = __spreadArrays(dataPoints, trendPoints);
            // Either sort, or place them in the order the infos are presented
            var points = _this.sortPoints
                ? tooltipPoints.sort(sortTooltipPoints(function (p) { return p.y; }))
                : _this.dataStreams.map(function (_a) {
                    var id = _a.id;
                    return tooltipPoints.find(function (p) { return p.streamId === id; });
                }).filter(isDefined);
            // Optionally filter out anything without a point
            if (_this.showBlankTooltipRows) {
                return points;
            }
            return points.filter(function (p) { return p.point != null; });
        };
    }
    ScTooltipRows.prototype.render = function () {
        var _this = this;
        var resolutions = this.dataStreams.map(function (_a) {
            var resolution = _a.resolution;
            return resolution;
        });
        var minResolution = resolutions.length > 0 ? Math.min.apply(Math, resolutions) : 0;
        var isCrossResolution = lodash_uniq(resolutions).length > 1;
        var points = this.getTooltipPoints();
        var displayedDate = this.getDisplayedDate(points);
        var position = tooltipPosition({
            points: points,
            resolution: minResolution,
            viewport: this.viewport,
            size: this.size,
            selectedTimestamp: this.selectedDate.getTime(),
        });
        if (points.length === 0) {
            // If there are no tooltip points to display on the tool tip, don't display anything.
            return null;
        }
        if (position == null) {
            return null;
        }
        var tooltipContainerTop = this.top != null
            ? this.top + "px"
            : position.y - (this.tooltipHeight(points.length) * 3) / 4 - this.size.height + "px";
        var displayToolTipOnLeftSize = position.x >= this.size.width / 2;
        var toolTipPositioning = displayToolTipOnLeftSize
            ? {
                right: -position.x + X_OFFSET + "px",
                transform: 'translateX(-100%)',
            }
            : {
                left: position.x + X_OFFSET + "px",
            };
        return (h("div", { class: "awsui" }, h("div", { class: "tooltip-line", style: {
                left: position.x + "px",
                height: this.size.height + "px",
            } }), h("div", { class: "tooltip-container", style: Object.assign({ top: tooltipContainerTop }, toolTipPositioning) }, h("div", { class: "awsui-util-shadow awsui-util-p-s" }, h("small", { class: { 'awsui-util-d-b': true, 'left-offset': !this.showDataStreamColor } }, displayDate(displayedDate, minResolution, this.viewport)), !isCrossResolution && (h("small", { class: { 'awsui-util-d-b': true, 'awsui-util-mb-s': true, 'left-offset': !this.showDataStreamColor } }, getAggregationFrequency(minResolution, AGGREGATED_LEVEL$1))), points.map(function (tooltipPoint) {
            var streamId = tooltipPoint.streamId;
            /** Find the data stream info associated with the given data point */
            var dataStream = _this.dataStreams.find(function (_a) {
                var id = _a.id;
                return id === streamId;
            });
            if (!dataStream) {
                /* eslint-disable-next-line  no-console */
                console.warn("No data stream info associated with id " + streamId);
                return null;
            }
            var _a = (tooltipPoint.point && _this.rowsValueColorAndIcon(streamId, tooltipPoint.point, displayedDate)) || {}, _b = _a.color, valueColor = _b === void 0 ? undefined : _b, _c = _a.icon, icon = _c === void 0 ? undefined : _c;
            return (h("sc-tooltip-row", { key: tooltipPoint.streamId + "-" + tooltipPoint.type, showDataStreamColor: _this.showDataStreamColor, label: tooltipPoint.label || dataStream.name, resolution: isCrossResolution ? dataStream.resolution : undefined, color: tooltipPoint.color || dataStream.color || 'black', point: tooltipPoint.point, pointType: tooltipPoint.type, valueColor: valueColor, icon: icon }));
        })))));
    };
    return ScTooltipRows;
}());
var scWebglAxisCss = "sc-webgl-axis{font-size:var(--font-size-0)}sc-webgl-axis .axis{font-family:var(--primary-font-family);shape-rendering:crispEdges;position:absolute;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none}sc-webgl-axis .axis path{display:none}sc-webgl-axis .axis .tick{color:var(--polaris-light-gray)}sc-webgl-axis line.x-axis-separator{color:var(--primary-light);stroke:var(--primary-light);stroke-width:1px}sc-webgl-axis .axis .tick line{color:var(--primary-light)}sc-webgl-axis .axis .tick text{font-size:var(--font-size-0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}sc-webgl-axis .x-axis .tick:last-child text{font-weight:var(--font-weight-bold)}";
var ScWebglAxis = /** @class */ (function () {
    function ScWebglAxis(hostRef) {
        registerInstance(this, hostRef);
    }
    ScWebglAxis.prototype.render = function () {
        var _a = this.size, width = _a.width, height = _a.height, marginLeft = _a.marginLeft, marginRight = _a.marginRight, marginTop = _a.marginTop, marginBottom = _a.marginBottom;
        return (h("svg", { class: "axis", style: {
                width: width + marginLeft + marginRight + "px",
                height: height + marginBottom + marginTop + "px",
            } }));
    };
    return ScWebglAxis;
}());
ScWebglAxis.style = scWebglAxisCss;
var lodash_clonedeep = createCommonjsModule(function (module, exports) {
    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;
    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] =
        cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
            cloneableTags[boolTag] = cloneableTags[dateTag] =
                cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                        cloneableTags[int32Tag] = cloneableTags[mapTag] =
                            cloneableTags[numberTag] = cloneableTags[objectTag] =
                                cloneableTags[regexpTag] = cloneableTags[setTag] =
                                    cloneableTags[stringTag] = cloneableTags[symbolTag] =
                                        cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] =
        cloneableTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;
    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */
    function addMapEntry(map, pair) {
        // Don't return `map.set` because it's not chainable in IE 11.
        map.set(pair[0], pair[1]);
        return map;
    }
    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */
    function addSetEntry(set, value) {
        // Don't return `set.add` because it's not chainable in IE 11.
        set.add(value);
        return set;
    }
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        if (initAccum && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
        return object == null ? undefined : object[key];
    }
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
        // Many host objects are `Object` objects that can coerce to strings
        // despite having improperly defined `toString` methods.
        var result = false;
        if (value != null && typeof value.toString != 'function') {
            try {
                result = !!(value + '');
            }
            catch (e) { }
        }
        return result;
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
        return function (arg) {
            return func(transform(arg));
        };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }
    /** Used for built-in method references. */
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */
    var coreJsData = root['__core-js_shared__'];
    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
    }());
    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
        funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
        var data = this.__data__;
        data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
        return this;
    }
    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
        this.__data__ = [];
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        }
        else {
            splice.call(data, index, 1);
        }
        return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            data.push([key, value]);
        }
        else {
            data[index][1] = value;
        }
        return this;
    }
    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
        this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
        };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
        return getMapData(this, key)['delete'](key);
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
    }
    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
        this.__data__ = new ListCache(entries);
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
        this.__data__ = new ListCache;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
        return this.__data__['delete'](key);
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
        return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
        return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
            var pairs = cache.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                pairs.push([key, value]);
                return this;
            }
            cache = this.__data__ = new MapCache(pairs);
        }
        cache.set(key, value);
        return this;
    }
    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
        // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
        // Safari 9 makes `arguments.length` enumerable in strict mode.
        var result = (isArray(value) || isArguments(value))
            ? baseTimes(value.length, String)
            : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))) {
            object[key] = value;
        }
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
    }
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined) {
            return result;
        }
        if (!isObject(value)) {
            return value;
        }
        var isArr = isArray(value);
        if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
                return copyArray(value, result);
            }
        }
        else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                if (isHostObject(value)) {
                    return object ? value : {};
                }
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) {
                    return copySymbols(value, baseAssign(result, value));
                }
            }
            else {
                if (!cloneableTags[tag]) {
                    return object ? value : {};
                }
                result = initCloneByTag(value, tag, baseClone, isDeep);
            }
        }
        // Check for circular references and return its corresponding clone.
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
            return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
            var props = isFull ? getAllKeys(value) : keys(value);
        }
        arrayEach(props || value, function (subValue, key) {
            if (props) {
                key = subValue;
                subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
        });
        return result;
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(proto) {
        return isObject(proto) ? objectCreate(proto) : {};
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
        return objectToString.call(value);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
        if (!isPrototype(object)) {
            return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
            }
        }
        return result;
    }
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
            return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
    }
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
    }
    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
    function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
        return arrayReduce(array, addMapEntry, new map.constructor);
    }
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
    }
    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
    function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
        return arrayReduce(array, addSetEntry, new set.constructor);
    }
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
            array[index] = source[index];
        }
        return array;
    }
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
            var key = props[index];
            var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined;
            assignValue(object, key, newValue === undefined ? source[key] : newValue);
        }
        return object;
    }
    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
    }
    /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;
    // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge < 14, and promises in Node.js.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
        getTag = function (value) {
            var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString: return dataViewTag;
                    case mapCtorString: return mapTag;
                    case promiseCtorString: return promiseTag;
                    case setCtorString: return setTag;
                    case weakMapCtorString: return weakMapTag;
                }
            }
            return result;
        };
    }
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
        var length = array.length, result = array.constructor(length);
        // Add properties assigned by `RegExp#exec`.
        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
        }
        return result;
    }
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
        return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
    }
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
            case arrayBufferTag:
                return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
                return new Ctor(+object);
            case dataViewTag:
                return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
                return cloneTypedArray(object, isDeep);
            case mapTag:
                return cloneMap(object, isDeep, cloneFunc);
            case numberTag:
            case stringTag:
                return new Ctor(object);
            case regexpTag:
                return cloneRegExp(object);
            case setTag:
                return cloneSet(object, isDeep, cloneFunc);
            case symbolTag:
                return cloneSymbol(object);
        }
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length &&
            (typeof value == 'number' || reIsUint.test(value)) &&
            (value > -1 && value % 1 == 0 && value < length);
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
        var type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
        var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
        return value === proto;
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
        if (func != null) {
            try {
                return funcToString.call(func);
            }
            catch (e) { }
            try {
                return (func + '');
            }
            catch (e) { }
        }
        return '';
    }
    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
        return baseClone(value, true, true);
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
        return value === other || (value !== value && other !== other);
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
        // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
        return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
            (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 8-9 which returns 'object' for typed array and other constructors.
        var tag = isObject(value) ? objectToString.call(value) : '';
        return tag == funcTag || tag == genTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
        return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
        var type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
        return !!value && typeof value == 'object';
    }
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
        return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
        return false;
    }
    module.exports = cloneDeep;
});
var LOADING_SPINNER_SIZE_PX = 60;
var LoadingStatus = function (_a) {
    var isLoading = _a.isLoading;
    return (h("div", { style: {
            zIndex: '11',
            position: 'absolute',
            width: '100%',
            height: '100%',
            display: isLoading ? 'flex' : 'none',
            justifyContent: 'center',
            alignItems: 'center',
            pointerEvents: 'none',
        } }, isLoading && h("sc-loading-spinner", { size: LOADING_SPINNER_SIZE_PX })));
};
var ErrorStatus = function (_a) {
    var hasError = _a.hasError, _b = _a.size, marginLeft = _b.marginLeft, width = _b.width;
    return hasError ? (h("div", { style: { position: 'absolute', width: width + "px" } }, h("div", { class: "awsui-util-mt-s", style: {
            left: marginLeft + "px",
            position: 'relative',
            width: '100%',
            display: 'flex',
            flexDirection: 'row-reverse',
        } }, h("sc-error-badge", null, "Stopped")))) : (h("div", { "data-test-tag": "error-badge-place-holder", style: { display: 'none' } }));
};
var chartLegendContainerClassName = 'chart-legend-container';
var ChartLegendContainer = function (_a, children) {
    var legendHeight = _a.legendHeight, config = _a.config, _b = _a.size, height = _b.height, marginRight = _b.marginRight, marginLeft = _b.marginLeft, marginBottom = _b.marginBottom, marginTop = _b.marginTop, width = _b.width;
    var sharedStyles = {
        position: 'relative',
        overflowY: 'scroll',
        msOverflowStyle: 'none',
    };
    return config.position === LEGEND_POSITION.BOTTOM ? (h("div", { class: chartLegendContainerClassName, style: Object.assign(Object.assign({}, sharedStyles), { top: height + marginTop + marginBottom + "px", marginLeft: marginLeft + "px", marginRight: marginRight + "px", height: legendHeight + "px", width: width + "px" }) }, children)) : (h("div", { class: chartLegendContainerClassName, style: Object.assign(Object.assign({}, sharedStyles), { top: marginTop + "px", marginLeft: marginLeft + width + marginRight + "px", width: config.width + "px", marginRight: '0', height: height + "px" }) }, children));
};
/* Data Container is the tracking element used to draw our visualizations for this chart onto */
var DataContainer = function (_a, children) {
    var _b = _a.size, width = _b.width, height = _b.height, marginLeft = _b.marginLeft, marginTop = _b.marginTop;
    return (h("div", { style: {
            width: width + "px",
            height: height + "px",
            marginLeft: marginLeft + "px",
            marginTop: marginTop + "px",
        }, class: "data-container" }, children));
};
var ANNOTATION_FONT_SIZE = 10;
var ANNOTATION_STROKE_WIDTH = 1.5;
var getX = function (_a) {
    var annotation = _a.annotation, width = _a.width, viewport = _a.viewport;
    var start = viewport.start, end = viewport.end;
    return Math.floor((width / (end.getTime() - start.getTime())) * (annotation.value.getTime() - start.getTime()));
};
var TEXT_SELECTOR = 'text.x-text';
var ANNOTATION_GROUP_SELECTOR = 'g.x-annotation';
var LINE_SELECTOR = 'line.x-line';
var renderXAnnotations = function (_a) {
    var container = _a.container, xAnnotations = _a.xAnnotations, viewport = _a.viewport, resolution = _a.resolution, _b = _a.size, width = _b.width, height = _b.height;
    var annotationSelection = select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR)
        .data(xAnnotations);
    var getXAnnotationTextX = function (a) { return -getX({ annotation: a, width: width, viewport: viewport }); };
    var padding = 5;
    /** Add group for all elements */
    var annotationGroup = annotationSelection
        .enter()
        .append('g')
        .attr('transform', 'translate(0,0)')
        .attr('class', 'x-annotation');
    /** Create Line */
    annotationGroup
        .append('line')
        .attr('class', 'x-line')
        .attr('font-size', ANNOTATION_FONT_SIZE)
        .attr('x1', function (annotation) { return getX({ annotation: annotation, width: width, viewport: viewport }); })
        .attr('x2', function (annotation) { return getX({ annotation: annotation, width: width, viewport: viewport }); })
        .attr('y1', 0)
        .attr('y2', height)
        .style('stroke', getColor)
        .style('stroke-width', ANNOTATION_STROKE_WIDTH);
    /** Create X Text */
    annotationGroup
        .append('text')
        .text(function (annotation) { return getValueAndText({ annotation: annotation, resolution: resolution, viewport: viewport }); })
        .attr('display', getValueAndTextVisibility)
        .attr('font-size', ANNOTATION_FONT_SIZE)
        .attr('class', 'x-text')
        .attr('y', getXAnnotationTextX)
        .attr('x', 0)
        .style('pointer-events', 'none')
        .style('user-select', 'none')
        .style('transform', "rotate(90deg) translateY(" + -padding + "px)")
        .style('fill', getColor);
    /** Update Line */
    annotationSelection
        .select(LINE_SELECTOR)
        .attr('x1', function (annotation) { return getX({ annotation: annotation, width: width, viewport: viewport }); })
        .attr('x2', function (annotation) { return getX({ annotation: annotation, width: width, viewport: viewport }); })
        .attr('y2', height)
        .attr('stroke', getColor);
    /** Update Text */
    annotationSelection
        .select(TEXT_SELECTOR)
        .attr('display', getValueAndTextVisibility)
        .text(function (annotation) { return getValueAndText({ annotation: annotation, resolution: resolution, viewport: viewport }); })
        .attr('y', getXAnnotationTextX)
        .style('fill', getColor);
    /** Delete */
    annotationSelection.exit().remove();
};
var removeXAnnotations = function (_a) {
    var container = _a.container;
    select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR)
        .remove();
};
var getY = function (_a) {
    var annotation = _a.annotation, height = _a.height, viewport = _a.viewport;
    var yMax = viewport.yMax, yMin = viewport.yMin;
    return height - ((annotation.value - yMin) * height) / (yMax - yMin);
};
var PADDING = 5;
var Y_ANNOTATION_TEXT_PADDING = 3;
var Y_ANNOTATION_TEXT_LEFT_PADDING = 5;
var HANDLE_OFFSET_X = 1;
var HANDLE_OFFSET_Y = -11;
var HANDLE_WIDTH = 45;
var SMALL_HANDLE_WIDTH = 18;
var HANDLE_HEIGHT = 20;
var DRAGGABLE_LINE_OFFSET_Y = -6;
var DRAGGABLE_LINE_OFFSET_X = 40;
var SMALL_DRAGGABLE_LINE_OFFSET_X = 13;
var DRAGGABLE_LINE_LENGTH = 10;
var DRAGGABLE_LINE_STROKE = 1;
var DRAGGABLE_LINE_SEPARATION = 2;
var TEXT_SELECTOR$1 = 'text.y-text';
var TEXT_VALUE_SELECTOR = 'text.y-value-text';
var ANNOTATION_GROUP_SELECTOR$1 = 'g.y-annotation';
var ANNOTATION_GROUP_SELECTOR_EDITABLE = 'g.y-annotation-editable';
var LINE_SELECTOR$1 = 'line.y-line';
var DRAGGABLE_HANDLE_SELECTOR = 'rect.y-annotation';
var DRAGGABLE_LINE_ONE_SELECTOR = 'line.y-handle-one';
var DRAGGABLE_LINE_TWO_SELECTOR = 'line.y-handle-two';
var ELEMENT_GROUP_SELECTOR = 'g.y-elements-group';
var renderYAnnotationsEditable = function (_a) {
    var container = _a.container, yAnnotations = _a.yAnnotations, viewport = _a.viewport, resolution = _a.resolution, _b = _a.size, width = _b.width, height = _b.height;
    var getYPosition = function (annotation) { return getY({
        annotation: annotation,
        height: height,
        viewport: viewport,
    }); };
    var getYHandleWidth = function (yAnnotation) { return getValueTextVisibility(yAnnotation) === 'inline' ? HANDLE_WIDTH : SMALL_HANDLE_WIDTH; };
    var getDraggableLineTwoX = function (yAnnotation) { return getValueTextVisibility(yAnnotation) === 'inline'
        ? width + DRAGGABLE_LINE_OFFSET_X + DRAGGABLE_LINE_SEPARATION
        : width + SMALL_DRAGGABLE_LINE_OFFSET_X + DRAGGABLE_LINE_SEPARATION; };
    var getDraggableLineOneX = function (yAnnotation) { return getValueTextVisibility(yAnnotation) === 'inline'
        ? width + DRAGGABLE_LINE_OFFSET_X
        : width + SMALL_DRAGGABLE_LINE_OFFSET_X; };
    var getYAnnotationHandleY = function (yAnnotation) { return getYPosition(yAnnotation) + HANDLE_OFFSET_Y; };
    var getValueFontSize = function (yAnnotation) { return yAnnotation.value < -9999 ? ANNOTATION_FONT_SIZE - 1 : ANNOTATION_FONT_SIZE; };
    var getGroupPosition = function (yAnnotation) {
        return "translate(0," + getYPosition(yAnnotation) + ")";
    };
    var annotationSelectionEditable = select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR_EDITABLE)
        .data(yAnnotations.filter(function (annotation) { return annotation.isEditable; }));
    /** Add group for all elements */
    var annotationGroupEditable = annotationSelectionEditable
        .enter()
        .append('g')
        .attr('transform', 'translate(0,0)')
        .attr('class', 'y-annotation-editable');
    /** Create Draggable Annotation Handle Rectangle */
    var dragHandle = annotationGroupEditable
        .append('rect')
        .attr('class', 'y-annotation')
        .attr('width', getYHandleWidth)
        .attr('height', HANDLE_HEIGHT)
        .attr('x', width + HANDLE_OFFSET_X)
        .attr('y', getYAnnotationHandleY)
        .style('pointer-events', 'auto')
        .style('stroke', getColor)
        .style('stroke-width', ANNOTATION_STROKE_WIDTH)
        .style('fill', 'white');
    /** Create Sub Group for all elements except drag handle */
    var handleGroup = annotationGroupEditable
        .append('g')
        .attr('transform', getGroupPosition)
        .attr('class', 'y-elements-group');
    /** Create Line */
    handleGroup
        .append('line')
        .attr('class', 'y-line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', 0)
        .attr('y2', 0)
        .style('stroke', getColor)
        .style('stroke-width', ANNOTATION_STROKE_WIDTH);
    /** Create Value Text */
    handleGroup
        .append('text')
        .attr('display', getValueTextVisibility)
        .attr('class', 'y-value-text')
        .attr('x', width + Y_ANNOTATION_TEXT_LEFT_PADDING)
        .attr('text-anchor', 'start')
        .attr('y', Y_ANNOTATION_TEXT_PADDING)
        .text(function (annotation) { return getValueText({ annotation: annotation, resolution: resolution, viewport: viewport, formatText: true }); })
        .style('font-size', getValueFontSize)
        .style('user-select', 'none')
        .style('pointer-events', 'none')
        .style('fill', getColor);
    /** Create Label Text */
    handleGroup
        .append('text')
        .attr('display', getLabelTextVisibility)
        .attr('class', 'y-text')
        .attr('x', width - PADDING)
        .attr('text-anchor', 'end')
        .attr('y', -PADDING)
        .text(getText)
        .style('font-size', ANNOTATION_FONT_SIZE)
        .style('user-select', 'none')
        .style('pointer-events', 'none')
        .style('fill', getColor);
    /** Create lines for draggable annotation handle */
    handleGroup
        .append('line')
        .attr('class', 'y-handle-one')
        .attr('x1', getDraggableLineOneX)
        .attr('x2', getDraggableLineOneX)
        .attr('y1', DRAGGABLE_LINE_OFFSET_Y)
        .attr('y2', DRAGGABLE_LINE_OFFSET_Y + DRAGGABLE_LINE_LENGTH)
        .style('stroke', 'gray')
        .style('stroke-width', DRAGGABLE_LINE_STROKE);
    handleGroup
        .append('line')
        .attr('class', 'y-handle-two')
        .attr('x1', getDraggableLineTwoX)
        .attr('x2', getDraggableLineTwoX)
        .attr('y1', DRAGGABLE_LINE_OFFSET_Y)
        .attr('y2', DRAGGABLE_LINE_OFFSET_Y + DRAGGABLE_LINE_LENGTH)
        .style('stroke', 'gray')
        .style('stroke-width', DRAGGABLE_LINE_STROKE);
    /** Update Subgroup Elements */
    annotationSelectionEditable.select(ELEMENT_GROUP_SELECTOR).attr('transform', getGroupPosition);
    /** Update Threshold Value Text */
    annotationSelectionEditable
        .select(TEXT_VALUE_SELECTOR)
        .attr('display', getValueTextVisibility)
        .attr('x', width + Y_ANNOTATION_TEXT_LEFT_PADDING)
        .text(function (annotation) { return getValueText({ annotation: annotation, resolution: resolution, viewport: viewport, formatText: true }); })
        .style('fill', getColor)
        .style('font-size', getValueFontSize);
    /** Update Label Text */
    annotationSelectionEditable
        .select(TEXT_SELECTOR$1)
        .attr('display', getLabelTextVisibility)
        .attr('x', width - PADDING)
        .text(getText)
        .style('fill', getColor);
    /** Update Threshold Line */
    annotationSelectionEditable
        .select(LINE_SELECTOR$1)
        .attr('x2', width)
        .style('stroke', getColor);
    /** Update Handle Lines */
    annotationSelectionEditable
        .select(DRAGGABLE_LINE_ONE_SELECTOR)
        .attr('x1', getDraggableLineOneX)
        .attr('x2', getDraggableLineOneX);
    annotationSelectionEditable
        .select(DRAGGABLE_LINE_TWO_SELECTOR)
        .attr('x1', getDraggableLineTwoX)
        .attr('x2', getDraggableLineTwoX);
    /** Update Draggable Annotation Handle Rectangle */
    annotationSelectionEditable
        .select(DRAGGABLE_HANDLE_SELECTOR)
        .attr('y', getYAnnotationHandleY)
        .attr('x', width + HANDLE_OFFSET_X)
        .attr('width', getYHandleWidth)
        .style('stroke', getColor);
    // Note: the order in which we render the elements matters
    // the draggable handle MUST be rendered first in order to be at the bottom and not cover up any other draggable annotation elements
    /** Exit */
    annotationSelectionEditable.exit().remove();
    return dragHandle;
};
var renderYAnnotations = function (_a) {
    var container = _a.container, yAnnotations = _a.yAnnotations, viewport = _a.viewport, resolution = _a.resolution, _b = _a.size, width = _b.width, height = _b.height;
    var getYPosition = function (annotation) { return getY({
        annotation: annotation,
        height: height,
        viewport: viewport,
    }); };
    var getGroupPosition = function (yAnnotation) {
        return "translate(0," + getYPosition(yAnnotation) + ")";
    };
    /** Not Editable Annotations */
    var annotationSelectionNotEditable = select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR$1)
        .data(yAnnotations.filter(function (annotation) { return !annotation.isEditable; }));
    /** Add group for all elements */
    var annotationGroup = annotationSelectionNotEditable
        .enter()
        .append('g')
        .attr('transform', getGroupPosition)
        .attr('class', 'y-annotation');
    /** Create Line */
    annotationGroup
        .append('line')
        .attr('class', 'y-line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', 0)
        .attr('y2', 0)
        .style('stroke', getColor)
        .style('stroke-width', ANNOTATION_STROKE_WIDTH);
    /** Create Value Text */
    annotationGroup
        .append('text')
        .attr('display', getValueTextVisibility)
        .attr('font-size', ANNOTATION_FONT_SIZE)
        .attr('class', 'y-value-text')
        .attr('x', width + Y_ANNOTATION_TEXT_LEFT_PADDING)
        .attr('text-anchor', 'start')
        .attr('y', Y_ANNOTATION_TEXT_PADDING)
        .text(function (annotation) { return getValueText({ annotation: annotation, resolution: resolution, viewport: viewport, formatText: true }); })
        .style('user-select', 'none')
        .style('pointer-events', 'none')
        .style('fill', getColor);
    /** Create Label Text */
    annotationGroup
        .append('text')
        .attr('display', getLabelTextVisibility)
        .attr('font-size', ANNOTATION_FONT_SIZE)
        .attr('class', 'y-text')
        .attr('x', width - PADDING)
        .attr('text-anchor', 'end')
        .attr('y', -PADDING)
        .text(getText)
        .style('user-select', 'none')
        .style('pointer-events', 'none')
        .style('fill', getColor);
    /** Update Group Position */
    annotationSelectionNotEditable.attr('transform', getGroupPosition);
    /** Update Threshold Value Text */
    annotationSelectionNotEditable
        .select(TEXT_VALUE_SELECTOR)
        .attr('display', getValueTextVisibility)
        .attr('x', width + Y_ANNOTATION_TEXT_LEFT_PADDING)
        .text(function (annotation) { return getValueText({ annotation: annotation, resolution: resolution, viewport: viewport, formatText: true }); })
        .style('fill', getColor);
    /** Update Label Text */
    annotationSelectionNotEditable
        .select(TEXT_SELECTOR$1)
        .attr('display', getLabelTextVisibility)
        .attr('x', width - PADDING)
        .text(getText)
        .style('fill', getColor);
    /** Update Threshold Line */
    annotationSelectionNotEditable
        .select(LINE_SELECTOR$1)
        .attr('x2', width)
        .style('stroke', getColor);
    /** Exit */
    annotationSelectionNotEditable.exit().remove();
};
var removeYAnnotations = function (_a) {
    var container = _a.container;
    /**
     * Y Annotation Threshold Groups
     */
    select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR$1)
        .remove();
    select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR_EDITABLE)
        .remove();
};
var withinViewport = function (viewport) {
    return function (_a) {
        var value = _a.value;
        if (typeof value === 'number') {
            return viewport.yMin <= value && viewport.yMax >= value;
        }
        return viewport.start <= value && viewport.end >= value;
    };
};
var dragHandler; // need to hold onto the dragHandle selector to dispose of it properly to prevent memory leak
var renderAnnotations = function (_a) {
    var container = _a.container, resolution = _a.resolution, annotations = _a.annotations, viewport = _a.viewport, size = _a.size, onUpdate = _a.onUpdate, activeViewPort = _a.activeViewPort, emitUpdatedWidgetConfiguration = _a.emitUpdatedWidgetConfiguration, draggable = _a.draggable, startStopDragging = _a.startStopDragging, inDragState = _a.inDragState;
    if (typeof annotations === 'object' && typeof annotations.show === 'boolean' && !annotations.show) {
        removeXAnnotations({ container: container });
        removeYAnnotations({ container: container });
        return;
    }
    // get annotations which have a value that lays within the viewport.
    var xAnnotations = annotations.x == null ? [] : annotations.x.filter(withinViewport(viewport));
    var yAnnotations = annotations.y == null ? [] : annotations.y.filter(withinViewport(viewport));
    /**
     * X Annotations
     */
    renderXAnnotations({
        container: container,
        xAnnotations: xAnnotations,
        viewport: viewport,
        resolution: resolution,
        size: size,
    });
    /**
     * Y Annotations
     */
    renderYAnnotations({
        container: container,
        yAnnotations: yAnnotations,
        viewport: viewport,
        resolution: resolution,
        size: size,
    });
    if (!inDragState()) {
        // do not re-render editable annotations in drag state
        /**
         * Y Annotations Editable (Draggable)
         */
        dragHandler = renderYAnnotationsEditable({
            container: container,
            yAnnotations: yAnnotations,
            viewport: viewport,
            resolution: resolution,
            size: size,
        });
        // prevents more event listeners from being attached when we drag
        draggable({
            container: container,
            size: size,
            onUpdate: onUpdate,
            activeViewPort: activeViewPort,
            emitUpdatedWidgetConfiguration: emitUpdatedWidgetConfiguration,
            startStopDragging: startStopDragging,
            resolution: resolution,
            dragHandle: dragHandler,
        });
    }
};
var getLinearPathCommand = function (_a) {
    var trendResult = _a.trendResult, _b = _a.size, width = _b.width, height = _b.height, _c = _a.viewport, start = _c.start, end = _c.end, yMin = _c.yMin, yMax = _c.yMax;
    // convert y-value to pixel position for start and end points of path
    var startY = Math.round(height - ((getTrendValue(trendResult, start.getTime()) - yMin) * height) / (yMax - yMin));
    var endY = Math.round(height - ((getTrendValue(trendResult, end.getTime()) - yMin) * height) / (yMax - yMin));
    // create draw commands for SVG paths
    return "M 0 " + startY + " L " + width + " " + endY;
};
var renderTrendLines = function (_a) {
    var container = _a.container, viewport = _a.viewport, _b = _a.size, width = _b.width, height = _b.height, dataStreams = _a.dataStreams, trendResults = _a.trendResults;
    var linearPathCommands = [];
    trendResults.forEach(function (trendResult) {
        var dataStream = dataStreams.find(function (elt) { return elt.id === trendResult.dataStreamId; });
        if (dataStream) {
            switch (trendResult.type) {
                case TREND_TYPE.LINEAR:
                    linearPathCommands.push({
                        color: trendResult.color || dataStream.color || 'black',
                        command: getLinearPathCommand({
                            trendResult: trendResult,
                            size: { width: width, height: height },
                            viewport: viewport,
                        }),
                    });
                    break;
                default:
                    /* eslint-disable-next-line no-console */
                    console.error("Unable to render trend line for trend type '" + trendResult.type + "'.");
            }
        }
    });
    // select existing path elements
    var linearSelection = select(container)
        .selectAll('path.linear-regression')
        .data(linearPathCommands);
    // create
    linearSelection
        .enter()
        .append('path')
        .attr('class', 'linear-regression')
        .attr('stroke', function (data) { return data.color; })
        .attr('stroke-dasharray', TREND_LINE_DASH_ARRAY)
        .attr('stroke-linecap', 'round')
        .attr('stroke-width', TREND_LINE_STROKE_WIDTH)
        .attr('d', function (data) { return data.command; });
    // update
    linearSelection.attr('stroke', function (data) { return data.color; }).attr('d', function (data) { return data.command; });
    // clean up extra path elements
    linearSelection.exit().remove();
};
var slice = Array.prototype.slice;
function identity$4(x) {
    return x;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon = 1e-6;
function translateX(x) {
    return "translate(" + (x + 0.5) + ",0)";
}
function translateY(y) {
    return "translate(0," + (y + 0.5) + ")";
}
function number$3(scale) {
    return function (d) {
        return +scale(d);
    };
}
function center(scale) {
    var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scale.round())
        offset = Math.round(offset);
    return function (d) {
        return +scale(d) + offset;
    };
}
function entering() {
    return !this.__axis;
}
function axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
    function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues, format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$4) : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center : number$3)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));
        tick = tick.merge(tickEnter);
        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));
        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
        if (context !== selection) {
            path = path.transition(context);
            tick = tick.transition(context);
            line = line.transition(context);
            text = text.transition(context);
            tickExit = tickExit.transition(context)
                .attr("opacity", epsilon)
                .attr("transform", function (d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });
            tickEnter
                .attr("opacity", epsilon)
                .attr("transform", function (d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
        }
        tickExit.remove();
        path
            .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));
        tick
            .attr("opacity", 1)
            .attr("transform", function (d) { return transform(position(d)); });
        line
            .attr(x + "2", k * tickSizeInner);
        text
            .attr(x, k * spacing)
            .text(format);
        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
        selection
            .each(function () { this.__axis = position; });
    }
    axis.scale = function (_) {
        return arguments.length ? (scale = _, axis) : scale;
    };
    axis.ticks = function () {
        return tickArguments = slice.call(arguments), axis;
    };
    axis.tickArguments = function (_) {
        return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
    };
    axis.tickValues = function (_) {
        return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
    };
    axis.tickFormat = function (_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
    };
    axis.tickSize = function (_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
    };
    axis.tickSizeInner = function (_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
    };
    axis.tickSizeOuter = function (_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
    };
    axis.tickPadding = function (_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
    };
    return axis;
}
function axisBottom(scale) {
    return axis(bottom, scale);
}
function axisLeft(scale) {
    return axis(left, scale);
}
function formatDecimal$1(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
}
// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts$1(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
        return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}
function exponent$1(x) {
    return x = formatDecimalParts$1(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup$1(grouping, thousands) {
    return function (value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while (i > 0 && g > 0) {
            if (length + g + 1 > width)
                g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width)
                break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}
function formatNumerals$1(numerals) {
    return function (value) {
        return value.replace(/[0-9]/g, function (i) {
            return numerals[+i];
        });
    };
}
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier$1(specifier) {
    if (!(match = re$1.exec(specifier)))
        throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier$1({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
    });
}
formatSpecifier$1.prototype = FormatSpecifier$1.prototype; // instanceof
function FormatSpecifier$1(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier$1.prototype.toString = function () {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
};
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim$1(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
            case ".":
                i0 = i1 = i;
                break;
            case "0":
                if (i0 === 0)
                    i0 = i;
                i1 = i;
                break;
            default:
                if (!+s[i])
                    break out;
                if (i0 > 0)
                    i0 = 0;
                break;
        }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent$1;
function formatPrefixAuto$1(x, p) {
    var d = formatDecimalParts$1(x, p);
    if (!d)
        return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
            : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
                : "0." + new Array(1 - i).join("0") + formatDecimalParts$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}
function formatRounded$1(x, p) {
    var d = formatDecimalParts$1(x, p);
    if (!d)
        return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
            : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var formatTypes$1 = {
    "%": function (x, p) { return (x * 100).toFixed(p); },
    "b": function (x) { return Math.round(x).toString(2); },
    "c": function (x) { return x + ""; },
    "d": formatDecimal$1,
    "e": function (x, p) { return x.toExponential(p); },
    "f": function (x, p) { return x.toFixed(p); },
    "g": function (x, p) { return x.toPrecision(p); },
    "o": function (x) { return Math.round(x).toString(8); },
    "p": function (x, p) { return formatRounded$1(x * 100, p); },
    "r": formatRounded$1,
    "s": formatPrefixAuto$1,
    "X": function (x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function (x) { return Math.round(x).toString(16); }
};
function identity$5(x) {
    return x;
}
var map$1 = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$2(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$5 : formatGroup$1(map$1.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? identity$5 : formatNumerals$1(map$1.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "−" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
    function newFormat(specifier) {
        specifier = formatSpecifier$1(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n")
            comma = true, type = "g";
        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes$1[type])
            precision === undefined && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "="))
            zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes$1[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
                : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            }
            else {
                value = +value;
                // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                var valueNegative = value < 0 || 1 / value < 0;
                // Perform the initial formatting.
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim)
                    value = formatTrim$1(value);
                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                if (valueNegative && +value === 0 && sign !== "+")
                    valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer “value” part that can be
                // grouped, and fractional or exponential “suffix” part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while (++i < n) {
                        if (c = value.charCodeAt(i), 48 > c || c > 57) {
                            valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                            value = value.slice(0, i);
                            break;
                        }
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero)
                value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero)
                value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch (align) {
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function () {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes$1[8 + e / 3];
        return function (value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}
var locale$2;
var format$1;
defaultLocale$2({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
});
function defaultLocale$2(definition) {
    locale$2 = formatLocale$2(definition);
    format$1 = locale$2.format;
    return locale$2;
}
var X_TICK_DISTANCE_PX = 100;
// Y ticks can be closer since the height of a label is much less than the max width of a label across multiple resolutions
var Y_TICK_DISTANCE_PX = 30;
var MIN_TICK_COUNT = 2;
var getTickCount = function (_a, _b) {
    var width = _a.width, height = _a.height;
    var yScaleType = _b.yScaleType;
    var xTickCount = Math.max(Math.floor(width / X_TICK_DISTANCE_PX), MIN_TICK_COUNT);
    var yTickCount = Math.max(Math.floor(height / (Y_TICK_DISTANCE_PX + (yScaleType === ScaleType.Log ? 60 : 0))), MIN_TICK_COUNT);
    return { xTickCount: xTickCount, yTickCount: yTickCount };
};
/**
 * Axis Display Constants
 */
var TICK_SIZE = 0;
var TICK_PADDING = 10;
var DEFAULT_AXIS_OPTIONS = {
    showX: true,
    showY: true,
};
/**
 *
 * Utils
 *
 */
var scales = function (size, viewport) {
    var xScale = time()
        .domain([viewport.start.getTime(), viewport.end.getTime()])
        .range([0, size.width]);
    var yScale = linear$1()
        .domain([viewport.yMin, viewport.yMax])
        .range([size.height, 0]);
    return {
        xScale: xScale,
        yScale: yScale,
    };
};
var tickCount = function (size) { return getTickCount({ width: size.width, height: size.height }, {
    xScaleSide: 'bottom',
    yScaleSide: 'left',
    yScaleType: ScaleType.Linear,
    xScaleType: ScaleType.Linear,
}); };
/**
 *
 * Axis Construction
 *
 */
var xAxisConstructor = function (size, viewport) {
    var xTickCount = tickCount(size).xTickCount;
    var xScale = scales(size, viewport).xScale;
    return axisBottom(xScale)
        .ticks(xTickCount)
        .tickPadding(TICK_PADDING)
        .tickSize(TICK_SIZE);
};
var yAxisConstructor = function (size, viewport) {
    var yTickCount = tickCount(size).yTickCount;
    var yScale = scales(size, viewport).yScale;
    return axisLeft(yScale)
        .ticks(yTickCount)
        .tickFormat(format$1('.2s'))
        .tickSize(-size.width)
        .tickPadding(TICK_PADDING);
};
/** D3 call to construct the X Axis */
var xAxisCall = function (size, viewport) { return function (selection) { return selection
    .attr('transform', "translate(" + size.marginLeft + ", " + (size.marginTop + size.height) + ")")
    .call(xAxisConstructor(size, viewport)); }; };
/** D3 call to construct the Y Axis */
var yAxisCall = function (size, viewport) { return function (selection) { return selection
    .attr('transform', "translate(" + size.marginLeft + ", " + size.marginTop + ")")
    .call(yAxisConstructor(size, viewport)); }; };
var renderAxis = function () {
    // Store axis element references to prevent re-querying DOM nodes on every render.
    var yAxis;
    var xAxisSeparator;
    var xAxis;
    var axisRenderer = function (_a) {
        var container = _a.container, viewport = _a.viewport, size = _a.size, axis = _a.axis;
        var sel = select(container);
        var _b = Object.assign(Object.assign({}, DEFAULT_AXIS_OPTIONS), axis), showX = _b.showX, showY = _b.showY, labels = _b.labels;
        if (!showX && xAxis && xAxisSeparator) {
            xAxis.remove();
            xAxis = null;
            xAxisSeparator.remove();
            xAxisSeparator = null;
        }
        if (!showY && yAxis) {
            yAxis.remove();
            yAxis = null;
        }
        if (showX && !xAxis) {
            // Adds the x axis separator between the chart and the y axis points
            sel
                .append('line')
                .attr('class', 'x-axis-separator')
                .attr('x1', size.marginLeft)
                .attr('y1', size.height + size.marginTop)
                .attr('x2', size.width + size.marginLeft)
                .attr('y2', size.height + size.marginTop);
            // Create X Axis
            sel
                .append('g')
                .attr('class', 'axis x-axis')
                .call(xAxisCall(size, viewport));
            // Note: We are assuming that axis within a component aren't destroyed and recreated.
            xAxis = select(container.querySelector('.x-axis'));
            xAxisSeparator = select(container.querySelector('.x-axis-separator'));
            if (!xAxis) {
                // This implies there's a issue in the utilization of this method. Should never occur.
                throw new Error('Failed to initialize the axis component');
            }
        }
        if (showY && !yAxis) {
            // Create Y Axis
            sel
                .append('g')
                .attr('class', 'axis y-axis')
                .call(yAxisCall(size, viewport));
            // Note: We are assuming that axis within a component aren't destroyed and recreated.
            yAxis = select(container.querySelector('.y-axis'));
            if (!yAxis) {
                // This implies there's a issue in the utilization of this method. Should never occur.
                throw new Error('Failed to initialize the axis component');
            }
        }
        if (xAxis) {
            xAxis.call(xAxisCall(size, viewport));
            /** Update X Axis Separator */
            if (xAxisSeparator) {
                xAxisSeparator
                    .attr('x1', size.marginLeft)
                    .attr('y1', size.height + size.marginTop)
                    .attr('x2', size.width + size.marginLeft)
                    .attr('y2', size.height + size.marginTop);
            }
        }
        if (yAxis) {
            /** Update Y Axis */
            if (labels && labels.yAxis) {
                var newContent_1 = labels.yAxis.content;
                var currentLabel = sel.select('.y-axis-label');
                if (currentLabel.empty() || newContent_1 !== currentLabel.text()) {
                    if (!currentLabel.empty()) {
                        currentLabel.remove();
                    }
                    sel
                        .append('text')
                        .attr('class', 'y-axis-label')
                        .attr('transform', 'translate(10, 10)')
                        .text(function () { return newContent_1; });
                }
            }
            yAxis.call(yAxisCall(size, viewport));
        }
    };
    return axisRenderer;
};
var orderOfMagnitude = function (n) {
    var o = Math.log10(Math.abs(n));
    return Math.ceil(o);
};
var roundedMagnitude = function (n) {
    var m = orderOfMagnitude(n);
    return n > 0 ? Math.pow(10, m) : -1 * Math.pow(10, m);
};
var DEFAULT_ROUNDING_DIVISOR = 50;
var roundedToNearest = function (rMag, n) { return function (roundUp) {
    var a = n / (rMag / DEFAULT_ROUNDING_DIVISOR);
    var b = rMag / DEFAULT_ROUNDING_DIVISOR;
    return roundUp ? Math.ceil(a) * b : Math.floor(a) * b;
}; };
var roundToOrderOfMagnitude = function (n, min) {
    if (n === 0) {
        return 0;
    }
    var roundedY = roundedToNearest(roundedMagnitude(n), n);
    return n < 0 ? roundedY(min) : roundedY(!min);
};
var DEFAULT_Y_RANGE = {
    yMax: 1000,
    yMin: 1,
};
var getBufferHeightByRange = function (yMin, yMax) {
    var bufferHeight = 0;
    // Adding padding such that the data's y-values are not flush with the view port
    if (yMax === yMin) {
        // Taking care of the case where yMax === yMin as well as a special case where both are 0
        bufferHeight = yMax !== 0 ? Math.abs(yMax * 0.5 /* SAME_VALUE */) : 0.5 /* SAME_VALUE */;
    }
    else {
        bufferHeight = (yMax - yMin) * 0.15 /* STANDARD */;
    }
    return bufferHeight;
};
var getYRangeWithBuffers = function (_a) {
    var yValues = _a.yValues, startFromZero = _a.startFromZero;
    if (yValues.length === 0) {
        return DEFAULT_Y_RANGE;
    }
    var dataRange = yValues.reduce(function (yRange, currentY) { return ({
        yMin: Math.min(currentY, yRange.yMin),
        yMax: Math.max(currentY, yRange.yMax),
    }); }, {
        yMin: Infinity,
        yMax: -Infinity,
    });
    var noNegativeValues = dataRange.yMin >= 0;
    var noPositiveValues = dataRange.yMax <= 0;
    var bufferHeight = getBufferHeightByRange(dataRange.yMin, dataRange.yMax);
    var yMax = dataRange.yMax + bufferHeight;
    var yMin = dataRange.yMin - bufferHeight;
    // Special case where yMax ans yMin is both zero. We will want to have padding.
    if (dataRange.yMax !== 0 || dataRange.yMin !== 0) {
        // If should start from zero and all in view points are positive, we set the yMin to zero
        if (startFromZero && noNegativeValues) {
            yMin = 0;
        }
        // If should start from zero and all in view points are negative, we set the yMax to zero.
        if (startFromZero && noPositiveValues) {
            yMax = 0;
        }
    }
    return {
        yMin: roundToOrderOfMagnitude(yMin, true),
        yMax: roundToOrderOfMagnitude(yMax, false),
    };
};
var getYRange = function (_a) {
    var points = _a.points, yAnnotations = _a.yAnnotations, startFromZero = _a.startFromZero;
    // Extract out Y values for each of the data set for normalization.
    var yDataValues = points.map(function (point) { return point.y; });
    var yAnnotationValues = yAnnotations.map(function (yAnnotation) { return yAnnotation.value; });
    return getYRangeWithBuffers({ yValues: __spreadArrays(yDataValues, yAnnotationValues), startFromZero: startFromZero });
};
/**
 * Provide messaging to clarify that the data/stream has invalid DataType(s)
 */
var UnsupportedDataTypeStatus = function (_a) {
    var supportedDataTypes = _a.supportedDataTypes, messageOverrides = _a.messageOverrides, size = _a.size;
    var width = size.width, height = size.height, marginLeft = size.marginLeft, marginRight = size.marginRight, marginTop = size.marginTop, marginBottom = size.marginBottom;
    return (h("div", { id: "unsupported-data-type-error", class: "unsupported-data-type-status", style: {
            width: width + marginLeft + marginRight + "px",
            height: height + marginBottom + marginTop + "px",
            padding: '24px',
            background: 'white',
            border: 'solid 4px black',
        } }, h("h2", null, messageOverrides.unsupportedDataTypeHeader || 'Unable to render your data'), h("h2", null, messageOverrides.unsupportedDataTypeSubHeader || 'This chart only supports the following DataType(s):'), h("div", null, messageOverrides.supportedTypes || supportedDataTypes.map(function (type) { return h("div", null, type); }))));
};
/**
 * Calculate new threshold value based on where the cursor is dragged
 * Returns the new threshold value and whether the viewport needs to be adjusted
 */
var calculateNewThreshold = function (_a) {
    var yPos = _a.yPos, viewport = _a.viewport, size = _a.size;
    var height = size.height;
    var yMax = viewport.yMax, yMin = viewport.yMin;
    var newVal = (height * yMax - yMax * yPos + yMin * yPos) / height;
    /** We truncate the newVal to 1/1000 of the axis scale to prevent unnecessary precision */
    var yAxisScale = (yMax - yMin) / 1000;
    var decimalDigits = Math.log(yAxisScale) / Math.log(10);
    return +newVal.toFixed(decimalDigits >= 0 ? 0 : -decimalDigits);
};
var needAxisRescale = function (_a) {
    var annotationValue = _a.annotationValue, viewport = _a.viewport;
    var yMax = viewport.yMax, yMin = viewport.yMin;
    var lowerThreshold = yMin + 0.01 * (yMax - yMin);
    var upperThreshold = yMin + 0.99 * (yMax - yMin);
    return annotationValue < lowerThreshold || annotationValue > upperThreshold;
};
var FOCUS_TRANSITION_TIME = 100; // milliseconds of the focus mode transition
var FOCUS_OPACITY = 0.32; // the opacity of the other handles that are not selected for dragging
var UPDATE_THROTTLE_MS = 90;
/**
 * Given a annotation container, it will mask by change the opacity of all Y annotation that is not
 * the currentDraggedAnnotation
 */
var maskNonDraggedAnnotations = function (_a) {
    var on = _a.on, container = _a.container, currentDraggedAnnotation = _a.currentDraggedAnnotation;
    select(container)
        .selectAll(ANNOTATION_GROUP_SELECTOR_EDITABLE + "," + ANNOTATION_GROUP_SELECTOR$1)
        .filter(function (annotation) { return annotation !== currentDraggedAnnotation; })
        .transition()
        .duration(FOCUS_TRANSITION_TIME)
        .attr('opacity', on ? FOCUS_OPACITY : 1);
};
/**
 * Draggable Thresholds Feature
 */
var attachDraggable = function () {
    var draggedAnnotationValue; // this is necessary to prevent race condition (new annotation value) from occurring during the drag process
    var internalUpdate = lodash_throttle(function (_a) {
        var onUpdate = _a[0], viewport = _a[1];
        onUpdate(viewport, false, false, true);
    }, UPDATE_THROTTLE_MS);
    var draggable = function (_a) {
        var container = _a.container, size = _a.size, onUpdate = _a.onUpdate, activeViewPort = _a.activeViewPort, emitUpdatedWidgetConfiguration = _a.emitUpdatedWidgetConfiguration, startStopDragging = _a.startStopDragging, dragHandle = _a.dragHandle, resolution = _a.resolution;
        var height = size.height;
        var getGroupPosition = function (annotation, viewport) {
            return "translate(0," + getY({ annotation: annotation, height: height, viewport: viewport }) + ")";
        };
        var getHandlePosition = function (annotation, viewport) {
            return getY({ annotation: annotation, height: height, viewport: viewport }) + HANDLE_OFFSET_Y;
        };
        dragHandle.call(drag()
            .on('start', function dragStarted(yAnnotation) {
            var annotationDragged = yAnnotation;
            if (!annotationDragged.isEditable) {
                return;
            }
            startStopDragging(true);
            draggedAnnotationValue = +annotationDragged.value;
            select(this).classed('active', true);
            maskNonDraggedAnnotations({
                container: container,
                on: true,
                currentDraggedAnnotation: yAnnotation,
            });
        })
            .on('drag', function handleDragged(yAnnotation) {
            /** Drag Event */
            var annotationDragged = yAnnotation;
            if (!annotationDragged.isEditable) {
                return;
            }
            var viewport = activeViewPort();
            var yPos = event.y;
            var draggedValue = calculateNewThreshold({ yPos: yPos, viewport: viewport, size: size });
            annotationDragged.value = draggedValue;
            draggedAnnotationValue = draggedValue;
            // re-rendering of everything except annotation movement
            var axisRescale = needAxisRescale({ annotationValue: annotationDragged.value, viewport: viewport });
            if (axisRescale) {
                // prevent the user from dragging off the page
                onUpdate(viewport, false, axisRescale, true);
                viewport = activeViewPort();
            }
            else {
                internalUpdate([onUpdate, viewport]);
            }
            // Update draggable annotation element groups
            select(container)
                .selectAll(ANNOTATION_GROUP_SELECTOR_EDITABLE)
                .selectAll(ELEMENT_GROUP_SELECTOR)
                .attr('transform', function (annotation) { return getGroupPosition(annotation, viewport); });
            // Update draggable annotation handles
            select(container)
                .selectAll(DRAGGABLE_HANDLE_SELECTOR)
                .attr('y', function (annotation) { return getHandlePosition(annotation, viewport); });
            // Update all annotation text values
            select(container)
                .selectAll(ANNOTATION_GROUP_SELECTOR_EDITABLE + "," + ANNOTATION_GROUP_SELECTOR$1)
                .select(TEXT_VALUE_SELECTOR)
                .text(function (annotation) { return getValueText({ annotation: annotation, resolution: resolution, viewport: viewport, formatText: true }); });
            // Update non-draggable annotation groups
            select(container)
                .selectAll(ANNOTATION_GROUP_SELECTOR$1)
                .attr('transform', function (annotation) { return getGroupPosition(annotation, viewport); });
        })
            .on('end', function dragEnded(yAnnotation) {
            var annotationDragged = yAnnotation;
            if (!annotationDragged.isEditable) {
                return;
            }
            annotationDragged.value = draggedAnnotationValue != null ? draggedAnnotationValue : annotationDragged.value;
            var viewport = activeViewPort();
            /** emit event updating annotation on mouse up */
            emitUpdatedWidgetConfiguration();
            var axisRescale = needAxisRescale({ annotationValue: annotationDragged.value, viewport: viewport });
            onUpdate(viewport, false, axisRescale, true);
            select(this).classed('active', false);
            startStopDragging(false);
            maskNonDraggedAnnotations({
                container: container,
                on: false,
                currentDraggedAnnotation: yAnnotation,
            });
        }));
    };
    return draggable;
};
var scWebglBaseChartCss = "sc-webgl-base-chart .sc-webgl-base-chart{height:0}sc-webgl-base-chart .empty-status{z-index:11;position:absolute;width:100%;height:100%;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;text-align:center;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;pointer-events:none;color:var(--light-text);font-size:var(--font-size-1)}sc-webgl-base-chart .empty-status h3{font-size:var(--font-size-3);line-height:var(--line-height-3);padding-bottom:var(--font-size-2);font-weight:normal}sc-webgl-base-chart .data-container{position:absolute}sc-webgl-base-chart .selection{fill:rgba(41, 168, 221, var(--selection-opacity));stroke-width:var(--selection-width);stroke:var(--selection-color);stroke-opacity:var(--selection-opacity);z-index:11}sc-webgl-base-chart .chart-legend-container{-ms-overflow-style:none;scrollbar-width:none}sc-webgl-base-chart .chart-legend-container::-webkit-scrollbar{display:none}sc-webgl-base-chart .threshold-container{z-index:5;position:absolute;pointer-events:none;font-size:12px}sc-webgl-base-chart .trend-container{z-index:4;position:absolute;pointer-events:none}";
var MIN_WIDTH = 50;
var MIN_HEIGHT = 50;
var LEGEND_HEIGHT = 100;
var DEFAULT_SHOW_DATA_STREAM_COLOR = true;
var ScWebglBaseChart = /** @class */ (function () {
    function ScWebglBaseChart(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.widgetUpdated = createEvent(this, "widgetUpdated", 7);
        this.dateRangeChange = createEvent(this, "dateRangeChange", 7);
        this.isEditing = false;
        this.renderLegend = function (props) { return h("sc-legend", Object.assign({}, props)); };
        this.annotations = {};
        this.trends = [];
        this.displaysError = true;
        this.supportedDataTypes = Object.values(DataType);
        this.yRangeStartFromZero = false;
        // Utilized to trigger a re-render once the data container is present to allow the
        // tooltip component to be properly rendered.
        this.isMounted = false;
        /**
         * Active View Port Config
         */
        this.yMin = this.viewport.yMin || 0;
        this.yMax = this.viewport.yMax || 100;
        // NOTE: If a start and end date are not provided, that means we are in 'live' mode
        this.start = isMinimalStaticViewport(this.viewport)
            ? new Date(this.viewport.start)
            : new Date(Date.now() - parseDuration(this.viewport.duration));
        this.end = isMinimalStaticViewport(this.viewport) ? new Date(this.viewport.end) : new Date();
        this.trendResults = [];
        this.axisRenderer = renderAxis();
        this.draggable = attachDraggable();
        this.isDragging = false;
        this.startStopDragging = function (dragState) {
            _this.isDragging = dragState;
        };
        this.inDragState = function () {
            return _this.isDragging;
        };
        this.getAxisContainer = function () {
            if (!_this.axisContainer) {
                // Grab the svg within `<sc-webgl-axis />` component
                _this.axisContainer = _this.el.querySelector('svg.axis');
            }
            return _this.axisContainer;
        };
        /**
         * Emit the current widget configuration
         */
        this.emitUpdatedWidgetConfiguration = function (dataStreams) {
            var configUpdate = {
                movement: undefined,
                scale: undefined,
                layout: undefined,
                legend: _this.legend,
                annotations: _this.internalAnnotations,
                axis: _this.axis,
                widgetId: _this.configId,
                dataStreams: dataStreams ? getDataStreamForEventing(dataStreams) : _this.dataStreams,
            };
            _this.widgetUpdated.emit(configUpdate);
        };
        /**
         * On Widget Updated - Persist `DataStreamInfo`
         *
         * Emits an event which persists the current `NameValue[]` state into the
         * data stream.
         */
        this.updateDataStreamName = function (_a) {
            var streamId = _a.streamId, name = _a.name;
            var updatedDataStreams = _this.dataStreams.map(function (dataStream) {
                return Object.assign(Object.assign({}, dataStream), { name: dataStream.id === streamId ? name : dataStream.name });
            });
            _this.emitUpdatedWidgetConfiguration(updatedDataStreams);
        };
        this.onDateRangeChange = lodash_throttle(function (_a) {
            var start = _a[0], end = _a[1], from = _a[2];
            _this.dateRangeChange.emit([start, end, from]);
        }, DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.chartSizeConfig = function () {
            var size = _this.chartSize();
            var marginTop = size.marginTop, marginBottom = size.marginBottom, marginLeft = size.marginLeft, marginRight = size.marginRight, height = size.height, width = size.width;
            var chartHeight = height - marginBottom - marginTop;
            var isRightLegend = _this.legend && _this.legend.position === LEGEND_POSITION.RIGHT;
            var isBottomLegend = _this.legend && _this.legend.position === LEGEND_POSITION.BOTTOM;
            return Object.assign(Object.assign({}, size), { width: Math.max(width - marginLeft - marginRight - (isRightLegend ? _this.legend.width : 0), MIN_WIDTH), height: chartHeight - (isBottomLegend ? LEGEND_HEIGHT : 0) });
        };
        /**
         * Get Active View Port
         *
         * Returns a view port with the current y range applied.
         * This can differ from the view port passed in, as
         * translations to the y range are only applied locally
         * as opposed to being applied via config changes from above.
         */
        this.activeViewPort = function () { return ({
            start: _this.start,
            end: _this.end,
            yMin: _this.yMin,
            yMax: _this.yMax,
            group: _this.viewport.group,
            duration: !isMinimalStaticViewport(_this.viewport) ? parseDuration(_this.viewport.duration) : undefined,
        }); };
        this.handleCameraEvent = function (_a) {
            var start = _a.start, end = _a.end;
            if (_this.scene) {
                var oldViewport = { yMin: _this.yMin, yMax: _this.yMax, start: start, end: end };
                if (_this.shouldRerenderOnViewportChange &&
                    _this.shouldRerenderOnViewportChange({ oldViewport: oldViewport, newViewport: _this.activeViewPort() })) {
                    _this.onUpdate({ start: start, end: end }, false, false, false, true);
                }
                // Update Camera
                webGLRenderer.updateViewPorts({ start: start, end: end, manager: _this.scene });
            }
        };
        /**
         * Updates the active view port y range.
         */
        this.updateYRange = function () {
            // Filter down the data streams to only contain data within the viewport
            var inViewPoints = _this.dataStreams
                .filter(isNumberDataStream)
                .map(function (stream) { return getVisibleData(getDataPoints(stream, stream.resolution), { start: _this.start, end: _this.end }, false); })
                .flat();
            var yAnnotations = (_this.internalAnnotations && Array.isArray(_this.internalAnnotations.y) && _this.internalAnnotations.y) || [];
            var _a = getYRange({
                points: inViewPoints,
                yAnnotations: yAnnotations.filter(function (annotation) { return isNumeric(annotation.value); }),
                startFromZero: _this.yRangeStartFromZero,
            }), yMin = _a.yMin, yMax = _a.yMax;
            var prevYMin = _this.yMin;
            var prevYMax = _this.yMax;
            /** Update active viewport. */
            _this.yMin = _this.viewport.yMin != null ? _this.viewport.yMin : yMin;
            _this.yMax = _this.viewport.yMax != null ? _this.viewport.yMax : yMax;
            var oldViewport = { yMin: prevYMin, yMax: prevYMax, start: _this.start, end: _this.end };
            if (_this.shouldRerenderOnViewportChange &&
                _this.shouldRerenderOnViewportChange({ oldViewport: oldViewport, newViewport: _this.activeViewPort() })) {
                _this.onUpdate(_this.activeViewPort(), false, false, false, true);
            }
            _this.applyYRangeChanges();
        };
        /**
         * Apply Y Range Changes
         *
         * Updates the scene camera to point to the correct location
         */
        this.applyYRangeChanges = function () {
            if (_this.scene) {
                /** Update threejs camera to have the updated viewport */
                _this.scene.camera.top = _this.yMax;
                _this.scene.camera.bottom = _this.yMin;
                // NOTE: This is required to make the changes to the camera take effect.
                // This updates the matricies which represent the cameras transformation.
                // This is done by setting a uniform for the shaders which are referenced to the
                // vertex shaders to translate and skew the coordinate space.
                _this.scene.camera.updateProjectionMatrix();
            }
        };
        /**
         * Container Helpers
         *
         * Help provide an efficient way to have the correct mount point on the DOM.
         * We want to prevent the DOM from being re-queried for performance concerns.
         */
        this.getDataContainer = function () {
            if (_this.dataContainer == null) {
                _this.dataContainer = _this.el.querySelector('.data-container');
            }
            return _this.dataContainer;
        };
        this.getThresholdContainer = function () {
            if (_this.thresholdContainer == null) {
                _this.thresholdContainer = _this.el.querySelector('.threshold-container');
            }
            return _this.thresholdContainer;
        };
        this.getTrendContainer = function () {
            if (_this.trendContainer == null) {
                _this.trendContainer = _this.el.querySelector('.trend-container');
            }
            return _this.trendContainer;
        };
        this.getHasSupportedData = function () {
            return _this.dataStreams.every(function (_a) {
                var streamType = _a.streamType, dataType = _a.dataType;
                return streamType === StreamType.ALARM || _this.supportedDataTypes.includes(dataType);
            });
        };
        this.thresholds = function () { return _this.internalAnnotations && _this.internalAnnotations.y ? _this.internalAnnotations.y.filter(isThreshold) : []; };
        this.getThresholdOptions = function () {
            // If user did not pass in any threshold options, we just use default
            if (_this.internalAnnotations == null || _this.internalAnnotations.thresholdOptions == null) {
                return DEFAULT_THRESHOLD_OPTIONS;
            }
            var thresholdOptions = _this.internalAnnotations.thresholdOptions;
            // if threshold option is a type of bool, it means that we either turn on all defaults or
            // disable all defaults.
            if (typeof thresholdOptions === 'boolean') {
                return thresholdOptions ? DEFAULT_THRESHOLD_OPTIONS : DEFAULT_THRESHOLD_OPTIONS_OFF;
            }
            // If its a threshold object, then we just use the user's setting and override it with the default settings
            // that we have
            return Object.assign(Object.assign({}, DEFAULT_THRESHOLD_OPTIONS), thresholdOptions);
        };
        /**
         * Lifecycle method
         *
         * Called every time the component mounts, or has it's data, viewport, or size changed.
         *
         * Provide no `hasDataChanged` to prevent a re-processing of the chart scenes.
         */
        this.onUpdate = function (_a, hasDataChanged, hasSizeChanged, hasAnnotationChanged, shouldRerender) {
            var start = _a.start, end = _a.end, shouldBlockDateRangeChangedEvent = _a.shouldBlockDateRangeChangedEvent;
            if (hasDataChanged === void 0) { hasDataChanged = false; }
            if (hasSizeChanged === void 0) { hasSizeChanged = false; }
            if (hasAnnotationChanged === void 0) { hasAnnotationChanged = false; }
            if (shouldRerender === void 0) { shouldRerender = false; }
            /**
             * Failure Handling
             */
            // avoid updating if dataStream has unsupported data
            if (!_this.getHasSupportedData())
                return;
            // why do we have this condition?
            // - if one of the watched props e.g. dataStreams changes this will call onUpdate
            // - if the component unmounts before this this.scene is set to null
            // - if we do not have a scene or a component to render it in we should bail
            if (!_this.scene && !_this.el.isConnected)
                return;
            if (!_this.el.isConnected && _this.scene) {
                // Disconnected failure case:
                // This can occur in very 'stressed' performance situations where updates get called
                // and then a chart is disconnected. We can recover from this by removing itself
                // from the view port manager and bailing on the update.
                /* eslint-disable-next-line no-console */
                console.error("[SynchroCharts] chart with associated scene id of " + _this.scene.id + " is disconnected,\n         but still being called via the view port manager. removing from the view port manager.");
                // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
                webGLRenderer.removeChartScene(_this.scene.id);
                _this.scene = null;
                return;
            }
            if (!_this.scene) {
                // This should never occur - if it does, it's not recoverable so we just bail.
                throw new Error('[SynchroCharts] Scene is not present but update is being called.');
            }
            /**
             * Update Procedure
             */
            var hasViewPortChanged = _this.start.getTime() !== start.getTime() || _this.end.getTime() !== end.getTime();
            if (hasViewPortChanged && !shouldBlockDateRangeChangedEvent) {
                _this.onDateRangeChange([start, end, _this.viewport.group]);
            }
            // Update Active Viewport
            _this.start = start;
            _this.end = end;
            if (!_this.supportString && !shouldRerender) {
                _this.updateYRange();
            }
            // Render chart scene
            _this.updateAndRegisterChartScene({
                hasDataChanged: hasDataChanged,
                hasSizeChanged: hasSizeChanged,
                hasAnnotationChanged: hasAnnotationChanged,
                shouldRerender: shouldRerender,
            });
            // settings to utilize in all feature updates.
            var viewport = _this.activeViewPort();
            var size = _this.chartSizeConfig();
            if (_this.onUpdateLifeCycle) {
                // Call all passed in updates - custom features
                _this.onUpdateLifeCycle(_this.activeViewPort());
            }
            /**
             *
             * Features
             *
             * Place custom features which are built into the chart at the base level here.
             * Non-base chart features should instead be delegated via the `onUpdateLifeCycle` hook.
             */
            /**
             * Annotations Feature
             *
             * Currently only supports rendering annotations for number data streams
             */
            if (!_this.supportString) {
                var numberAnnotations = getNumberAnnotations(_this.internalAnnotations);
                renderAnnotations({
                    container: _this.getThresholdContainer(),
                    annotations: numberAnnotations,
                    viewport: viewport,
                    size: size,
                    // TODO: Revisit this.
                    // If no data streams are present we will fallback to a resolution of 0, i.e. 'raw' data
                    resolution: _this.dataStreams[0] ? _this.dataStreams[0].resolution : 0,
                    onUpdate: _this.onUpdate,
                    activeViewPort: _this.activeViewPort,
                    emitUpdatedWidgetConfiguration: _this.emitUpdatedWidgetConfiguration,
                    draggable: _this.draggable,
                    startStopDragging: _this.startStopDragging,
                    inDragState: _this.inDragState,
                });
            }
            /**
             * Trend Lines Feature
             *
             * Currently only supports rendering trends for number data streams
             */
            if (!_this.supportString) {
                var dataStreamsWithTrends = _this.visualizedDataStreams().filter(isNumberDataStream);
                _this.trendResults = getAllTrendResults(viewport, dataStreamsWithTrends, _this.trends);
                renderTrendLines({
                    container: _this.getTrendContainer(),
                    viewport: viewport,
                    size: size,
                    dataStreams: _this.visualizedDataStreams(),
                    trendResults: _this.trendResults,
                });
            }
            /**
             * Axis Feature
             */
            _this.axisRenderer({
                container: _this.getAxisContainer(),
                viewport: viewport,
                size: size,
                axis: _this.axis,
            });
        };
        /**
         * Set Chart Rendering Position
         *
         * Registers the chart rectangle, which tells webGL where to render the data-vizualization to.
         * This must be called each time after a scene is set.
         *
         */
        this.setChartRenderingPosition = function () {
            if (_this.scene) {
                var chartSize = _this.chartSizeConfig();
                webGLRenderer.setChartRect(_this.scene.id, {
                    width: chartSize.width,
                    height: chartSize.height,
                    x: _this.size.x + chartSize.marginLeft,
                    y: _this.size.y + chartSize.marginTop,
                    left: _this.size.left + chartSize.marginLeft,
                    top: _this.size.top + chartSize.marginTop,
                    right: _this.size.left + chartSize.marginLeft + chartSize.width,
                    bottom: _this.size.top + chartSize.marginTop + chartSize.height,
                    density: window.devicePixelRatio,
                });
            }
        };
        this.chartSize = function () {
            var marginLeft = _this.size.marginLeft == null ? DEFAULT_CHART_CONFIG.size.marginLeft : _this.size.marginLeft;
            var marginRight = _this.size.marginRight == null ? DEFAULT_CHART_CONFIG.size.marginRight : _this.size.marginRight;
            var marginTop = _this.size.marginTop == null ? DEFAULT_CHART_CONFIG.size.marginTop : _this.size.marginTop;
            var marginBottom = _this.size.marginBottom == null ? DEFAULT_CHART_CONFIG.size.marginBottom : _this.size.marginBottom;
            var minWidth = marginLeft + marginRight + MIN_WIDTH;
            var minHeight = marginTop + marginBottom + MIN_HEIGHT;
            return {
                marginLeft: marginLeft,
                marginRight: marginRight,
                marginTop: marginTop,
                marginBottom: marginBottom,
                width: Math.max(_this.size.width, minWidth),
                height: Math.max(_this.size.height, minHeight),
            };
        };
        this.renderTooltipComponent = function (marginLeft, marginTop, thresholds) { return _this.renderTooltip({
            size: _this.chartSizeConfig(),
            style: { marginLeft: marginLeft + "px", marginTop: marginTop + "px" },
            dataStreams: _this.dataStreams,
            viewport: _this.activeViewPort(),
            dataContainer: _this.getDataContainer(),
            thresholds: thresholds,
            trendResults: _this.trendResults,
            visualizesAlarms: _this.visualizesAlarms,
        }); };
        this.renderLegendComponent = function (_a) {
            var isLoading = _a.isLoading, thresholds = _a.thresholds, showDataStreamColor = _a.showDataStreamColor;
            return _this.renderLegend({
                config: _this.legend,
                dataStreams: _this.dataStreams,
                visualizesAlarms: _this.visualizesAlarms,
                updateDataStreamName: _this.updateDataStreamName,
                viewport: _this.activeViewPort(),
                isEditing: _this.isEditing,
                isLoading: isLoading,
                thresholds: thresholds,
                supportString: _this.supportString,
                trendResults: _this.trendResults,
                showDataStreamColor: showDataStreamColor,
            });
        };
    }
    ScWebglBaseChart.prototype.componentDidLoad = function () {
        // Why do we have this condition?
        //  - If componentDidUnload is called before componentDidLoad this.el.isConnected will be false
        //  - This can happen when scrolling page very quickly
        //  - If the component is unmounted before this.setupChartScene is complete we run into a race condition
        //  where the scene gets created and assigned to this.scene but we override it with null before
        //  this.setupChartScene calls this.onUpdate
        //  - Without the component mounted there is no point in calling onUpdate since we have nowhere to render this.scene
        if (this.el.isConnected) {
            this.setupChartScene();
            this.isMounted = true;
        }
    };
    ScWebglBaseChart.prototype.componentWillLoad = function () {
        if (!this.isDragging) {
            this.setInternalAnnotations();
        }
    };
    ScWebglBaseChart.prototype.setInternalAnnotations = function () {
        // Internal annotations are mutated, so we clone it to prevent altering the inputs.
        this.internalAnnotations = lodash_clonedeep(this.annotations);
    };
    /**
     * Visualized Data Streams
     *
     * Returns the data streams we want to directly visualize
     * Depending on if visualizeAlarms is false, this will filter out alarm data.
     */
    ScWebglBaseChart.prototype.visualizedDataStreams = function () {
        if (this.visualizesAlarms) {
            return this.dataStreams;
        }
        return this.dataStreams.filter(function (_a) {
            var streamType = _a.streamType;
            return streamType !== StreamType.ALARM;
        });
    };
    ScWebglBaseChart.prototype.onViewPortChange = function (newViewPort, oldViewPort) {
        if (this.scene && !lodash_isequal(newViewPort, oldViewPort)) {
            var hasYRangeChanged = newViewPort.yMin !== oldViewPort.yMin || newViewPort.yMax !== oldViewPort.yMax;
            if (hasYRangeChanged) {
                /** Update active viewport. */
                this.yMin = newViewPort.yMin;
                this.yMax = newViewPort.yMax;
                /** Apply Changes */
                this.applyYRangeChanges();
            }
            // All charts are correctly synced.
            /** Update active viewport */
            this.start = isMinimalStaticViewport(newViewPort)
                ? new Date(newViewPort.start)
                : new Date(Date.now() - parseDuration(newViewPort.duration));
            this.end = isMinimalStaticViewport(newViewPort) ? new Date(newViewPort.end) : new Date();
            /**
             * Updates viewport to the active viewport
             */
            this.scene.updateViewPort(this.activeViewPort());
            /** Re-render scene */
            // This is a necessary call to ensure that the view port group is correctly set.
            // If `updateViewPorts` is **not** called, `updateAndRegisterChartScene` in an edge case may
            // re-create the chart resources, and set the new viewport equal to the view port groups stale viewport.
            webGLRenderer.updateViewPorts({
                start: this.start,
                end: this.end,
                manager: this.scene,
                duration: this.activeViewPort().duration,
            });
            this.updateAndRegisterChartScene({
                hasDataChanged: false,
                hasSizeChanged: false,
                hasAnnotationChanged: false,
                shouldRerender: false,
            });
            if (this.shouldRerenderOnViewportChange &&
                this.shouldRerenderOnViewportChange({ oldViewport: oldViewPort, newViewport: newViewPort })) {
                this.onUpdate({ start: this.start, end: this.end }, false, false, false, true);
            }
        }
        var duration = this.activeViewPort().duration;
        if (this.scene != null && duration != null) {
            webGLRenderer.stopTick({ manager: this.scene });
            webGLRenderer.startTick({ manager: this.scene, duration: duration, chartSize: this.chartSizeConfig() });
        }
    };
    ScWebglBaseChart.prototype.onSizeChange = function (newProp, oldProp) {
        // NOTE: Change of legend can effect sizing
        if (!lodash_isequal(newProp, oldProp)) {
            this.onUpdate(this.activeViewPort(), false, true);
        }
        // Since internal clocks are depended on width, when we detect a width change, we want to re-start the timer.
        if (newProp.width != null && newProp.width !== oldProp.width) {
            var duration = this.activeViewPort().duration;
            if (this.scene != null && duration != null) {
                webGLRenderer.stopTick({ manager: this.scene });
                webGLRenderer.startTick({ manager: this.scene, duration: duration, chartSize: this.chartSizeConfig() });
            }
        }
    };
    ScWebglBaseChart.prototype.onDataStreamsChange = function () {
        // Avoiding a deep equality check due to the cost on a potentially large object.
        this.onUpdate(this.activeViewPort(), true);
    };
    ScWebglBaseChart.prototype.onAnnotationsChange = function (newProp, oldProp) {
        if (!lodash_isequal(newProp, oldProp) && !this.isDragging) {
            this.setInternalAnnotations();
            this.onUpdate(this.activeViewPort(), false, false, true);
        }
    };
    ScWebglBaseChart.prototype.onTrendsChange = function (newProp, oldProp) {
        if (!lodash_isequal(newProp, oldProp)) {
            this.onUpdate(this.activeViewPort(), false);
        }
    };
    ScWebglBaseChart.prototype.onAxisChange = function (newProp, oldProp) {
        var viewport = this.activeViewPort();
        var size = this.chartSizeConfig();
        if (!lodash_isequal(newProp, oldProp)) {
            this.axisRenderer({
                container: this.getAxisContainer(),
                viewport: viewport,
                size: size,
                axis: this.axis,
            });
        }
    };
    // NOTE: While `componentDidUnload` is deprecated, `disconnectedCallback` causes critical issues
    //       causing orphaned updates to occur, where no `scene` is present.
    ScWebglBaseChart.prototype.componentDidUnload = function () {
        if (this.scene) {
            // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
            webGLRenderer.removeChartScene(this.scene.id);
        }
        this.scene = null;
    };
    ScWebglBaseChart.prototype.setupChartScene = function () {
        this.scene = this.createChartScene({
            viewport: this.activeViewPort(),
            chartSize: this.chartSizeConfig(),
            dataStreams: this.visualizedDataStreams(),
            alarms: this.alarms,
            container: this.getDataContainer(),
            minBufferSize: this.minBufferSize,
            bufferFactor: this.bufferFactor,
            onUpdate: this.onUpdate,
            thresholdOptions: this.getThresholdOptions(),
            thresholds: this.thresholds(),
        });
        var duration = this.activeViewPort().duration;
        webGLRenderer.addChartScene({ manager: this.scene, duration: duration, chartSize: this.chartSizeConfig() });
        this.setChartRenderingPosition();
        webGLRenderer.render(this.scene);
        this.onUpdate(this.activeViewPort());
    };
    /**
     * Update and register chart scene
     *
     * handles the updating of the chart scene, and handles registering the new
     * chart scene if a new chart scene is returned.
     *
     * A new chart scene will be returned if the new data passed in has
     * more data points that the previous chart scene had room allocated for.
     */
    ScWebglBaseChart.prototype.updateAndRegisterChartScene = function (_a) {
        var _this = this;
        var hasDataChanged = _a.hasDataChanged, hasSizeChanged = _a.hasSizeChanged, hasAnnotationChanged = _a.hasAnnotationChanged, shouldRerender = _a.shouldRerender;
        if (this.scene) {
            if (hasSizeChanged) {
                this.setChartRenderingPosition();
            }
            var container = this.getDataContainer();
            var updatedScene = this.updateChartScene({
                scene: this.scene,
                chartSize: this.chartSizeConfig(),
                dataStreams: this.visualizedDataStreams(),
                alarms: this.alarms,
                container: container,
                viewport: this.activeViewPort(),
                minBufferSize: this.minBufferSize,
                bufferFactor: this.bufferFactor,
                onUpdate: this.onUpdate,
                thresholdOptions: this.getThresholdOptions(),
                thresholds: this.thresholds(),
                hasSizeChanged: hasSizeChanged,
                hasDataChanged: hasDataChanged,
                shouldRerender: shouldRerender,
                hasAnnotationChanged: hasAnnotationChanged,
            });
            // update chart scene will return a new scene if it needed to delete the old one to make
            // the changes necessary and reconstruct a entirely new scene in it's place.
            // in this scenario we need to remove it's old scene from the global chart registry within webGL Renderer.
            var isNewChartScene = updatedScene.id !== this.scene.id;
            if (isNewChartScene) {
                // Must unregister the previous chart scene and register the new one with webgl
                webGLRenderer.removeChartScene(this.scene.id);
                this.scene = updatedScene;
                var duration = this.activeViewPort().duration;
                webGLRenderer.addChartScene({
                    manager: updatedScene,
                    duration: duration,
                    shouldSync: false,
                    chartSize: this.chartSizeConfig(),
                });
                this.setChartRenderingPosition();
            }
            /** Render to canvas */
            webGLRenderer.render(this.scene);
            if (hasSizeChanged) {
                // if the size has changed, then we need to wait till the next 'frame'
                // until the DOM has updated to it's new position.
                window.setTimeout(function () {
                    if (_this.scene) {
                        webGLRenderer.render(_this.scene);
                    }
                }, 0);
            }
        }
    };
    ScWebglBaseChart.prototype.render = function () {
        var _this = this;
        var chartSizeConfig = this.chartSizeConfig();
        var marginLeft = chartSizeConfig.marginLeft, marginTop = chartSizeConfig.marginTop, marginRight = chartSizeConfig.marginRight, marginBottom = chartSizeConfig.marginBottom;
        var hasError = this.dataStreams.some(function (_a) {
            var error = _a.error;
            return error != null;
        });
        var shouldDisplayAsLoading = !hasError && this.visualizedDataStreams().some(function (_a) {
            var isLoading = _a.isLoading;
            return isLoading;
        });
        var hasNoDataStreamsPresent = this.visualizedDataStreams().length === 0;
        var hasNoDataPresent = this.visualizedDataStreams().every(function (stream) {
            var points = getDataPoints(stream, stream.resolution);
            if (points.length === 0) {
                return true;
            }
            // Check the latest datapoint to see if its before the start of viewport
            var isDataOutOfRange = points[points.length - 1].x < _this.start.getTime();
            return isDataOutOfRange;
        });
        var thresholds = this.thresholds();
        var showDataStreamColor = this.legend != null && this.legend.showDataStreamColor != null
            ? this.legend.showDataStreamColor
            : DEFAULT_SHOW_DATA_STREAM_COLOR;
        if (!this.getHasSupportedData()) {
            return (h("div", { class: "awsui sc-webgl-base-chart" }, h(UnsupportedDataTypeStatus, { size: chartSizeConfig, messageOverrides: this.messageOverrides || {}, supportedDataTypes: this.supportedDataTypes })));
        }
        return [
            h("div", { class: "awsui sc-webgl-base-chart" }, this.displaysError && h(ErrorStatus, { hasError: hasError, size: chartSizeConfig }), h("sc-webgl-axis", { size: chartSizeConfig }), h(DataContainer, { size: chartSizeConfig }, h(EmptyStatus, { displaysNoDataPresentMsg: this.displaysNoDataPresentMsg != null ? this.displaysNoDataPresentMsg : true, messageOverrides: this.messageOverrides || {}, isLoading: shouldDisplayAsLoading, hasNoDataPresent: hasNoDataPresent, hasNoDataStreamsPresent: hasNoDataStreamsPresent }), h(LoadingStatus, { isLoading: shouldDisplayAsLoading }), this.gestures && (h("sc-gesture-handler", { onDateRangeChange: this.handleCameraEvent, size: chartSizeConfig, viewport: this.activeViewPort() }))), this.legend && (h(ChartLegendContainer, { config: this.legend, legendHeight: LEGEND_HEIGHT, size: chartSizeConfig }, this.renderLegendComponent({ isLoading: shouldDisplayAsLoading, thresholds: thresholds, showDataStreamColor: showDataStreamColor })))),
            this.isMounted && this.renderTooltipComponent(marginLeft, marginTop, thresholds),
            h("svg", { class: "threshold-container", width: chartSizeConfig.width + marginRight, height: chartSizeConfig.height + marginBottom, style: { marginLeft: marginLeft + "px", marginTop: marginTop + "px" } }),
            h("svg", { class: "trend-container", width: chartSizeConfig.width, height: chartSizeConfig.height, style: { marginLeft: marginLeft + "px", marginTop: marginTop + "px" } }),
        ];
    };
    Object.defineProperty(ScWebglBaseChart.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScWebglBaseChart, "watchers", {
        get: function () {
            return {
                "viewport": ["onViewPortChange"],
                "size": ["onSizeChange"],
                "legend": ["onSizeChange"],
                "dataStreams": ["onDataStreamsChange"],
                "annotations": ["onAnnotationsChange"],
                "trends": ["onTrendsChange"],
                "axis": ["onAxisChange"]
            };
        },
        enumerable: false,
        configurable: true
    });
    return ScWebglBaseChart;
}());
ScWebglBaseChart.style = scWebglBaseChartCss;
var scWebglContextCss = "sc-webgl-context{--scroll-bar-size:16px;width:100%;height:100%;position:absolute;top:0;left:0;z-index:1;pointer-events:none}.webgl-context-canvas{position:absolute;left:0;top:0;width:100%;height:100%;max-width:100vw;max-height:100vh;display:block;pointer-events:none;z-index:10}.webgl-context-canvas-viewport{width:calc(100vw - var(--scroll-bar-size));height:calc(100vh - var(--scroll-bar-size))}";
var ScWebglContext = /** @class */ (function () {
    function ScWebglContext(hostRef) {
        registerInstance(this, hostRef);
    }
    ScWebglContext.prototype.componentDidLoad = function () {
        var canvas = this.el.querySelector('canvas');
        webGLRenderer.initRendering(canvas, this.onContextInitialization, this.viewFrame);
    };
    ScWebglContext.prototype.render = function () {
        var viewportViewFrame = this.viewFrame === undefined || this.viewFrame instanceof Window;
        var classes = "webgl-context-canvas " + (viewportViewFrame ? 'webgl-context-canvas-viewport' : '');
        return h("canvas", { class: classes });
    };
    Object.defineProperty(ScWebglContext.prototype, "el", {
        get: function () { return getElement(this); },
        enumerable: false,
        configurable: true
    });
    return ScWebglContext;
}());
ScWebglContext.style = scWebglContextCss;
export { ScChartIcon as sc_chart_icon, ScDataStreamName as sc_data_stream_name, ScErrorBadge as sc_error_badge, ScExpandableInput as sc_expandable_input, ScGestureHandler as sc_gesture_handler, ScLegend as sc_legend, ScLegendRow as sc_legend_row, ScLoadingSpinner as sc_loading_spinner, ScSizeProvider as sc_size_provider, ScTooltip as sc_tooltip, ScTooltipRow as sc_tooltip_row, ScTooltipRows as sc_tooltip_rows, ScWebglAxis as sc_webgl_axis, ScWebglBaseChart as sc_webgl_base_chart, ScWebglContext as sc_webgl_context };
