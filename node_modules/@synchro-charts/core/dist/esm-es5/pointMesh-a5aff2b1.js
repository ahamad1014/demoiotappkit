import { C as COMPARISON_OPERATOR } from './constants-35570903.js';
import { c as getNumberThresholds, s as sortThreshold, a as getBreachedThreshold } from './utils-96fe4147.js';
import { c as isNumberDataStream } from './predicates-67461267.js';
import { c as BufferGeometry, d as ShaderMaterial, P as Points, B as BufferAttribute } from './three.module-06da257a.js';
import { g as getCSSColorByString, n as numDataPoints, v as vertices } from './clipSpaceConversion-8273b9c5.js';
var pointVert = function (showColor) { return "\nvarying vec3 vColor;\n" + (showColor ? 'varying float positionY;' : '') + "\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  " + (showColor ? 'positionY = position.y;' : '') + "\n}\n"; };
var shaderFrag = "\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n";
/**
 * Max of 13 threshold bands because we allow only up to 12 thresholds. Imaging a piece of paper being split into
 * 12 times. You will end up with 13 different pieces.
 */
var MAX_THRESHOLD_BANDS = 13;
/**
 * First we sort the thresholds then reverse it. Reversing the sorted threshold allows us to create the band from
 * top to bottom.
 *
 * For each threshold that is not the first or the last, we check both upper and lower to see if a band is needed.
 *
 * Because we check against the previous threshold and the next threshold, a set is needed to prevent duplicates
 *
 * We know that all the threshold bands can only have unique upper, so we will be using that as the key in the Set.
 */
var thresholdBands = function (thresholds) {
    if (thresholds.length === 0) {
        return [];
    }
    var numberThresholds = getNumberThresholds(thresholds);
    var sortedThresholds = sortThreshold(numberThresholds).reverse();
    var bands = [];
    var thresholdBandsSet = new Set();
    sortedThresholds.forEach(function (threshold, index) {
        var thresholdValue = threshold.value;
        if (sortedThresholds[index].comparisonOperator === COMPARISON_OPERATOR.EQUAL) {
            var _a = getCSSColorByString(sortedThresholds[index].color), r = _a[0], g = _a[1], b = _a[2];
            bands.push({
                upper: thresholdValue,
                lower: thresholdValue,
                color: [r, g, b],
            });
            return;
        }
        /**
         * When looking at the first threshold, we want to find a mid point between the MAX SAFE INTEGER and the first
         * threshold value to determine if the first threshold is an upper bound threshold.
         */
        if (index === 0) {
            var midPoint_1 = (Number.MAX_SAFE_INTEGER + thresholdValue) / 2;
            var breachedThreshold_1 = getBreachedThreshold(midPoint_1, sortedThresholds);
            if (breachedThreshold_1 != null) {
                var _b = getCSSColorByString(breachedThreshold_1.color), r = _b[0], g = _b[1], b = _b[2];
                bands.push({
                    upper: Number.MAX_SAFE_INTEGER,
                    lower: thresholdValue,
                    color: [r, g, b],
                });
            }
            return;
        }
        /**
         * When looking at the thresholds that is not the first or the last, we want to compare it with the one before
         * to make sure if there is an upper band or not.
         */
        var prevThreshold = sortedThresholds[index - 1];
        var prevThresholdValue = prevThreshold.value;
        var midPoint = (prevThresholdValue + thresholdValue) / 2;
        var breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);
        if (breachedThreshold != null) {
            if (!thresholdBandsSet.has(prevThreshold.value)) {
                var _c = getCSSColorByString(breachedThreshold.color), r = _c[0], g = _c[1], b = _c[2];
                if (prevThreshold.comparisonOperator === COMPARISON_OPERATOR.EQUAL &&
                    prevThreshold.value === sortedThresholds[index].value) {
                    bands.push({
                        upper: prevThresholdValue,
                        lower: thresholdValue,
                        color: [r, g, b],
                    });
                }
                else {
                    bands.push({
                        upper: prevThresholdValue,
                        lower: thresholdValue,
                        color: [r, g, b],
                    });
                }
                thresholdBandsSet.add(prevThreshold.value);
            }
        }
        /**
         * When looking at the last threshold, we want to find the mid point between it and the Min Safe Int
         * to see if there is a lower band that needs to be create.
         */
        if (index === sortedThresholds.length - 1) {
            midPoint = (thresholdValue + Number.MIN_SAFE_INTEGER) / 2;
            breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);
            if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {
                var _d = getCSSColorByString(breachedThreshold.color), r = _d[0], g = _d[1], b = _d[2];
                bands.push({
                    lower: Number.MIN_SAFE_INTEGER,
                    upper: thresholdValue,
                    color: [r, g, b],
                });
            }
            return;
        }
        /**
         * When looking at a threshold that is not first or last, we want to compare it with the next one to see if
         * a lower band is needed.
         */
        var nexThreshold = sortedThresholds[index + 1];
        var nexThresholdValue = nexThreshold.value;
        midPoint = (thresholdValue + nexThresholdValue) / 2;
        breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);
        if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {
            var _e = getCSSColorByString(breachedThreshold.color), r = _e[0], g = _e[1], b = _e[2];
            bands.push({
                upper: thresholdValue,
                lower: nexThresholdValue,
                color: [r, g, b],
            });
            thresholdBandsSet.add(threshold.value);
        }
    });
    /**
     * Because we need to have a set amount of buffer in Frag, which is 12. If the array length is not 12,
     * we need to fill in the rest with proper threshold bands. It should be duplicates of the last threshold band
     *
     * This function also takes into account when there is only 1 threshold with lower bound.
     */
    var lastThresholdBand = bands[bands.length - 1];
    while (bands.length < MAX_THRESHOLD_BANDS) {
        var threshold = sortedThresholds[sortedThresholds.length - 1];
        var thresholdValue = threshold.value;
        var midPoint = Number.MIN_SAFE_INTEGER + thresholdValue / 2;
        var breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);
        if (breachedThreshold == null) {
            bands.push(lastThresholdBand);
        }
        else {
            var _a = getCSSColorByString(breachedThreshold.color), r = _a[0], g = _a[1], b = _a[2];
            lastThresholdBand = {
                lower: Number.MIN_SAFE_INTEGER,
                upper: thresholdValue,
                color: [r, g, b],
            };
            bands.push(lastThresholdBand);
        }
    }
    return bands;
};
var colorationShaderFrag = "\n#define MAX_NUM_TOTAL_THRESHOLD_BAND " + MAX_THRESHOLD_BANDS + "\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n";
/* eslint-disable no-param-reassign */
var POINT_MESH_INDEX = 0;
var POINT_DIAMETER = 6.25;
var RAW_POINT_DIAMETER = 4;
/**
 * Get the diameter of the points to display on the chart.
 *
 * We want to display points smaller for raw data since they may be displayed very densely
 */
var pointDiameter = function (dataStreams) {
    var resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;
    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;
};
/**
 * Create Point Mesh
 *
 * The representation of the points on a chart.
 */
// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated
// up front per `ChartScene`.
var NUM_POSITION_COMPONENTS = 2; // (x, y)
var NUM_COLOR_COMPONENTS = 3; // (r, g, b)
/**
 * Update Geometry
 *
 * Updates the color, and position of the vertices sent down to the vertex shader.
 */
var updateGeometry = function (geometry, dataStreams, toClipSpace) {
    var streamVertexSets = dataStreams.filter(isNumberDataStream).map(function (stream) { return vertices(stream, stream.resolution); });
    var allVertices = streamVertexSets.flat();
    var _a = geometry.attributes, position = _a.position, pointColor = _a.pointColor;
    /**
     * Fill Buffers with data
     */
    allVertices.forEach(function (_a, i) {
        var x = _a[0], y = _a[1], r = _a[2], g = _a[3], b = _a[4];
        // Set Position
        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);
        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;
        // Set Normal Data Stream Color
        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;
        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;
        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;
    });
    geometry.setDrawRange(0, allVertices.length);
    position.needsUpdate = true;
    pointColor.needsUpdate = true;
};
var initializeGeometry = function (geometry, bufferSize) {
    // TODO: Change to double precision
    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));
    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));
};
/**
 * Create Point Mesh
 */
var pointMesh = function (_a) {
    var toClipSpace = _a.toClipSpace, dataStreams = _a.dataStreams, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);
    var geometry = new BufferGeometry();
    initializeGeometry(geometry, bufferSize);
    updateGeometry(geometry, dataStreams, toClipSpace);
    var _b = thresholdOptions.showColor, showColor = _b === void 0 ? true : _b;
    var material = new ShaderMaterial({
        vertexShader: pointVert(showColor && thresholds.length > 0),
        fragmentShader: !showColor || thresholds.length === 0 ? shaderFrag : colorationShaderFrag,
        transparent: true,
        uniforms: {
            pointDiameter: {
                value: pointDiameter(dataStreams),
            },
            devicePixelRatio: {
                value: window.devicePixelRatio,
            },
            thresholdBands: {
                value: thresholdBands(thresholds),
            },
        },
    });
    var points = new Points(geometry, material);
    // Prevent computeBoundingSphere from being called
    points.frustumCulled = false;
    return points;
};
/**
 * Update Point Mesh
 *
 * Updates the point mesh to match the given data stream info and data streams.
 * Increases size of attribute buffers if necessary.
 */
var updatePointMesh = function (dataStreams, points, toClipSpace, hasDataChanged) {
    if (hasDataChanged === void 0) { hasDataChanged = true; }
    /**
     * Update Uniforms
     *
     * The uniforms are variables passed into the webgl Shaders.
     * Learn more about uniforms:
     * https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms
     */
    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);
    points.material.uniforms.devicePixelRatio.value = window.devicePixelRatio;
    if (hasDataChanged) {
        updateGeometry(points.geometry, dataStreams, toClipSpace);
    }
};
export { MAX_THRESHOLD_BANDS as M, NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, thresholdBands as t, updatePointMesh as u };
