import { r as registerInstance, e as createEvent, h } from './index-0c943849.js';
import './constants-35570903.js';
import './dataConstants-856cb1e9.js';
import './index-b3f1c3a1.js';
import { p as parseDuration } from './time-b732648c.js';
import { i as isThreshold } from './utils-96fe4147.js';
import { b as isMinimalStaticViewport } from './predicates-67461267.js';
import './number-a7331d73.js';
import './dataFilters-2772c214.js';
import './breachedThreshold-500f9d58.js';
import './getDataPoints-6f8b4e89.js';
import './three.module-06da257a.js';
import { w as webGLRenderer } from './webglContext-da311040.js';
import './_commonjsHelpers-1d681858.js';
import { l as lodash_throttle, D as DATE_RANGE_EMIT_EVENT_MS } from './constants-24b6dac6.js';
import { c as constructTableData } from './constructTableData-b239a9a1.js';
import { v as viewportStartDate, a as viewportEndDate, i as isInLiveMode } from './viewPort-8a84bb2e.js';
var ScTable = /** @class */ (function () {
    function ScTable(hostRef) {
        var _this = this;
        registerInstance(this, hostRef);
        this.dateRangeChange = createEvent(this, "dateRangeChange", 7);
        this.messageOverrides = {};
        /** Active Viewport */
        this.start = viewportStartDate(this.viewport);
        this.end = viewportEndDate(this.viewport);
        this.duration = !isMinimalStaticViewport(this.viewport)
            ? parseDuration(this.viewport.duration)
            : undefined;
        this.onUpdate = function (_a) {
            var start = _a.start, end = _a.end, duration = _a.duration;
            var hasViewPortChanged = viewportStartDate(_this.viewport).getTime() !== start.getTime() ||
                viewportEndDate(_this.viewport).getTime() !== end.getTime();
            var inLiveMode = isInLiveMode(_this.viewport);
            if (hasViewPortChanged && !inLiveMode) {
                _this.onDateRangeChange([start, end, _this.viewport.group]);
            }
            // Update active viewport
            _this.start = start;
            _this.end = end;
            _this.duration = duration;
        };
        this.onDateRangeChange = lodash_throttle(function (_a) {
            var start = _a[0], end = _a[1], from = _a[2];
            _this.dateRangeChange.emit([start, end, from]);
        }, DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.getThresholds = function () { return _this.annotations && _this.annotations.y ? _this.annotations.y.filter(isThreshold) : []; };
    }
    ScTable.prototype.onViewPortChange = function (newViewPort) {
        this.onUpdate(Object.assign(Object.assign({}, newViewPort), { duration: !isMinimalStaticViewport(newViewPort) ? parseDuration(newViewPort.duration) : undefined, start: viewportStartDate(this.viewport), end: viewportEndDate(this.viewport) }));
    };
    ScTable.prototype.componentDidLoad = function () {
        webGLRenderer.addChartScene({
            manager: {
                id: this.widgetId,
                viewportGroup: this.viewport.group,
                updateViewPort: this.onUpdate,
            },
            duration: this.duration,
        });
    };
    ScTable.prototype.disconnectedCallback = function () {
        // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
        webGLRenderer.removeChartScene(this.widgetId);
    };
    ScTable.prototype.render = function () {
        var rows = constructTableData({
            tableColumns: this.tableColumns,
            dataStreams: this.dataStreams,
            thresholds: this.getThresholds(),
            date: this.end,
        });
        var isEnabled = this.duration != null;
        return (h("sc-table-base", { columns: this.tableColumns, rows: rows, isEnabled: isEnabled, messageOverrides: this.messageOverrides }));
    };
    Object.defineProperty(ScTable, "watchers", {
        get: function () {
            return {
                "viewport": ["onViewPortChange"]
            };
        },
        enumerable: false,
        configurable: true
    });
    return ScTable;
}());
export { ScTable as sc_table };
