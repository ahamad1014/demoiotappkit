import { a as getBreachedThreshold } from './utils-96fe4147.js';
import { c as isNumberDataStream } from './predicates-67461267.js';
import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-06da257a.js';
import { n as numDataPoints, v as vertices, g as getCSSColorByString, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-8273b9c5.js';
import { g as getDistanceFromDuration } from './getDistanceFromDuration-5c7da5d2.js';
/* eslint-disable max-len */
var barVert = "\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nattribute vec2 bar;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  // Negative width here because we want to render the bars' width to the left side starting from its x position.\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * -width + bar.x, position.y * bar.y, 0.0, 1.0);\n  vColor = color;\n}\n";
var barFrag = "\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n";
/**
 * Display Constants
 *
 * Adjust these to scale the margins provided within the bar chart.
 * This represent which fraction of the 'width' of a given bar group a margin.
 */
var MARGIN_FACTOR = 1 / 6;
var getBarMargin = function (toClipSpace, resolution) { return getDistanceFromDuration(toClipSpace, resolution * MARGIN_FACTOR); };
/**
 * Get the bar width
 *
 * Returns the clipSpace width which each bar should be.
 * It is assumed that each bar within a group will have the same width.
 */
var getBarWidth = function (_a) {
    var toClipSpace = _a.toClipSpace, resolution = _a.resolution, numDataStreams = _a.numDataStreams;
    return (getDistanceFromDuration(toClipSpace, resolution) - getBarMargin(toClipSpace, resolution)) / numDataStreams;
};
// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated
// up front per `ChartScene`.
var NUM_POSITION_COMPONENTS = 2; // (x, y)
var NUM_COLOR_COMPONENTS = 3; // (r, g, b)
var numBars = function (streamVertexSets) {
    return streamVertexSets.reduce(function (totalBars, streamVertexSet) { return totalBars + streamVertexSet.length; }, 0);
};
var getUniformWidth = function (dataStreams, toClipSpace) {
    if (dataStreams.length === 0) {
        return 0;
    }
    var resolution = dataStreams[0].resolution;
    return getBarWidth({
        toClipSpace: toClipSpace,
        numDataStreams: dataStreams.length,
        resolution: resolution,
    });
};
var updateMesh = function (_a) {
    var dataStreams = _a.dataStreams, mesh = _a.mesh, toClipSpace = _a.toClipSpace, thresholds = _a.thresholds, thresholdOptions = _a.thresholdOptions;
    var streamVertexSets = dataStreams.filter(isNumberDataStream).map(function (stream) { return vertices(stream, stream.resolution); });
    // Set the number of instances of the bar are to be rendered.
    // eslint-disable-next-line no-param-reassign
    mesh.count = numBars(streamVertexSets);
    var geometry = mesh.geometry;
    var _b = geometry.attributes, color = _b.color, bar = _b.bar;
    var positionIndex = 0;
    var colorIndex = 0;
    streamVertexSets.forEach(function (streamVertexSet, setIndex) {
        streamVertexSet.forEach(function (currVertex) {
            var currX = currVertex[0], currY = currVertex[1], r = currVertex[2], g = currVertex[3], b = currVertex[4];
            /**
             * Subtracting setIndex * getUniformWidth(dataStreams, toClipSpace) because with each new
             * data stream, we want to render it side by side on the left side.
             */
            bar.array[positionIndex] = toClipSpace(currX) - setIndex * getUniformWidth(dataStreams, toClipSpace);
            bar.array[positionIndex + 1] = currY;
            var breachedThreshold = getBreachedThreshold(currY, thresholds);
            if (breachedThreshold == null || !thresholdOptions.showColor) {
                // Set bar color (r, g, b)
                color.array[colorIndex] = r;
                color.array[colorIndex + 1] = g;
                color.array[colorIndex + 2] = b;
            }
            else {
                var _a = getCSSColorByString(breachedThreshold.color), rr = _a[0], gg = _a[1], bb = _a[2];
                // Set bar color (r, g, b)
                color.array[colorIndex] = rr;
                color.array[colorIndex + 1] = gg;
                color.array[colorIndex + 2] = bb;
            }
            // Increment Indexes by the associated stride of the buffer
            colorIndex += NUM_COLOR_COMPONENTS;
            positionIndex += NUM_POSITION_COMPONENTS;
        });
    });
    bar.needsUpdate = true;
    color.needsUpdate = true;
};
// https://wwwtyro.net/2019/11/18/instanced-lines.html
// 2d vertices composing of two triangles which make up a square
// (0, 1) - - - (1, 1)
//   |  \         |
//   |     \      |
//   |        \   |
// (0, 0) - - - (1, 0)
var unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];
var initializeGeometry = function (geometry, bufferSize) {
    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));
    geometry.setAttribute('bar', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));
    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));
};
var barMesh = function (_a) {
    var dataStreams = _a.dataStreams, toClipSpace = _a.toClipSpace, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var instGeo = new InstancedBufferGeometry();
    var bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);
    // Create and populate geometry
    initializeGeometry(instGeo, bufferSize);
    /**
     * Create Bar Mesh
     *
     * The representation of the bars on a bar chart.
     *
     * Utilizes an instance of a single unit square, which then gets
     * stretched and transposed across the canvas.
     */
    var barChartMaterial = new RawShaderMaterial({
        vertexShader: barVert,
        fragmentShader: barFrag,
        side: DoubleSide,
        transparent: false,
        uniforms: {
            width: {
                value: getUniformWidth(dataStreams, toClipSpace),
            },
        },
    });
    var mesh = new InstancedMesh(instGeo, barChartMaterial, bufferSize);
    updateMesh({ dataStreams: dataStreams, mesh: mesh, toClipSpace: toClipSpace, thresholds: thresholds, thresholdOptions: thresholdOptions });
    // Prevent bounding sphere from being called
    mesh.frustumCulled = false;
    return mesh;
};
var updateBarMesh = function (_a) {
    var bars = _a.bars, dataStreams = _a.dataStreams, toClipSpace = _a.toClipSpace, hasDataChanged = _a.hasDataChanged, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    if (hasDataChanged) {
        // eslint-disable-next-line no-param-reassign
        bars.material.uniforms.width.value = getUniformWidth(dataStreams, toClipSpace);
        updateMesh({ dataStreams: dataStreams, mesh: bars, toClipSpace: toClipSpace, thresholds: thresholds, thresholdOptions: thresholdOptions });
    }
};
var maxDataPointsRendered = function (bars) { return bars.geometry.attributes.bar.array.length / NUM_POSITION_COMPONENTS; };
var chartScene = function (_a) {
    var dataStreams = _a.dataStreams, container = _a.container, viewport = _a.viewport, bufferFactor = _a.bufferFactor, minBufferSize = _a.minBufferSize, onUpdate = _a.onUpdate, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds;
    var scene = new Scene();
    var toClipSpace = clipSpaceConversion(viewport);
    scene.add(barMesh({ dataStreams: dataStreams, toClipSpace: toClipSpace, bufferFactor: bufferFactor, minBufferSize: minBufferSize, thresholdOptions: thresholdOptions, thresholds: thresholds }));
    return constructChartScene({ scene: scene, viewport: viewport, container: container, toClipSpace: toClipSpace, onUpdate: onUpdate });
};
var updateChartScene = function (_a) {
    var scene = _a.scene, dataStreams = _a.dataStreams, hasDataChanged = _a.hasDataChanged, minBufferSize = _a.minBufferSize, bufferFactor = _a.bufferFactor, viewport = _a.viewport, container = _a.container, onUpdate = _a.onUpdate, chartSize = _a.chartSize, thresholdOptions = _a.thresholdOptions, thresholds = _a.thresholds, hasAnnotationChanged = _a.hasAnnotationChanged;
    var bars = scene.scene.children[0];
    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the
    // chart scene, we must fully recreate the chart scene. This is a costly operation.
    var isDataOverflowingBuffer = maxDataPointsRendered(bars) < numDataPoints(dataStreams);
    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {
        return chartScene({
            onUpdate: onUpdate,
            dataStreams: dataStreams,
            container: container,
            viewport: viewport,
            minBufferSize: minBufferSize,
            bufferFactor: bufferFactor,
            chartSize: chartSize,
            thresholdOptions: thresholdOptions,
            thresholds: thresholds,
        });
    }
    updateBarMesh({
        bars: bars,
        dataStreams: dataStreams,
        toClipSpace: scene.toClipSpace,
        hasDataChanged: hasDataChanged,
        thresholdOptions: thresholdOptions,
        thresholds: thresholds,
    });
    return scene;
};
export { chartScene as c, updateChartScene as u };
