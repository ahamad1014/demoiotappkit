var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { D as DATA_ALIGNMENT } from './constants-35570903.js';
import { S as StreamType } from './dataConstants-856cb1e9.js';
import { a as getBreachedThreshold } from './utils-96fe4147.js';
import { a as isDefined } from './predicates-67461267.js';
import { p as pointBisector, g as getDataBeforeDate } from './dataFilters-2772c214.js';
import { g as getDataPoints } from './getDataPoints-6f8b4e89.js';
/**
 * Sorts points in order of their points values.
 * Places objects with no point at the end of the list.
 */
var sortTooltipPoints = function (attr) { return function (a, b) {
    if (a.point == null && b.point == null) {
        return 0;
    }
    if (a.point == null) {
        return -1;
    }
    if (b.point == null) {
        return 1;
    }
    if (attr(a.point) === attr(b.point)) {
        return 0;
    }
    return attr(b.point) > attr(a.point) ? 1 : -1;
}; };
/**
 * Closest Points
 *
 * Returns the closest point to the left, and right of a
 * given point in time..
 *
 * @param maxDistance - maximum distance, measured in terms of milliseconds. if not present, there is no max distance.
 */
var closestPoint = function (dataPoints, date, dataAlignment, maxDistance) {
    var idx = pointBisector.left(dataPoints, date);
    var leftPoint = dataPoints[idx - 1];
    var rightPoint = dataPoints[idx];
    /**
     * If a point falls on our point of time, return it immediately regardless of 'data alignment'.
     */
    if (leftPoint && leftPoint.x === date.getTime()) {
        return leftPoint;
    }
    if (rightPoint && rightPoint.x === date.getTime()) {
        return rightPoint;
    }
    /** Right Alignment */
    if (dataAlignment === DATA_ALIGNMENT.RIGHT) {
        if (!rightPoint) {
            return undefined;
        }
        if (maxDistance == null) {
            return rightPoint;
        }
        return rightPoint.x - date.getTime() <= maxDistance ? rightPoint : undefined;
    }
    /** Left Alignment */
    if (dataAlignment === DATA_ALIGNMENT.LEFT) {
        if (!leftPoint) {
            return undefined;
        }
        if (maxDistance == null) {
            return leftPoint;
        }
        return date.getTime() - leftPoint.x <= maxDistance ? leftPoint : undefined;
    }
    /** Either Alignment */
    // If only the left, or only the right point exist, go ahead and just return it.
    if (!leftPoint || !rightPoint) {
        return leftPoint || rightPoint;
    }
    // We are right bias because the interval between two points is the time span for the point on the right.
    return rightPoint;
};
/**
 * Get Active Points
 *
 * Returns at most one point per data stream - for each data stream, it finds the point which is
 * 1. within the given view port
 * 2. closest to the provided `selectedDate`
 *
 * Additionally, if `allowMultipleDates` is false, it will only return the points which are the closest
 * to the `selectedDate`. i.e. if you have 10 points that are all equally distant from the `selectedDate`,
 * all 10 are returned.
 *
 * However if you have 10 points of different dates, only the closest point would be returned.
 */
var activePoints = function (_a) {
    var viewport = _a.viewport, dataStreams = _a.dataStreams, selectedDate = _a.selectedDate, allowMultipleDates = _a.allowMultipleDates, dataAlignment = _a.dataAlignment, maxDurationFromDate = _a.maxDurationFromDate;
    var dataStreamUtilizedData = dataStreams.map(function (stream) { return ({
        streamId: stream.id,
        dataPoints: getDataBeforeDate(getDataPoints(stream, stream.resolution), viewport.end),
    }); });
    var selectedTimestamp = selectedDate.getTime();
    // Find the closest point to the selected date for each stream
    var points = dataStreamUtilizedData.map(function (_a) {
        var streamId = _a.streamId, dataPoints = _a.dataPoints;
        return ({
            streamId: streamId,
            point: closestPoint(dataPoints, selectedDate, dataAlignment, maxDurationFromDate),
        });
    });
    if (allowMultipleDates) {
        return points;
    }
    var distanceFromDate = function (p) { return Math.abs(p.x - selectedTimestamp); };
    // Sort in ascending order by there distance from the selected date
    var sortedPoints = points.sort(sortTooltipPoints(distanceFromDate));
    if (sortedPoints.length === 0) {
        return [];
    }
    var topPoint = sortedPoints[sortedPoints.length - 1].point;
    if (topPoint == null) {
        // everything must be a 'blank' point
        return sortedPoints;
    }
    // Filter such that only the points with a date equal to the date of the point which is closest to the selected date.
    return sortedPoints.filter(function (p) { return p.point && p.point.x === topPoint.x; });
};
var isHigherPriority = function (t1, t2) {
    if (t1 == null) {
        return t2;
    }
    if (t1.severity == null && t2.severity == null) {
        return t1;
    }
    if (t1.severity == null) {
        return t2;
    }
    if (t2.severity == null) {
        return t1;
    }
    return t1.severity <= t2.severity ? t1 : t2;
};
/**
 * Returns the most important threshold.
 *
 * The most important threshold is the visual which is most important to a user
 * This is determined via the `severity`. Lower severity means highest importance.
 *
 * If no thresholds are present with `severity`, the first threshold is returned.
 */
var highestPriorityThreshold = function (thresholds) {
    return thresholds.reduce(isHigherPriority, undefined);
};
/**
 * returns whether the given threshold can be applied to the requested data stream.
 *
 * EXPOSED FOR TESTING
 */
var thresholdAppliesToDataStream = function (threshold, dataStreamId) {
    var dataStreamIds = threshold.dataStreamIds;
    if (dataStreamIds == null) {
        return true;
    }
    return dataStreamIds.includes(dataStreamId);
};
/**
 * Returns all of the breached thresholds for any of the alarms associated with the requested data stream.
 *
 * Does NOT return them in any sort of priority order.
 *
 * EXPOSED FOR TESTING
 */
var breachedAlarmThresholds = function (_a) {
    var date = _a.date, dataStream = _a.dataStream, dataStreams = _a.dataStreams, thresholds = _a.thresholds;
    var alarmStreamIds = dataStream.associatedStreams != null
        ? dataStream.associatedStreams.filter(function (_a) {
            var type = _a.type;
            return type === StreamType.ALARM;
        }).map(function (_a) {
            var id = _a.id;
            return id;
        })
        : [];
    var isAssociatedAlarm = function (stream) { return alarmStreamIds.includes(stream.id); };
    var alarmStreams = dataStreams.filter(isAssociatedAlarm);
    // thresholds considered breech, across all alarms for the requested data stream
    var allBreachedAlarmThresholds = alarmStreams
        .map(function (stream) {
        var alarmThresholds = thresholds.filter(function (threshold) { return thresholdAppliesToDataStream(threshold, stream.id); });
        var latestAlarmValue = closestPoint(stream.data, date, DATA_ALIGNMENT.LEFT);
        return latestAlarmValue != null ? getBreachedThreshold(latestAlarmValue.y, alarmThresholds) : undefined;
    })
        .filter(isDefined);
    return allBreachedAlarmThresholds;
};
/**
 * Get the highest priority breached threshold.
 *
 * NOTE: If you do not want to get alarm thresholds, simply pass in an empty array for the `dataStreams`.
 */
var breachedThreshold = function (_a) {
    var value = _a.value, date = _a.date, thresholds = _a.thresholds, dataStreams = _a.dataStreams, dataStream = _a.dataStream;
    var applicableThresholds = thresholds.filter(function (threshold) { return thresholdAppliesToDataStream(threshold, dataStream.id); });
    var dataThreshold = value != null ? getBreachedThreshold(value, applicableThresholds) : undefined;
    var alarmThresholds = breachedAlarmThresholds({
        date: date,
        dataStream: dataStream,
        dataStreams: dataStreams,
        thresholds: thresholds,
    });
    return highestPriorityThreshold(__spreadArrays([dataThreshold], alarmThresholds).filter(isDefined));
};
export { activePoints as a, breachedThreshold as b, closestPoint as c, sortTooltipPoints as s };
