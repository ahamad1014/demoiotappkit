'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-0b3ed36d.js');
const constants = require('./constants-d154fa06.js');
const dataConstants = require('./dataConstants-02642889.js');
require('./terms-4f03f33b.js');
require('./index-0fadf3ad.js');
const time = require('./time-3c18516e.js');
const utils = require('./utils-43efeece.js');
const predicates = require('./predicates-739d43b9.js');
require('./number-46ecc337.js');
require('./dataFilters-b9b845d5.js');
const breachedThreshold = require('./breachedThreshold-19580034.js');
require('./getDataPoints-726a614b.js');
require('./three.module-c70df973.js');
const webglContext = require('./webglContext-8b04e2f6.js');
require('./_commonjsHelpers-ac2d0785.js');
const common = require('./common-9c0591ff.js');
const constants$1 = require('./constants-11a37182.js');
const viewPort = require('./viewPort-6cfbf3c2.js');
const validate = require('./validate-270f6bac.js');
const dataTypes = require('./dataTypes-bde2225c.js');
const Value = require('./Value-3156abf4.js');
const toolTipSettings = require('./toolTipSettings-daebe40b.js');
const helper = require('./helper-c4f1c588.js');

const scGridCss = "sc-grid .grid{--widget-min-width:190px;--widget-min-height:100px;display:grid;grid-template-columns:repeat(auto-fit, minmax(var(--widget-min-width), 1fr));grid-auto-rows:minmax(var(--widget-min-height), 1fr);grid-gap:10px;margin:10px}sc-grid .grid-wrapper{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:center;align-content:center}";

const ScGrid = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
    }
    render() {
        return (index.h("div", { class: "grid-wrapper" }, index.h("div", { class: "grid" }, index.h("slot", null))));
    }
};
ScGrid.style = scGridCss;

const ScGridTooltip = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.displayToolTip = () => {
            const container = this.el.querySelector('.tooltip-container');
            const tooltip = this.el.querySelector('.cell-tooltip');
            if (tooltip != null && container != null) {
                tooltip.style.display = 'block';
                this.tooltip = toolTipSettings.tippy(container, Object.assign(Object.assign({}, toolTipSettings.TIPPY_SETTINGS), { placement: 'left', content: tooltip }));
            }
        };
    }
    componentDidLoad() {
        this.displayToolTip();
    }
    disconnectedCallback() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    }
    render() {
        const thereIsSomeData = this.propertyPoint != null || this.alarmPoint != null;
        const color = this.breachedThreshold ? this.breachedThreshold.color : undefined;
        const displaysMoreThanTitle = thereIsSomeData && this.isEnabled;
        return (index.h("div", { class: "tooltip-container" }, index.h("div", { class: "cell-tooltip awsui-util-container awsui" }, index.h("div", { class: { 'awsui-util-container-header': true, 'awsui-util-mb-m': displaysMoreThanTitle } }, index.h("h3", null, this.title)), displaysMoreThanTitle && (index.h("div", null, index.h("div", { class: "awsui-util-spacing-v-s" }, this.propertyPoint && (index.h("div", null, index.h("div", { class: "awsui-util-label" }, "Latest value:"), index.h("div", null, index.h("strong", { style: { color } }, index.h(Value.Value, { value: this.propertyPoint.y })), ' ', "at", ' ', new Date(this.propertyPoint.x).toLocaleString('en-US', {
            hour12: true,
            minute: 'numeric',
            hour: 'numeric',
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
        })))), this.alarmPoint && (index.h("div", null, index.h("div", { class: "awsui-util-label" }, "Status:"), index.h("div", null, index.h("strong", { style: { color } }, index.h(Value.Value, { value: this.alarmPoint.y })), ' ', "since", ' ', new Date(this.alarmPoint.x).toLocaleString('en-US', {
            hour12: true,
            minute: 'numeric',
            hour: 'numeric',
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
        }), this.breachedThreshold && this.breachedThreshold.description && (index.h("div", null, "(", this.breachedThreshold.description, ")"))))))))), index.h("slot", null)));
    }
    get el() { return index.getElement(this); }
};

/* eslint-disable max-len */
const QuestionMarkIcon = () => (index.h("svg", { width: "25px", height: "25px", viewBox: "0 0 30 30" },
    index.h("defs", null,
        index.h("path", { d: "M14.8742857,24.7485714 C20.3277031,24.7485714 24.7485714,20.3277031 24.7485714,14.8742857 C24.7485714,9.4208683 20.3277031,5 14.8742857,5 C9.4208683,5 5,9.4208683 5,14.8742857 C5,20.3277031 9.4208683,24.7485714 14.8742857,24.7485714 Z M13.64,18.5771429 L16.1566605,18.5771429 L16.1566605,21.0457143 L13.64,21.0457143 L13.64,18.5771429 Z M10.7019512,12.6821943 C10.7134712,12.0601112 10.8200302,11.4898769 11.0216312,10.9714743 C11.2232322,10.4530717 11.5054693,10.0037962 11.8683512,9.62363429 C12.231233,9.24347238 12.6689886,8.94683535 13.1816312,8.73371429 C13.6942737,8.52059322 14.267388,8.41403429 14.9009912,8.41403429 C15.7189152,8.41403429 16.4014684,8.52635316 16.9486712,8.75099429 C17.4958739,8.97563541 17.9365095,9.25499262 18.2705912,9.58907429 C18.6046728,9.92315596 18.8437104,10.2831524 18.9877112,10.6690743 C19.1317119,11.0549962 19.2037112,11.4149926 19.2037112,11.7490743 C19.2037112,12.3020371 19.1317119,12.7570725 18.9877112,13.1141943 C18.8437104,13.4713161 18.6651522,13.776593 18.4520312,14.0300343 C18.2389101,14.2834756 18.0027525,14.4994734 17.7435512,14.6780343 C17.4843499,14.8565952 17.2395523,15.0351534 17.0091512,15.2137143 C16.77875,15.3922752 16.5742721,15.5967531 16.3957112,15.8271543 C16.2171503,16.0575554 16.1546517,16.3455526 16.1085714,16.6911543 L16.1085714,17.3477943 L13.64,17.3477943 L13.64,16.5701943 C13.64,15.9718011 13.7557976,15.6706595 13.9113184,15.3365778 C14.0668391,15.0024962 14.3480301,14.7068355 14.5553912,14.4706743 C14.7627522,14.2345131 14.98163,14.0300351 15.2120312,13.8572343 C15.4424323,13.6844334 15.6555502,13.5116351 15.8513912,13.3388343 C16.0472321,13.1660334 16.2056306,12.9759553 16.3265912,12.7685943 C16.4475518,12.5612332 16.5022712,12.3020358 16.4907512,11.9909943 C16.4907512,11.4610716 16.3611525,11.0693956 16.1019512,10.8159543 C15.8427499,10.562513 15.4827535,10.4357943 15.0219512,10.4357943 C14.7109096,10.4357943 14.4430723,10.4962737 14.2184312,10.6172343 C13.99379,10.7381949 13.8094719,10.8994733 13.6654712,11.1010743 C13.5214704,11.3026753 13.4149115,11.5388329 13.3457912,11.8095543 C13.2766708,12.0802756 13.2421112,12.3711527 13.2421112,12.6821943 L10.7019512,12.6821943 Z", id: "path-1" })),
    index.h("g", { fill: "none" },
        index.h("rect", { x: "0", y: "0", width: "30", height: "30" }),
        index.h("mask", { id: "mask-2", fill: "white" },
            index.h("use", { xlinkHref: "#path-1" })),
        index.h("g", { id: "Oval" }),
        index.h("g", { mask: "url(#mask-2)", fill: "#DEE0E2" },
            index.h("rect", { x: "0", y: "0", width: "30", height: "30" })))));

const ScHelpTooltip = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.displayToolTip = () => {
            const container = this.el.querySelector('.help-icon');
            const tooltip = this.el.querySelector('[role="tooltip"]');
            if (tooltip != null && container != null) {
                tooltip.style.display = 'block';
                this.tooltip = toolTipSettings.tippy(container, Object.assign(Object.assign({}, toolTipSettings.TIPPY_SETTINGS), { content: tooltip }));
            }
        };
    }
    disconnectedCallback() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    }
    render() {
        return (index.h("div", { class: "help-icon", tabIndex: -1, onMouseOver: this.displayToolTip, onFocus: this.displayToolTip }, index.h(QuestionMarkIcon, null), index.h("div", { role: "tooltip", class: "awsui-util-container awsui", style: { display: 'none' } }, index.h("div", { class: "awsui-util-spacing-v-s" }, index.h("p", null, this.message)))));
    }
    get el() { return index.getElement(this); }
};

/**
 * Given a list of infos, return the ones that are to be visualized.
 *
 * This will remove any alarms that don't have an associated property info.
 */
const removePairedAlarms = (streams) => {
    const alarmInfos = streams.filter(({ streamType }) => streamType === dataConstants.StreamType.ALARM);
    const propertyInfos = streams.filter(({ streamType }) => streamType !== dataConstants.StreamType.ALARM);
    // If an alarm is not 'part' of any property info, it is a stray and can be visualized.
    const isStrayAlarm = ({ id }) => !propertyInfos.some(({ associatedStreams = [] }) => associatedStreams.some(a => a.id === id));
    const strayAlarmInfos = alarmInfos.filter(isStrayAlarm);
    const visualizedInfoIds = [...propertyInfos, ...strayAlarmInfos].map(({ id }) => id);
    // Want to maintain the original order, so we will filter out what isn't included from our original input.
    return streams.filter(({ id }) => visualizedInfoIds.includes(id)).filter(predicates.isDefined);
};
/**
 * Returns alarm/property pairs.
 *
 * For instance, if you have one property with 3 alarms associated with it, this will return you 3 pairs in total. One pair for each alarm.
 */
const streamPairs = (dataStreams) => {
    const primaryInfos = removePairedAlarms(dataStreams);
    return primaryInfos
        .map(stream => {
        if (stream.streamType === dataConstants.StreamType.ALARM) {
            // if it's an alarm an not removed, that means it's not pair, and has no associated property.
            return [{ alarm: stream }];
        }
        const hasNoAssociatedAlarms = stream.associatedStreams == null || !stream.associatedStreams.some(({ type }) => type === dataConstants.StreamType.ALARM);
        if (hasNoAssociatedAlarms) {
            // No alarms, just report back the property
            return [{ property: stream }];
        }
        // Return on cell info for each alarm associated
        return (stream.associatedStreams || [])
            .map(({ id: associatedId }) => dataStreams.find(({ id: id2 }) => id2 === associatedId))
            .filter(predicates.isDefined)
            .map(alarmInfo => ({
            property: stream,
            alarm: alarmInfo,
        }));
    })
        .flat();
};

const scWidgetGridCss = "sc-widget-grid .help-icon-container{z-index:100;position:absolute;right:0;top:0}sc-widget-grid .container{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;height:100%;overflow:auto;position:relative;-ms-overflow-style:none;scrollbar-width:none}sc-widget-grid .container::-webkit-scrollbar{display:none}";

const title = ({ alarm, property }) => {
    if (property) {
        return property.detailedName || property.name;
    }
    if (alarm) {
        return alarm.detailedName || alarm.name;
    }
    return '';
};
const ScWidgetGrid = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.dateRangeChange = index.createEvent(this, "dateRangeChange", 7);
        this.widgetUpdated = index.createEvent(this, "widgetUpdated", 7);
        this.collapseVertically = true;
        this.isEditing = false;
        this.messageOverrides = {};
        /** Widget data stream names */
        this.names = [];
        /** Active Viewport */
        this.start = viewPort.viewportStartDate(this.viewport);
        this.end = viewPort.viewportEndDate(this.viewport);
        this.duration = !predicates.isMinimalStaticViewport(this.viewport)
            ? time.parseDuration(this.viewport.duration)
            : undefined;
        this.onDateRangeChange = constants$1.lodash_throttle(([start, end, from]) => {
            this.dateRangeChange.emit([start, end, from]);
        }, constants$1.DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.onUpdate = ({ start, end, duration }) => {
            const hasViewPortChanged = viewPort.viewportStartDate(this.viewport).getTime() !== start.getTime() ||
                viewPort.viewportEndDate(this.viewport).getTime() !== end.getTime();
            const inLiveMode = viewPort.isInLiveMode(this.viewport);
            if (hasViewPortChanged && !inLiveMode) {
                this.onDateRangeChange([start, end, this.viewport.group]);
            }
            // Update active viewport
            this.start = start;
            this.end = end;
            this.duration = duration;
        };
        /**
         * Emit the current widget configuration
         */
        this.emitUpdatedWidgetConfiguration = (dataStreams) => {
            const configUpdate = {
                movement: undefined,
                scale: undefined,
                layout: undefined,
                legend: undefined,
                annotations: this.annotations,
                axis: undefined,
                widgetId: this.widgetId,
                dataStreams: dataStreams ? common.getDataStreamForEventing(dataStreams) : this.dataStreams,
            };
            this.widgetUpdated.emit(configUpdate);
        };
        this.onChangeLabel = ({ streamId, name }) => {
            this.names = helper.updateName(this.names, name, streamId);
            this.onWidgetUpdated();
        };
        this.getPoints = () => breachedThreshold.activePoints({
            viewport: {
                start: this.start,
                end: this.end,
            },
            dataStreams: this.dataStreams,
            selectedDate: this.end,
            allowMultipleDates: true,
            dataAlignment: constants.DATA_ALIGNMENT.EITHER,
        });
        this.getBreachedThreshold = (point, dataStream) => breachedThreshold.breachedThreshold({
            value: point && point.y,
            date: predicates.isMinimalStaticViewport(this.viewport) ? new Date(this.viewport.end) : new Date(),
            dataStreams: this.dataStreams,
            dataStream,
            thresholds: utils.getThresholds(this.annotations),
        });
    }
    componentWillRender() {
        validate.validate(this);
    }
    componentDidLoad() {
        webglContext.webGLRenderer.addChartScene({
            manager: {
                id: this.widgetId,
                viewportGroup: this.viewport.group,
                updateViewPort: this.onUpdate,
            },
            duration: this.duration,
        });
    }
    onViewPortChange(newViewPort) {
        this.onUpdate(Object.assign(Object.assign({}, newViewPort), { duration: !predicates.isMinimalStaticViewport(newViewPort) ? time.parseDuration(newViewPort.duration) : undefined, start: viewPort.viewportStartDate(this.viewport), end: viewPort.viewportEndDate(this.viewport) }));
    }
    disconnectedCallback() {
        // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
        webglContext.webGLRenderer.removeChartScene(this.widgetId);
    }
    /**
     * On Widget Updated - Persist `DataStreamInfo`
     *
     * Emits an event which persists the current `NameValue[]` state into the
     * data stream info.
     */
    onWidgetUpdated() {
        // Construct the config update with the new names specified.
        const updatedDataStreams = this.dataStreams.map(dataStream => {
            const nameValue = this.names.find(({ id: nameId }) => dataStream.id === nameId);
            const name = nameValue != null ? nameValue.name : dataStream.name;
            return Object.assign(Object.assign({}, dataStream), { name });
        });
        this.emitUpdatedWidgetConfiguration(updatedDataStreams);
    }
    render() {
        var _a, _b;
        const isEnabled = this.duration != null;
        const points = this.getPoints();
        const pairs = streamPairs(this.dataStreams);
        const isMiniVersion = pairs.length > 1;
        return (index.h("div", { class: { tall: !this.collapseVertically } }, !isEnabled && (index.h("div", { class: "help-icon-container" }, index.h("sc-help-tooltip", { message: (_b = (_a = this.messageOverrides) === null || _a === void 0 ? void 0 : _a.liveModeOnly) !== null && _b !== void 0 ? _b : dataTypes.DEFAULT_MESSAGE_OVERRIDES.liveModeOnly }))), index.h("sc-grid", null, pairs.map(({ alarm, property }) => {
            const stream = alarm || property;
            if (stream == null) {
                return undefined;
            }
            const alarmPointWrapper = alarm && points.find(p => p.streamId === alarm.id);
            const propertyPointWrapper = property && points.find(p => p.streamId === property.id);
            const alarmPoint = alarmPointWrapper ? alarmPointWrapper.point : undefined;
            const propertyPoint = propertyPointWrapper ? propertyPointWrapper.point : undefined;
            const pointToEvaluateOn = alarmPoint || propertyPoint;
            const infoToEvaluateOn = alarm || property;
            const threshold = pointToEvaluateOn && infoToEvaluateOn && this.getBreachedThreshold(pointToEvaluateOn, infoToEvaluateOn);
            const alarmStream = alarm && this.dataStreams.find(s => s.id === alarm.id);
            const primaryStream = alarm ? alarmStream : property;
            return (index.h("sc-grid-tooltip", { title: title({ alarm, property }), propertyPoint: propertyPoint, alarmPoint: alarmPoint, breachedThreshold: threshold, isEnabled: isEnabled }, this.renderCell({
                isEnabled,
                trendStream: property,
                propertyStream: property,
                propertyPoint,
                alarmStream,
                alarmPoint,
                breachedThreshold: threshold,
                isEditing: this.isEditing,
                viewport: { start: this.start, end: this.end },
                miniVersion: isMiniVersion,
                onChangeLabel: this.onChangeLabel,
                messageOverrides: this.messageOverrides,
                labelsConfig: this.labelsConfig,
                icon: threshold ? threshold.icon : undefined,
                valueColor: threshold ? threshold.color : undefined,
                error: primaryStream ? primaryStream.error : undefined,
                isLoading: primaryStream ? primaryStream.isLoading || false : false,
                isRefreshing: primaryStream ? primaryStream.isRefreshing || false : false,
            })));
        }))));
    }
    static get watchers() { return {
        "viewport": ["onViewPortChange"]
    }; }
};
ScWidgetGrid.style = scWidgetGridCss;

exports.sc_grid = ScGrid;
exports.sc_grid_tooltip = ScGridTooltip;
exports.sc_help_tooltip = ScHelpTooltip;
exports.sc_widget_grid = ScWidgetGrid;
