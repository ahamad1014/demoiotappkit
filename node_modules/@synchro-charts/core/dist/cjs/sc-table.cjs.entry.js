'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-0b3ed36d.js');
require('./constants-d154fa06.js');
require('./dataConstants-02642889.js');
require('./index-0fadf3ad.js');
const time = require('./time-3c18516e.js');
const utils = require('./utils-43efeece.js');
const predicates = require('./predicates-739d43b9.js');
require('./number-46ecc337.js');
require('./dataFilters-b9b845d5.js');
require('./breachedThreshold-19580034.js');
require('./getDataPoints-726a614b.js');
require('./three.module-c70df973.js');
const webglContext = require('./webglContext-8b04e2f6.js');
require('./_commonjsHelpers-ac2d0785.js');
const constants$1 = require('./constants-11a37182.js');
const constructTableData = require('./constructTableData-1d71958f.js');
const viewPort = require('./viewPort-6cfbf3c2.js');

const ScTable = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.dateRangeChange = index.createEvent(this, "dateRangeChange", 7);
        this.messageOverrides = {};
        /** Active Viewport */
        this.start = viewPort.viewportStartDate(this.viewport);
        this.end = viewPort.viewportEndDate(this.viewport);
        this.duration = !predicates.isMinimalStaticViewport(this.viewport)
            ? time.parseDuration(this.viewport.duration)
            : undefined;
        this.onUpdate = ({ start, end, duration }) => {
            const hasViewPortChanged = viewPort.viewportStartDate(this.viewport).getTime() !== start.getTime() ||
                viewPort.viewportEndDate(this.viewport).getTime() !== end.getTime();
            const inLiveMode = viewPort.isInLiveMode(this.viewport);
            if (hasViewPortChanged && !inLiveMode) {
                this.onDateRangeChange([start, end, this.viewport.group]);
            }
            // Update active viewport
            this.start = start;
            this.end = end;
            this.duration = duration;
        };
        this.onDateRangeChange = constants$1.lodash_throttle(([start, end, from]) => {
            this.dateRangeChange.emit([start, end, from]);
        }, constants$1.DATE_RANGE_EMIT_EVENT_MS, {
            leading: true,
            trailing: true,
        });
        this.getThresholds = () => this.annotations && this.annotations.y ? this.annotations.y.filter(utils.isThreshold) : [];
    }
    onViewPortChange(newViewPort) {
        this.onUpdate(Object.assign(Object.assign({}, newViewPort), { duration: !predicates.isMinimalStaticViewport(newViewPort) ? time.parseDuration(newViewPort.duration) : undefined, start: viewPort.viewportStartDate(this.viewport), end: viewPort.viewportEndDate(this.viewport) }));
    }
    componentDidLoad() {
        webglContext.webGLRenderer.addChartScene({
            manager: {
                id: this.widgetId,
                viewportGroup: this.viewport.group,
                updateViewPort: this.onUpdate,
            },
            duration: this.duration,
        });
    }
    disconnectedCallback() {
        // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.
        webglContext.webGLRenderer.removeChartScene(this.widgetId);
    }
    render() {
        const rows = constructTableData.constructTableData({
            tableColumns: this.tableColumns,
            dataStreams: this.dataStreams,
            thresholds: this.getThresholds(),
            date: this.end,
        });
        const isEnabled = this.duration != null;
        return (index.h("sc-table-base", { columns: this.tableColumns, rows: rows, isEnabled: isEnabled, messageOverrides: this.messageOverrides }));
    }
    static get watchers() { return {
        "viewport": ["onViewPortChange"]
    }; }
};

exports.sc_table = ScTable;
