import"./p-2e85d2ee.js";import{a as t}from"./p-aa8712f2.js";import{I as a,R as e,D as s,a as r,B as o,b as n,S as i}from"./p-23766e60.js";import{n as h,v as l,g as c,c as p,a as d,b as m}from"./p-ce95813c.js";import{g as S}from"./p-14bccdc1.js";const u=1,f=33.5,C=[213,219,219],g=[135,149,150],v=({dataStreams:a,mesh:e,toClipSpace:s,thresholds:r,thresholdOptions:o,chartSize:n,alarms:i})=>{const h=a.map(t=>l(t,t.resolution));e.count=(t=>t.reduce((t,a)=>t+Math.max(a.length,0),0))(h);const{geometry:p}=e,{color:d,status:m}=p.attributes;let u=0,f=0;const v=1/a.length,w=v-33.5/n.height;h.forEach((a,e)=>{let n,h=C;a.forEach((l,p)=>{const z=a[p+1],[b]=z||[],[x,O]=l;null!=n&&n!==O&&(h=h===C?g:C);const y=t(O,r);if(null!=y&&o.showColor){const[t,a,e]=c(y.color);d.array[f]=t,d.array[f+1]=a,d.array[f+2]=e}else{const[t,a,e]=h;d.array[f]=t,d.array[f+1]=a,d.array[f+2]=e}f+=3,m.array[u]=s(x),m.array[u+1]=1-v*(e+1),m.array[u+2]=(({nextX:t,currX:a,toClipSpace:e,alarms:s})=>{const r=s?s.expires:void 0;if(null!=r){const s=S(e,r);return null==t?s:Math.min(S(e,t-a),s)}return S(e,null!=t?t-a:Date.now()-a)})({currX:x,nextX:b,toClipSpace:s,alarms:i}),m.array[u+3]=w,u+=4,n=O})}),m.needsUpdate=!0,d.needsUpdate=!0},w=[0,0,0,1,1,0,0,1,1,0,1,1],z=({alarms:t,dataStreams:l,container:c,viewport:m,bufferFactor:S,minBufferSize:u,onUpdate:f,thresholdOptions:C,thresholds:g,chartSize:z})=>{const b=new i,x=d(m);return b.add((({alarms:t,dataStreams:i,toClipSpace:l,bufferFactor:c,minBufferSize:p,thresholdOptions:d,thresholds:m,chartSize:S})=>{const u=new a,f=Math.max(p,h(i)*c);((t,a)=>{t.setAttribute("position",new o(new Float32Array(w),2)),t.setAttribute("status",new n(new Float32Array(4*a),4,!1)),t.setAttribute("color",new n(new Uint8Array(3*a),3,!0))})(u,f);const C=new e({vertexShader:"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec4 status;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  float width = status.z;\n  float height = status.w;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * width + status.x, position.y * height + status.y, 0.0, 1.0);\n  vColor = color;\n}\n",fragmentShader:"\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:s,transparent:!1}),g=new r(u,C,f);return v({dataStreams:i,mesh:g,toClipSpace:l,thresholds:m,thresholdOptions:d,chartSize:S,alarms:t}),g.frustumCulled=!1,g})({alarms:t,dataStreams:l,toClipSpace:x,bufferFactor:S,minBufferSize:u,thresholdOptions:C,thresholds:g,chartSize:z})),p({scene:b,viewport:m,container:c,toClipSpace:x,onUpdate:f})},b=({scene:t,alarms:a,dataStreams:e,minBufferSize:s,bufferFactor:r,viewport:o,container:n,onUpdate:i,chartSize:l,thresholdOptions:c,thresholds:p,hasDataChanged:d,hasAnnotationChanged:S,hasSizeChanged:u})=>{const f=t.scene.children[0];return(t=>t.geometry.attributes.status.array.length/4)(f)<h(e)||m(o,t.toClipSpace)?z({onUpdate:i,dataStreams:e,alarms:a,container:n,viewport:o,minBufferSize:s,bufferFactor:r,chartSize:l,thresholdOptions:c,thresholds:p}):((({alarms:t,statuses:a,dataStreams:e,toClipSpace:s,thresholdOptions:r,thresholds:o,chartSize:n,hasDataChanged:i,hasAnnotationChanged:h,hasSizeChanged:l})=>{(i||h||l)&&v({dataStreams:e,mesh:a,toClipSpace:s,thresholds:o,thresholdOptions:r,chartSize:n,alarms:t})})({alarms:a,statuses:f,dataStreams:e,toClipSpace:t.toClipSpace,thresholdOptions:c,thresholds:p,chartSize:l,hasDataChanged:d,hasAnnotationChanged:S,hasSizeChanged:u}),t)};export{u as H,f as S,z as c,b as u}