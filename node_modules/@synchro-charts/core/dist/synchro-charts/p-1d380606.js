import{a as t}from"./p-aa8712f2.js";import{c as e}from"./p-45352c6b.js";import{I as a,R as o,D as r,a as s,B as n,b as i,S as h}from"./p-23766e60.js";import{n as p,v as c,g as l,c as d,a as m,b as f}from"./p-ce95813c.js";import{g as S}from"./p-14bccdc1.js";const u=(t,e)=>{if(0===t.length)return 0;const{resolution:a}=t[0];return(({toClipSpace:t,resolution:e,numDataStreams:a})=>(S(t,e)-((t,e)=>S(t,e*(1/6)))(t,e))/a)({toClipSpace:e,numDataStreams:t.length,resolution:a})},v=({dataStreams:a,mesh:o,toClipSpace:r,thresholds:s,thresholdOptions:n})=>{const i=a.filter(e).map(t=>c(t,t.resolution));o.count=(t=>t.reduce((t,e)=>t+e.length,0))(i);const{geometry:h}=o,{color:p,bar:d}=h.attributes;let m=0,f=0;i.forEach((e,o)=>{e.forEach(e=>{const[i,h,c,S,v]=e;d.array[m]=r(i)-o*u(a,r),d.array[m+1]=h;const w=t(h,s);if(null!=w&&n.showColor){const[t,e,a]=l(w.color);p.array[f]=t,p.array[f+1]=e,p.array[f+2]=a}else p.array[f]=c,p.array[f+1]=S,p.array[f+2]=v;f+=3,m+=2})}),d.needsUpdate=!0,p.needsUpdate=!0},w=[0,0,0,1,1,0,0,1,1,0,1,1],b=({dataStreams:t,container:e,viewport:c,bufferFactor:l,minBufferSize:f,onUpdate:S,thresholdOptions:b,thresholds:C})=>{const g=new h,O=m(c);return g.add((({dataStreams:t,toClipSpace:e,bufferFactor:h,minBufferSize:c,thresholdOptions:l,thresholds:d})=>{const m=new a,f=Math.max(c,p(t)*h);((t,e)=>{t.setAttribute("position",new n(new Float32Array(w),2)),t.setAttribute("bar",new i(new Float32Array(2*e),2,!1)),t.setAttribute("color",new i(new Uint8Array(3*e),3,!0))})(m,f);const S=new o({vertexShader:"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nattribute vec2 bar;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  // Negative width here because we want to render the bars' width to the left side starting from its x position.\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * -width + bar.x, position.y * bar.y, 0.0, 1.0);\n  vColor = color;\n}\n",fragmentShader:"\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:r,transparent:!1,uniforms:{width:{value:u(t,e)}}}),b=new s(m,S,f);return v({dataStreams:t,mesh:b,toClipSpace:e,thresholds:d,thresholdOptions:l}),b.frustumCulled=!1,b})({dataStreams:t,toClipSpace:O,bufferFactor:l,minBufferSize:f,thresholdOptions:b,thresholds:C})),d({scene:g,viewport:c,container:e,toClipSpace:O,onUpdate:S})},C=({scene:t,dataStreams:e,hasDataChanged:a,minBufferSize:o,bufferFactor:r,viewport:s,container:n,onUpdate:i,chartSize:h,thresholdOptions:c,thresholds:l,hasAnnotationChanged:d})=>{const m=t.scene.children[0];return(t=>t.geometry.attributes.bar.array.length/2)(m)<p(e)||f(s,t.toClipSpace)||d?b({onUpdate:i,dataStreams:e,container:n,viewport:s,minBufferSize:o,bufferFactor:r,chartSize:h,thresholdOptions:c,thresholds:l}):((({bars:t,dataStreams:e,toClipSpace:a,hasDataChanged:o,thresholdOptions:r,thresholds:s})=>{o&&(t.material.uniforms.width.value=u(e,a),v({dataStreams:e,mesh:t,toClipSpace:a,thresholds:s,thresholdOptions:r}))})({bars:m,dataStreams:e,toClipSpace:t.toClipSpace,hasDataChanged:a,thresholdOptions:c,thresholds:l}),t)};export{b as c,C as u}