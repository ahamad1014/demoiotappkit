import{c as e}from"./p-aa8712f2.js";import{c as n}from"./p-45352c6b.js";import{I as t,R as o,D as i,a as r,B as a,b as s,S as l}from"./p-23766e60.js";import{n as h,v as c,c as p,a as d,b as x}from"./p-ce95813c.js";import{M as f,t as u,P as v,p as m,N as P,u as y}from"./p-ae1955c4.js";import{S as w}from"./p-9472c7cc.js";const g=e=>`\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n${e?"varying float yPositionPx;":""}\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  ${e?"yPositionPx = positionPx.y;":""}\n}\n`,S=`\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ${f}\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n`,B=({viewport:{end:e,start:n,yMax:t,yMin:o},toClipSpace:i,size:r})=>{const{width:a,height:s}=r;return{x:Math.abs((i(e.getTime())-i(n.getTime()))/a),y:Math.abs((t-o)/s)}},C=w,b=(e,t,o)=>{const i=e.filter(n).map(e=>c(e,e.resolution));t.count=(e=>e.reduce((e,n)=>e+Math.max(n.length,0),0))(i);const{geometry:r}=t,{currPoint:a,nextPoint:s,segmentColor:l}=r.attributes;let h=0,p=0;i.forEach(e=>{e.forEach((n,t)=>{const i=t===e.length-1?n:e[t+1],[r,c,d,x,f]=n,[u,v]=i;a.array[h]=o(r),a.array[h+1]=c,s.array[h]=o(u),s.array[h+1]=v,l.array[p]=d,l.array[p+1]=x,l.array[p+2]=f,p+=3,h+=2})}),a.needsUpdate=!0,s.needsUpdate=!0,l.needsUpdate=!0},D=[[0,-.5],[1,-.5],[1,.5],[0,-.5],[1,.5],[0,.5]],M=({dataStreams:n,chartSize:c,container:x,viewport:f,minBufferSize:P,bufferFactor:y,onUpdate:w,thresholdOptions:M,thresholds:z})=>{const _=new l,A=d(f),F=e(z),T=[];return T[1]=(({viewport:e,dataStreams:n,chartSize:l,minBufferSize:c,bufferFactor:p,toClipSpace:d,thresholdOptions:x,thresholds:f})=>{const v=new t,m=Math.max(c,h(n)*p);((e,n)=>{e.setAttribute("position",new a(new Float32Array(D.flat()),2)),e.setAttribute("currPoint",new s(new Float32Array(2*n),2,!1)),e.setAttribute("nextPoint",new s(new Float32Array(2*n),2,!1)),e.setAttribute("segmentColor",new s(new Uint8Array(3*n),3,!0))})(v,m);const{x:P,y}=B({viewport:e,toClipSpace:d,size:l}),{showColor:w=!0}=x,M=new o({vertexShader:g(w&&f.length>0),fragmentShader:w&&0!==f.length?S:"\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:i,transparent:!0,uniforms:{width:{value:C},xPixelDensity:{value:P},yPixelDensity:{value:y},thresholdBands:{value:u(f)}}}),z=new r(v,M,m);return z.frustumCulled=!1,b(n,z,d),z})({toClipSpace:A,chartSize:c,dataStreams:n,viewport:f,minBufferSize:P,bufferFactor:y,thresholdOptions:M,thresholds:F}),T[v]=m({dataStreams:n,minBufferSize:P,bufferFactor:y,toClipSpace:A,thresholdOptions:M,thresholds:F}),T.forEach(e=>_.add(e)),p({scene:_,viewport:f,container:x,toClipSpace:A,onUpdate:w})},z=({scene:e,dataStreams:n,chartSize:t,container:o,viewport:i,hasDataChanged:r,bufferFactor:a,minBufferSize:s,onUpdate:l,thresholdOptions:c,hasAnnotationChanged:p,thresholds:d})=>{const f=e.scene.children[1],u=e.scene.children[v];return(e=>e.geometry.attributes.position.array.length/P)(u)<h(n)||x(i,e.toClipSpace)||p?M({dataStreams:n,chartSize:t,container:o,viewport:i,minBufferSize:s,bufferFactor:a,onUpdate:l,thresholdOptions:c,thresholds:d}):((({chartSize:e,toClipSpace:n,lines:t,dataStreams:o,viewport:i,hasDataChanged:r})=>{const{x:a,y:s}=B({viewport:i,toClipSpace:n,size:e});t.material.uniforms.xPixelDensity.value=a,t.material.uniforms.yPixelDensity.value=s,r&&b(o,t,n)})({lines:f,dataStreams:n,chartSize:t,viewport:i,hasDataChanged:r,toClipSpace:e.toClipSpace}),y(n,u,e.toClipSpace,r),e)};export{M as c,z as u}