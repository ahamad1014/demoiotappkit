System.register(["./p-cba1ca58.system.js","./p-7d965fb9.system.js","./p-2792cb06.system.js","./p-4143ebfb.system.js","./p-7c8c455e.system.js","./p-84c918a4.system.js"],(function(e){"use strict";var t,n,r,i,a,o,s,l,c,h,u,v,p,d,f,y,x,m,P,w,g;return{setters:[function(e){t=e.c},function(e){n=e.c},function(e){r=e.I;i=e.R;a=e.D;o=e.a;s=e.B;l=e.b;c=e.S},function(e){h=e.n;u=e.v;v=e.c;p=e.a;d=e.b},function(e){f=e.M;y=e.t;x=e.P;m=e.p;P=e.N;w=e.u},function(e){g=e.S}],execute:function(){var S=function(e){return"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n"+(e?"varying float yPositionPx;":"")+"\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  "+(e?"yPositionPx = positionPx.y;":"")+"\n}\n"};var b="\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n";var C="\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND "+f+"\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n";var B=function(e){var t=e.viewport,n=t.end,r=t.start,i=t.yMax,a=t.yMin,o=e.toClipSpace,s=e.size;var l=s.width,c=s.height;var h=Math.abs((o(n.getTime())-o(r.getTime()))/l);var u=Math.abs((i-a)/c);return{x:h,y:u}};var D=g;var M=1;var z=2;var A=3;var T=function(e){var t=e.reduce((function(e,t){var n=Math.max(t.length,0);return e+n}),0);return t};var _=function(e,t,r){var i=e.filter(n).map((function(e){return u(e,e.resolution)}));t.count=T(i);var a=t.geometry;var o=a.attributes,s=o.currPoint,l=o.nextPoint,c=o.segmentColor;var h=0;var v=0;i.forEach((function(e){e.forEach((function(t,n){var i=n===e.length-1;var a=!i?e[n+1]:t;var o=t[0],u=t[1],p=t[2],d=t[3],f=t[4];var y=a[0],x=a[1];s.array[h]=r(o);s.array[h+1]=u;l.array[h]=r(y);l.array[h+1]=x;c.array[v]=p;c.array[v+1]=d;c.array[v+2]=f;v+=A;h+=z}))}));s.needsUpdate=true;l.needsUpdate=true;c.needsUpdate=true};var F=[[0,-.5],[1,-.5],[1,.5],[0,-.5],[1,.5],[0,.5]];var O=function(e,t){e.setAttribute("position",new s(new Float32Array(F.flat()),z));e.setAttribute("currPoint",new l(new Float32Array(t*z),z,false));e.setAttribute("nextPoint",new l(new Float32Array(t*z),z,false));e.setAttribute("segmentColor",new l(new Uint8Array(t*A),A,true))};var U=function(e){var t=e.viewport,n=e.dataStreams,s=e.chartSize,l=e.minBufferSize,c=e.bufferFactor,u=e.toClipSpace,v=e.thresholdOptions,p=e.thresholds;var d=new r;var f=Math.max(l,h(n)*c);O(d,f);var x=B({viewport:t,toClipSpace:u,size:s}),m=x.x,P=x.y;var w=v.showColor,g=w===void 0?true:w;var M=new i({vertexShader:S(g&&p.length>0),fragmentShader:!g||p.length===0?b:C,side:a,transparent:true,uniforms:{width:{value:D},xPixelDensity:{value:m},yPixelDensity:{value:P},thresholdBands:{value:y(p)}}});var z=new o(d,M,f);z.frustumCulled=false;_(n,z,u);return z};var E=function(e){var t=e.chartSize,n=e.toClipSpace,r=e.lines,i=e.dataStreams,a=e.viewport,o=e.hasDataChanged;var s=B({viewport:a,toClipSpace:n,size:t}),l=s.x,c=s.y;r.material.uniforms.xPixelDensity.value=l;r.material.uniforms.yPixelDensity.value=c;if(o){_(i,r,n)}};var j=e("c",(function(e){var n=e.dataStreams,r=e.chartSize,i=e.container,a=e.viewport,o=e.minBufferSize,s=e.bufferFactor,l=e.onUpdate,h=e.thresholdOptions,u=e.thresholds;var d=new c;var f=p(a);var y=t(u);var P=[];P[M]=U({toClipSpace:f,chartSize:r,dataStreams:n,viewport:a,minBufferSize:o,bufferFactor:s,thresholdOptions:h,thresholds:y});P[x]=m({dataStreams:n,minBufferSize:o,bufferFactor:s,toClipSpace:f,thresholdOptions:h,thresholds:y});P.forEach((function(e){return d.add(e)}));return v({scene:d,viewport:a,container:i,toClipSpace:f,onUpdate:l})}));var N=function(e){return e.geometry.attributes.position.array.length/P};var H=e("u",(function(e){var t=e.scene,n=e.dataStreams,r=e.chartSize,i=e.container,a=e.viewport,o=e.hasDataChanged,s=e.bufferFactor,l=e.minBufferSize,c=e.onUpdate,u=e.thresholdOptions,v=e.hasAnnotationChanged,p=e.thresholds;var f=t.scene.children[M];var y=t.scene.children[x];var m=N(y)<h(n);if(m||d(a,t.toClipSpace)||v){return j({dataStreams:n,chartSize:r,container:i,viewport:a,minBufferSize:l,bufferFactor:s,onUpdate:c,thresholdOptions:u,thresholds:p})}E({lines:f,dataStreams:n,chartSize:r,viewport:a,hasDataChanged:o,toClipSpace:t.toClipSpace});w(n,y,t.toClipSpace,o);return t}))}}}));