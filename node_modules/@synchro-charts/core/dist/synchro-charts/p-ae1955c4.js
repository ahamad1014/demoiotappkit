import{C as o}from"./p-063edcd0.js";import{c as n,s as r,a as e}from"./p-aa8712f2.js";import{c as i}from"./p-45352c6b.js";import{c as t,d as s,P as a,B as l}from"./p-23766e60.js";import{g as p,n as c,v as d}from"./p-ce95813c.js";const h=o=>`\nvarying vec3 vColor;\n${o?"varying float positionY;":""}\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  ${o?"positionY = position.y;":""}\n}\n`,u=13,f=i=>{if(0===i.length)return[];const t=n(i),s=r(t).reverse(),a=[],l=new Set;s.forEach((n,r)=>{const i=n.value;if(s[r].comparisonOperator===o.EQUAL){const[o,n,e]=p(s[r].color);return void a.push({upper:i,lower:i,color:[o,n,e]})}if(0===r){const o=e((Number.MAX_SAFE_INTEGER+i)/2,s);if(null!=o){const[n,r,e]=p(o.color);a.push({upper:Number.MAX_SAFE_INTEGER,lower:i,color:[n,r,e]})}return}const t=s[r-1],c=t.value;let d=(c+i)/2,h=e(d,s);if(null!=h&&!l.has(t.value)){const[o,n,r]=p(h.color);a.push({upper:c,lower:i,color:[o,n,r]}),l.add(t.value)}if(r===s.length-1){if(d=(i+Number.MIN_SAFE_INTEGER)/2,h=e(d,s),null!=h&&!l.has(i)){const[o,n,r]=p(h.color);a.push({lower:Number.MIN_SAFE_INTEGER,upper:i,color:[o,n,r]})}return}const u=s[r+1].value;if(d=(i+u)/2,h=e(d,s),null!=h&&!l.has(i)){const[o,r,e]=p(h.color);a.push({upper:i,lower:u,color:[o,r,e]}),l.add(n.value)}});let c=a[a.length-1];for(;a.length<13;){const o=s[s.length-1].value,n=e(Number.MIN_SAFE_INTEGER+o/2,s);if(null==n)a.push(c);else{const[r,e,i]=p(n.color);c={lower:Number.MIN_SAFE_INTEGER,upper:o,color:[r,e,i]},a.push(c)}}return a},m=0,v=o=>0===(null!=o[0]?o[0].resolution:null)?4:6.25,g=2,w=(o,n,r)=>{const e=n.filter(i).map(o=>d(o,o.resolution)).flat(),{position:t,pointColor:s}=o.attributes;e.forEach(([o,n,e,i,a],l)=>{t.array[2*l]=r(o),t.array[2*l+1]=n,s.array[3*l]=e,s.array[3*l+1]=i,s.array[3*l+2]=a}),o.setDrawRange(0,e.length),t.needsUpdate=!0,s.needsUpdate=!0},B=({toClipSpace:o,dataStreams:n,minBufferSize:r,bufferFactor:e,thresholdOptions:i,thresholds:p})=>{const d=Math.max(r,c(n)*e),u=new t;((o,n)=>{o.setAttribute("position",new l(new Float32Array(2*n),2)),o.setAttribute("pointColor",new l(new Uint8Array(3*n),3,!0))})(u,d),w(u,n,o);const{showColor:m=!0}=i,g=new s({vertexShader:h(m&&p.length>0),fragmentShader:m&&0!==p.length?"\n#define MAX_NUM_TOTAL_THRESHOLD_BAND 13\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n":"\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n",transparent:!0,uniforms:{pointDiameter:{value:v(n)},devicePixelRatio:{value:window.devicePixelRatio},thresholdBands:{value:f(p)}}}),B=new a(u,g);return B.frustumCulled=!1,B},_=(o,n,r,e=!0)=>{n.material.uniforms.pointDiameter.value=v(o),n.material.uniforms.devicePixelRatio.value=window.devicePixelRatio,e&&w(n.geometry,o,r)};export{u as M,g as N,m as P,B as p,f as t,_ as u}